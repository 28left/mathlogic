[
  {
    "objectID": "021_Oct22_computable_functions.html",
    "href": "021_Oct22_computable_functions.html",
    "title": "MATH 557 Oct 22",
    "section": "",
    "text": "A Turing machine \\(M\\) has an unlimited (both sides) tape which is partitioned into infinitely many cells. Each cell can hold a letter from a finite alphabet \\(s_1,\\ldots,s_n\\). At any time, only finitely many cells contain a symbol \\(\\in \\{s_1,\\ldots,s_n\\}\\). The empty cells are marked by a blank symbol \\(b\\) that is distinct from the \\(s_i\\). To facilitate things, we put \\(s_0 := b\\).\nAccess to the tape is given via a read-write head, which scans a single cell. The cell currently scanned can be read and its contents overwritten. The head can also move left or right. These actions can be made dependent on the contents of the scanned cell.\nThus, the machine can read any cell on the tape and read and write its contents. Furthermore, at any time \\(M\\) is in one of finitely many states \\(q_1,\\ldots, q_r\\). The states influence the behavior of \\(M\\).\nFormally, there are three types of operations (also called instructions): Suppose \\(M\\) is in state \\(q_i\\) and currently scan a cell with symbol \\(s_j\\) (\\(0 \\leq j \\leq n\\)).\n\n\\(q_i \\; s_j \\; s_k \\; q_l\\):   delete \\(s_j\\) write \\(s_k\\),\n\\(q_i \\; s_j \\;R \\; q_l\\):   move the head one cell to the right,\n\\(q_i \\; s_j \\; L \\; q_l\\):   move the head one cell to the left.\n\nIn each case, transition to \\(q_l\\) afterwards.\nA (deterministic) Turing program is a finite list of instructions (1)-(3) such that for any pair \\((q_i,s_k)\\) there is at most one instruction starting with \\(q_i, s_k\\).\n\n\nThe machine begins in state \\(q_1\\) scanning the leftmost cell not containing a blank and follows the instructions, describe above, according to the current state and the content of the current cell.\nIf the machine enters state \\(q_r\\), the computation halts (no further instructions will be applied). If it ever enters a state \\(q_i\\) and scans symbol \\(s_j\\) for which there is no applicable instruction, it stalls (in particular, there will be no output as defined below).\nDuring the computation, the machine will pass from one configuration to the next. A configuration consists of\n\nthe current state + the current cell scanned + the contents the left and right of the current cell up to the leftmost/rightmost non-blank symbol.\n\nEvery configuration is determined by a finite amount of information.\n\n\n\nThe alphabet of \\(M\\) consists of the symbols \\(0,1\\) (and \\(b\\) for a blank cell), the states are \\(q_1,q_2, q_3\\). The program \\(P\\) has the following instructions: \\[\n\\begin{aligned}\nq_1 & \\; 0  \\; R  \\; q_1\\\\\nq_1 & \\; 1  \\; 0  \\; q_2\\\\\nq_2 & \\; 0  \\; R  \\; q_2\\\\\nq_2 & \\; 1  \\; R  \\; q_1\\\\\nq_2 & \\; b \\; b \\; q_3\n\\end{aligned}\n\\]\nIn the initial configuration, the machine looks as follows:\n\n\n\n\n\n\n\n\n\\(\\downarrow\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n…\nb\nb\nb\n1\n1\n1\n1\n1\n1\nb\nb\nb\n…\n\n\n\n\n\\(M\\) follows the instructions above until it reaches the halting state \\(q_3\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\downarrow\\)\n\n\n\n\n\n\n\n…\nb\nb\nb\n0\n1\n0\n1\n0\n1\nb\nb\nb\n…\n\n\n\n\n\n\n\nSince Turing computations may not halt (either because they stall or enter an infinite loop and never reach the halting state), we define partial computable functions whose domain may be a proper subset of \\(\\mathbb{N}^n\\).\nWe use the following notation:\n\\[\n\\begin{aligned}\nf(\\vec{x}) \\downarrow: & \\iff  f \\text{ is defined for } \\vec{x} \\\\\nf(\\vec{x}) \\uparrow: & \\iff  f \\text{ is not defined for } \\vec{x} \\\\\nf(\\vec{x}) \\simeq g(\\vec{x}): & \\iff  f(\\vec{x})\\downarrow \\iff g(\\vec{x}) \\downarrow \\; \\text{ and } \\; f(\\vec{x})\\downarrow \\Longrightarrow f(\\vec{x}) = g(\\vec{x}).\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\nDefinition 1 \nWe say a Turing machine \\(M\\) with program \\(P\\) computes a partial function \\(f : \\subseteq \\mathbb{N} \\to \\mathbb{N}\\) if the machine, when starting with \\(n+1\\) many \\(1\\)’s, ends in state \\(q_r\\) if and only if \\(n\\) is in the domain of \\(f\\), and in this case, when \\(M\\) reaches state \\(q_r\\), there are exactly \\(f(n)\\) many \\(1\\)’s on the tape (not necessarily contiguous).\nA partial function \\(f\\) is Turing computable if and only if there exists a Turing machine \\(M\\) and a program \\(P\\) that computes it.\n\n\n\n\nThe definition for multidimensional functions is similar.\n\n\n\n\nSheperdson and Sturgis proposed a variant of a machine model in 1963: An unlimited register machine (URM) has an infinite number of registers \\(R_1,\\ldots,R_l, \\dots\\), each containing a natural number; we use \\(r_n\\) to denote the number in register \\(R_n\\). These numbers are modified by a URM according to the following types of instructions:\n\n\n\n\n\n\n\n\n\nInstruction\nOperation\nAlternative Form\nDescription\n\n\n\n\n\\(O(n)\\):\n\\(0 \\to R_n\\)\nor \\(r_n:=0\\)\nreplace \\(r_n\\) with \\(0\\)\n\n\n\\(S(n)\\):\n\\(r_n +1 \\to R_n\\)\nor \\(r_n:= r_n+1\\)\nadd 1 to \\(r_n\\)\n\n\n\\(T(m,n)\\):\n\\(r_m \\to R_n\\)\nor \\(r_n:= r_m\\)\nreplace \\(r_n\\) with \\(r_m\\)\n\n\n\\(J(m,n,q)\\):\nif \\(r_n = r_m\\), then jump to the \\(q\\)th instruction, otherwise proceed to the next.\n\n\n\n\n\nNote: The jump instruction \\(J(m,n,q)\\) spans multiple columns in the original layout since it has a different structure than the other instructions. A program is a numbered finite sequence of such instructions, \\(P=(I_1,\\ldots,I_k)\\). To run a a program, the URM must be provided with an initial configuration of the registers, i.e. a sequence \\((a_i)_{n \\in \\mathbb{N}}\\) such that \\(r_i = a_i\\) for all \\(i\\). The machine then executes its program line-by-line, unless it encounters a jump instruction (in which case it performs the test and, if applicable, jumps to the given instruction). The computation halts if there is no “next” instruction, that is, either there is no next line to execute or the instruction given in a \\(J\\)-type line does not exist.\n\n\n\\[\n\\begin{aligned}\nI_1: && J(1,2,6)\\\\\nI_2:&& S(2)\\\\\nI_3:&& S(3)\\\\\nI_4:&& J(1,2,6)\\\\\nI_5:&& J(1,1,2)\\\\\nI_6:&& T(3,1)\n\\end{aligned}\n\\]\nIf the URM starts with the number \\(9\\) in the 1st and \\(5\\) in the 2nd register (and 0 in all others), it produces the number \\(4\\) in the 3rd register after several steps and then reaches instruction \\(I_6\\), which transfers the number \\(4\\) to the 1st register; since no further instruction follows, the program halts.\n\n\n\n\n\n\n\n\n\n\nDefinition 2 Let \\(f\\) be a partial \\(n\\)-ary function on the natural numbers, \\(P\\) a program, and let \\(a_1,\\ldots, a_n, b\\) be given numbers. We say \\(P\\) on input \\(a_1, \\ldots, a_n\\) converges to \\(b\\), written \\(P(a_1,\\ldots,a_n) \\downarrow b\\), if the run of \\(P\\) with initial configuration \\(a_1, \\dots, a_n, 0, 0, 0, \\dots\\) halts after finitely many steps and the number \\(b\\) is in the 1st register.\n\\(P\\) computes \\(f\\) if and only if for all \\(a_1,\\ldots,a_n, b\\) we have\n\\[\nP(a_1,\\ldots,a_n) \\downarrow b \\; \\iff \\;  f(a_1,\\ldots,a_n) \\text{ is defined and equals } b.\n\\]\nWe say \\(f\\) is URM-computable if and only if there exists a program \\(P\\) that computes \\(f\\).\n\n\n\n\n\n\n\n\nThere are further approaches to formalize the notion of computable functions:\n\nGödel-Herbrand-Kleene (1936): general recursive functions defined via an equational calculus\nChurch (1936): \\(\\lambda\\)-definable functions\nGödel-Kleene (1936): \\(\\mu\\)-recursive functions\nPost (1943): computable functions via canonical deduction systems\nMarkov (1951): computable functions via algorithms over finite alphabets\n\nAll these definitions turned out to be formally equivalent, and moreover, every individual (intuitively) computable function has so far been shown to be computable in the above formal sense, which has given rise to the following thesis:\n\n\n\n\n\n\nChurch-Turing Thesis\n\n\n\nThe (intuitively) computable functions are precisely the (in one of the above senses) formally computable functions.\n\n\n\n\n\nWe include, without detailed proofs, some basic facts and consequences regarding the enumeration of computable functions.\nSince all programs can be effectively enumerated (in any formalization, they are finite sequences over a countable alhpabet), there is an effective enumeration \\(\\varphi_0, \\varphi_1, \\ldots, \\varphi_n, \\ldots\\) of all unary computable (partial) functions. In particular, given an index \\(n\\), we can effectively produce a (Turing-, URM-, …) program that computes \\(\\varphi_n\\).\nUsing a diagonal argument, one obtains from this:\n\nthere exists a total function \\(f: \\mathbb{N} \\to \\mathbb{N}\\) that is not computable:\n\n\\[f(n) =\\begin{cases}\n    \\varphi_n(n)+1  & \\text{if } \\varphi_n(n) \\text{ is defined}, \\\\\n  0    & \\text{otherwise}.\n\\end{cases}\\]\nThus, while there exists an enumeration of all total computable functions, this enumeration itself cannot be computable.\nThe following predicates are also not decidable (i.e., their characteristic functions are not computable):\n\n\\(\\varphi_n(n)\\) is defined,\n\\(\\varphi_n\\) is a total function,\n\\(\\varphi_n\\) is the constant function 0,\n\\(\\varphi_n = \\varphi_m\\),\nthe \\(n\\)-th program with input \\(n\\) (more generally with input \\(m\\)) halts after finitely many steps (the halting problem).\n\nUniversal functions (or programs): For every computable 2-ary function \\(f\\), there exists a total computable function \\(k\\) with \\(f(n,m) = \\varphi_{k(n)}(m)\\); the 2-ary function \\(\\varphi(n,m)= \\varphi_n(m)\\) is computable.",
    "crumbs": [
      "10/22 - Computable functions"
    ]
  },
  {
    "objectID": "021_Oct22_computable_functions.html#turing-machines",
    "href": "021_Oct22_computable_functions.html#turing-machines",
    "title": "MATH 557 Oct 22",
    "section": "",
    "text": "A Turing machine \\(M\\) has an unlimited (both sides) tape which is partitioned into infinitely many cells. Each cell can hold a letter from a finite alphabet \\(s_1,\\ldots,s_n\\). At any time, only finitely many cells contain a symbol \\(\\in \\{s_1,\\ldots,s_n\\}\\). The empty cells are marked by a blank symbol \\(b\\) that is distinct from the \\(s_i\\). To facilitate things, we put \\(s_0 := b\\).\nAccess to the tape is given via a read-write head, which scans a single cell. The cell currently scanned can be read and its contents overwritten. The head can also move left or right. These actions can be made dependent on the contents of the scanned cell.\nThus, the machine can read any cell on the tape and read and write its contents. Furthermore, at any time \\(M\\) is in one of finitely many states \\(q_1,\\ldots, q_r\\). The states influence the behavior of \\(M\\).\nFormally, there are three types of operations (also called instructions): Suppose \\(M\\) is in state \\(q_i\\) and currently scan a cell with symbol \\(s_j\\) (\\(0 \\leq j \\leq n\\)).\n\n\\(q_i \\; s_j \\; s_k \\; q_l\\):   delete \\(s_j\\) write \\(s_k\\),\n\\(q_i \\; s_j \\;R \\; q_l\\):   move the head one cell to the right,\n\\(q_i \\; s_j \\; L \\; q_l\\):   move the head one cell to the left.\n\nIn each case, transition to \\(q_l\\) afterwards.\nA (deterministic) Turing program is a finite list of instructions (1)-(3) such that for any pair \\((q_i,s_k)\\) there is at most one instruction starting with \\(q_i, s_k\\).\n\n\nThe machine begins in state \\(q_1\\) scanning the leftmost cell not containing a blank and follows the instructions, describe above, according to the current state and the content of the current cell.\nIf the machine enters state \\(q_r\\), the computation halts (no further instructions will be applied). If it ever enters a state \\(q_i\\) and scans symbol \\(s_j\\) for which there is no applicable instruction, it stalls (in particular, there will be no output as defined below).\nDuring the computation, the machine will pass from one configuration to the next. A configuration consists of\n\nthe current state + the current cell scanned + the contents the left and right of the current cell up to the leftmost/rightmost non-blank symbol.\n\nEvery configuration is determined by a finite amount of information.\n\n\n\nThe alphabet of \\(M\\) consists of the symbols \\(0,1\\) (and \\(b\\) for a blank cell), the states are \\(q_1,q_2, q_3\\). The program \\(P\\) has the following instructions: \\[\n\\begin{aligned}\nq_1 & \\; 0  \\; R  \\; q_1\\\\\nq_1 & \\; 1  \\; 0  \\; q_2\\\\\nq_2 & \\; 0  \\; R  \\; q_2\\\\\nq_2 & \\; 1  \\; R  \\; q_1\\\\\nq_2 & \\; b \\; b \\; q_3\n\\end{aligned}\n\\]\nIn the initial configuration, the machine looks as follows:\n\n\n\n\n\n\n\n\n\\(\\downarrow\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n…\nb\nb\nb\n1\n1\n1\n1\n1\n1\nb\nb\nb\n…\n\n\n\n\n\\(M\\) follows the instructions above until it reaches the halting state \\(q_3\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\downarrow\\)\n\n\n\n\n\n\n\n…\nb\nb\nb\n0\n1\n0\n1\n0\n1\nb\nb\nb\n…\n\n\n\n\n\n\n\nSince Turing computations may not halt (either because they stall or enter an infinite loop and never reach the halting state), we define partial computable functions whose domain may be a proper subset of \\(\\mathbb{N}^n\\).\nWe use the following notation:\n\\[\n\\begin{aligned}\nf(\\vec{x}) \\downarrow: & \\iff  f \\text{ is defined for } \\vec{x} \\\\\nf(\\vec{x}) \\uparrow: & \\iff  f \\text{ is not defined for } \\vec{x} \\\\\nf(\\vec{x}) \\simeq g(\\vec{x}): & \\iff  f(\\vec{x})\\downarrow \\iff g(\\vec{x}) \\downarrow \\; \\text{ and } \\; f(\\vec{x})\\downarrow \\Longrightarrow f(\\vec{x}) = g(\\vec{x}).\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\nDefinition 1 \nWe say a Turing machine \\(M\\) with program \\(P\\) computes a partial function \\(f : \\subseteq \\mathbb{N} \\to \\mathbb{N}\\) if the machine, when starting with \\(n+1\\) many \\(1\\)’s, ends in state \\(q_r\\) if and only if \\(n\\) is in the domain of \\(f\\), and in this case, when \\(M\\) reaches state \\(q_r\\), there are exactly \\(f(n)\\) many \\(1\\)’s on the tape (not necessarily contiguous).\nA partial function \\(f\\) is Turing computable if and only if there exists a Turing machine \\(M\\) and a program \\(P\\) that computes it.\n\n\n\n\nThe definition for multidimensional functions is similar.",
    "crumbs": [
      "10/22 - Computable functions"
    ]
  },
  {
    "objectID": "021_Oct22_computable_functions.html#register-machines",
    "href": "021_Oct22_computable_functions.html#register-machines",
    "title": "MATH 557 Oct 22",
    "section": "",
    "text": "Sheperdson and Sturgis proposed a variant of a machine model in 1963: An unlimited register machine (URM) has an infinite number of registers \\(R_1,\\ldots,R_l, \\dots\\), each containing a natural number; we use \\(r_n\\) to denote the number in register \\(R_n\\). These numbers are modified by a URM according to the following types of instructions:\n\n\n\n\n\n\n\n\n\nInstruction\nOperation\nAlternative Form\nDescription\n\n\n\n\n\\(O(n)\\):\n\\(0 \\to R_n\\)\nor \\(r_n:=0\\)\nreplace \\(r_n\\) with \\(0\\)\n\n\n\\(S(n)\\):\n\\(r_n +1 \\to R_n\\)\nor \\(r_n:= r_n+1\\)\nadd 1 to \\(r_n\\)\n\n\n\\(T(m,n)\\):\n\\(r_m \\to R_n\\)\nor \\(r_n:= r_m\\)\nreplace \\(r_n\\) with \\(r_m\\)\n\n\n\\(J(m,n,q)\\):\nif \\(r_n = r_m\\), then jump to the \\(q\\)th instruction, otherwise proceed to the next.\n\n\n\n\n\nNote: The jump instruction \\(J(m,n,q)\\) spans multiple columns in the original layout since it has a different structure than the other instructions. A program is a numbered finite sequence of such instructions, \\(P=(I_1,\\ldots,I_k)\\). To run a a program, the URM must be provided with an initial configuration of the registers, i.e. a sequence \\((a_i)_{n \\in \\mathbb{N}}\\) such that \\(r_i = a_i\\) for all \\(i\\). The machine then executes its program line-by-line, unless it encounters a jump instruction (in which case it performs the test and, if applicable, jumps to the given instruction). The computation halts if there is no “next” instruction, that is, either there is no next line to execute or the instruction given in a \\(J\\)-type line does not exist.\n\n\n\\[\n\\begin{aligned}\nI_1: && J(1,2,6)\\\\\nI_2:&& S(2)\\\\\nI_3:&& S(3)\\\\\nI_4:&& J(1,2,6)\\\\\nI_5:&& J(1,1,2)\\\\\nI_6:&& T(3,1)\n\\end{aligned}\n\\]\nIf the URM starts with the number \\(9\\) in the 1st and \\(5\\) in the 2nd register (and 0 in all others), it produces the number \\(4\\) in the 3rd register after several steps and then reaches instruction \\(I_6\\), which transfers the number \\(4\\) to the 1st register; since no further instruction follows, the program halts.\n\n\n\n\n\n\n\n\n\n\nDefinition 2 Let \\(f\\) be a partial \\(n\\)-ary function on the natural numbers, \\(P\\) a program, and let \\(a_1,\\ldots, a_n, b\\) be given numbers. We say \\(P\\) on input \\(a_1, \\ldots, a_n\\) converges to \\(b\\), written \\(P(a_1,\\ldots,a_n) \\downarrow b\\), if the run of \\(P\\) with initial configuration \\(a_1, \\dots, a_n, 0, 0, 0, \\dots\\) halts after finitely many steps and the number \\(b\\) is in the 1st register.\n\\(P\\) computes \\(f\\) if and only if for all \\(a_1,\\ldots,a_n, b\\) we have\n\\[\nP(a_1,\\ldots,a_n) \\downarrow b \\; \\iff \\;  f(a_1,\\ldots,a_n) \\text{ is defined and equals } b.\n\\]\nWe say \\(f\\) is URM-computable if and only if there exists a program \\(P\\) that computes \\(f\\).",
    "crumbs": [
      "10/22 - Computable functions"
    ]
  },
  {
    "objectID": "021_Oct22_computable_functions.html#church-turing-thesis",
    "href": "021_Oct22_computable_functions.html#church-turing-thesis",
    "title": "MATH 557 Oct 22",
    "section": "",
    "text": "There are further approaches to formalize the notion of computable functions:\n\nGödel-Herbrand-Kleene (1936): general recursive functions defined via an equational calculus\nChurch (1936): \\(\\lambda\\)-definable functions\nGödel-Kleene (1936): \\(\\mu\\)-recursive functions\nPost (1943): computable functions via canonical deduction systems\nMarkov (1951): computable functions via algorithms over finite alphabets\n\nAll these definitions turned out to be formally equivalent, and moreover, every individual (intuitively) computable function has so far been shown to be computable in the above formal sense, which has given rise to the following thesis:\n\n\n\n\n\n\nChurch-Turing Thesis\n\n\n\nThe (intuitively) computable functions are precisely the (in one of the above senses) formally computable functions.",
    "crumbs": [
      "10/22 - Computable functions"
    ]
  },
  {
    "objectID": "021_Oct22_computable_functions.html#enumerability-of-programs-and-computable-functions",
    "href": "021_Oct22_computable_functions.html#enumerability-of-programs-and-computable-functions",
    "title": "MATH 557 Oct 22",
    "section": "",
    "text": "We include, without detailed proofs, some basic facts and consequences regarding the enumeration of computable functions.\nSince all programs can be effectively enumerated (in any formalization, they are finite sequences over a countable alhpabet), there is an effective enumeration \\(\\varphi_0, \\varphi_1, \\ldots, \\varphi_n, \\ldots\\) of all unary computable (partial) functions. In particular, given an index \\(n\\), we can effectively produce a (Turing-, URM-, …) program that computes \\(\\varphi_n\\).\nUsing a diagonal argument, one obtains from this:\n\nthere exists a total function \\(f: \\mathbb{N} \\to \\mathbb{N}\\) that is not computable:\n\n\\[f(n) =\\begin{cases}\n    \\varphi_n(n)+1  & \\text{if } \\varphi_n(n) \\text{ is defined}, \\\\\n  0    & \\text{otherwise}.\n\\end{cases}\\]\nThus, while there exists an enumeration of all total computable functions, this enumeration itself cannot be computable.\nThe following predicates are also not decidable (i.e., their characteristic functions are not computable):\n\n\\(\\varphi_n(n)\\) is defined,\n\\(\\varphi_n\\) is a total function,\n\\(\\varphi_n\\) is the constant function 0,\n\\(\\varphi_n = \\varphi_m\\),\nthe \\(n\\)-th program with input \\(n\\) (more generally with input \\(m\\)) halts after finitely many steps (the halting problem).\n\nUniversal functions (or programs): For every computable 2-ary function \\(f\\), there exists a total computable function \\(k\\) with \\(f(n,m) = \\varphi_{k(n)}(m)\\); the 2-ary function \\(\\varphi(n,m)= \\varphi_n(m)\\) is computable.",
    "crumbs": [
      "10/22 - Computable functions"
    ]
  },
  {
    "objectID": "027_Nov7_PA-proofs.html",
    "href": "027_Nov7_PA-proofs.html",
    "title": "Math 557 Nov 7",
    "section": "",
    "text": "Recall the axioms of \\(\\mathsf{PA}\\):\n\nP1 \\(\\quad\\) \\(Sx \\ne 0\\)\nP2 \\(\\quad\\) \\(Sx=Sy \\to x=y\\)\nP3 \\(\\quad\\) \\(x+0 = x\\)\nP4 \\(\\quad\\) \\(x+Sy =S(x+y)\\)\nP5 \\(\\quad\\) \\(x \\cdot 0 = 0\\)\nP6 \\(\\quad\\) \\(x \\cdot Sy = x \\cdot y + x\\)\nInd\\({}_\\varphi\\) \\(\\;\\) \\(\\varphi(0) \\, \\wedge \\, \\forall x (\\varphi(x) \\to \\varphi(Sx)) \\to \\forall x \\; \\varphi(x)\\)\n\n\n\n\n\n\n\n\nExercise 1 \nShow that \\(\\mathsf{PA} \\vdash \\forall x (Sx \\neq x)\\)\n\n\n\n\nBut we need induction to prove this, even if we throw in another axiom:\n\nP7 \\(\\quad\\) \\(\\forall x \\: (x \\neq 0 \\to \\exists y (x = Sy))\\)\n\nThe system (P1)-(P7) is referred to as Robinson’s \\(\\mathsf{Q}\\)\n\n\n\n\n\n\n\nExercise 2 \nShow that \\(Q \\nvdash \\forall x (Sx \\neq x)\\)\n(Construct a model of \\(\\mathsf{Q}\\) by adding a “point at infinity” to \\(\\mathbb{N}\\) and defining the operations \\(S, +\\) accordingly.)\nIf we use induction in the metatheory (i.e. the theory we are using to reason about \\(\\mathsf{Q}\\), \\(\\mathsf{PA}\\), etc.), we can still show\n\\[\\text{for all } n \\in \\mathbb{N}, \\quad \\mathsf{Q} \\vdash S\\underline{n} \\neq \\underline{n}\\]\n\n\n\n\n\n\n\nWe saw in class that \\(\\mathsf{PA}^-\\) proves all true \\(\\Sigma_1\\)-statements about \\(\\mathbb{N}\\). This is due to two facts:\n\n\\(\\Delta_0\\)-formulas are absolute between structures and end-extensions thereof.\nAny model \\(\\mathcal{M}\\) of \\(\\mathsf{PA}^-\\) is an end-extension of (an isomorphic copy of) \\(\\mathbb{N}\\).\n\nTo prove the second fact, we need to show two things:\n\nThe mapping \\(\\iota: n \\mapsto \\underline{n}^{\\mathcal{M}}\\) is an embedding (so \\(\\iota(\\mathbb{N})\\) is a substructure of \\(\\mathcal{M}\\) isomorphic to \\(\\mathbb{N}\\)).\nAny element \\(y \\in M\\) with \\(y &lt;^{\\mathcal{M}} \\underline{n}^{\\mathcal{M}}\\) is itself some \\(\\underline{m}^{\\mathcal{M}}\\).\n\nThe first item is established in the next exercise.\n\n\n\n\n\n\n\nExercise 3 \nShow that for all natural numbers \\(n,k,l\\),\n\\[\n\\begin{aligned}\nn = k+l & \\quad \\Longrightarrow \\quad \\mathsf{PA}^- \\vdash \\underline{n}= \\underline{k}+ \\underline{l} \\\\\nn = k \\cdot l & \\quad \\Longrightarrow \\quad \\mathsf{PA}^- \\vdash \\underline{n}= \\underline{k} \\cdot \\underline{l} \\\\\nn &lt; k& \\quad \\Longrightarrow \\quad  \\mathsf{PA}^- \\vdash \\underline{n} &lt; \\underline{k}\\\\\n\\end{aligned}\n\\]\n(You prove this by induction in the metatheory. For example, for the first statement, the case \\(k=0\\) follows from axiom (A6). For the inductive step, use axiom (A1).)\n\n\n\n\nFor the second item:\n\n\n\n\n\n\n\nExercise 4 \nShow that for all \\(k \\in \\mathbb{N}\\),\n\\[\n\\mathsf{PA}^- \\vdash \\forall x \\:(x \\le  \\underline{k} \\to  (x = \\underline{0} \\; \\vee \\ldots \\vee \\; x = \\underline{k})\n\\]\nAgain, use (meta-) induction on \\(k\\). The case \\(k=0\\) follows from (A15). For the inductive step, show\n\\[\n\\mathsf{PA}^- \\vdash \\forall x,y \\: (y &gt; x \\to y \\geq x+1)\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nLet \\(R\\) be the ring \\(\\mathbb{Z}[X,Y]/(X^2-2Y^2)\\), i.e., \\(R\\) is the polynomial ring \\(\\mathbb{Z}[X,Y]\\) modulo the equivalence \\[\np(X,Y) \\sim q(X,Y) \\quad :\\iff \\quad p-q = r (X^2-2Y^2).\n\\] Show that \\(R\\) can be discretely ordered.\nInfer that \\[\n\\mathsf{PA}^- \\nvdash \\forall x,y \\: (x&gt; 1 \\to x^2 \\neq 2y^2)\n\\]\n\n\n\n\n(Is this fact provable in \\(\\mathsf{PA}\\)?)\n\n\n\n\n\n\n\n\n\n\nExercise 6 \nShow that the following relations and functions are primitive recursive.\n\\[\n\\begin{aligned}\n& x  \\text{ divides }  y \\\\\n& \\operatorname{rem}(x,y) \\text{ (remainder when $y$ is divided by $x$)} \\\\\n& x  \\text{ is prime}\\\\\n& n \\mapsto p_n, \\text{ where $p_n$ is the $n$th prime}\\\\\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\nIf you feel like it, try your hands at proving Gödel’s famous Lemma on the \\(\\beta\\) function:\n\n\n\n\n\n\n\nLemma 1 (Gödel’s Lemma) \nThere exists a primitive recursive function \\(\\beta\\) such that for every \\(k\\) and for every finite sequence \\(x_0,x_1,\\ldots x_{k-1} \\in \\mathbb{N}\\), there exists a natural number \\(c\\) with \\[\n\\text{for all} \\;  i&lt;k: \\;  \\beta(c,i) = x_i.\n\\]\nIn fact, there exists a \\(\\Delta_0\\)-formula \\(\\theta(x,y,z)\\) such that \\[\n\\mathbb{N} \\models \\forall x,y \\;\\exists ! z \\, \\theta(x,y,z),\n\\] and the formula \\(\\theta(x,y,z)\\) defines the function \\(\\beta\\) over the natural numbers.\n\n\n\n\nHint: To code a sequence \\(x_0,x_1,\\ldots x_{k-1}\\) of natural numbers, set \\(m=b!\\) where \\(b = \\max(k,x_0,x_1,\\ldots x_{k-1})\\). Verify the numbers \\[\nm+1, 2m+1, \\ldots k \\cdot m+1\n\\] are pairwise coprime. Now try to apply the Chinese Remainder Theorem.",
    "crumbs": [
      "11/7 - Practice on PA"
    ]
  },
  {
    "objectID": "027_Nov7_PA-proofs.html#the-power-of-induction",
    "href": "027_Nov7_PA-proofs.html#the-power-of-induction",
    "title": "Math 557 Nov 7",
    "section": "",
    "text": "Recall the axioms of \\(\\mathsf{PA}\\):\n\nP1 \\(\\quad\\) \\(Sx \\ne 0\\)\nP2 \\(\\quad\\) \\(Sx=Sy \\to x=y\\)\nP3 \\(\\quad\\) \\(x+0 = x\\)\nP4 \\(\\quad\\) \\(x+Sy =S(x+y)\\)\nP5 \\(\\quad\\) \\(x \\cdot 0 = 0\\)\nP6 \\(\\quad\\) \\(x \\cdot Sy = x \\cdot y + x\\)\nInd\\({}_\\varphi\\) \\(\\;\\) \\(\\varphi(0) \\, \\wedge \\, \\forall x (\\varphi(x) \\to \\varphi(Sx)) \\to \\forall x \\; \\varphi(x)\\)\n\n\n\n\n\n\n\n\nExercise 1 \nShow that \\(\\mathsf{PA} \\vdash \\forall x (Sx \\neq x)\\)\n\n\n\n\nBut we need induction to prove this, even if we throw in another axiom:\n\nP7 \\(\\quad\\) \\(\\forall x \\: (x \\neq 0 \\to \\exists y (x = Sy))\\)\n\nThe system (P1)-(P7) is referred to as Robinson’s \\(\\mathsf{Q}\\)\n\n\n\n\n\n\n\nExercise 2 \nShow that \\(Q \\nvdash \\forall x (Sx \\neq x)\\)\n(Construct a model of \\(\\mathsf{Q}\\) by adding a “point at infinity” to \\(\\mathbb{N}\\) and defining the operations \\(S, +\\) accordingly.)\nIf we use induction in the metatheory (i.e. the theory we are using to reason about \\(\\mathsf{Q}\\), \\(\\mathsf{PA}\\), etc.), we can still show\n\\[\\text{for all } n \\in \\mathbb{N}, \\quad \\mathsf{Q} \\vdash S\\underline{n} \\neq \\underline{n}\\]",
    "crumbs": [
      "11/7 - Practice on PA"
    ]
  },
  {
    "objectID": "027_Nov7_PA-proofs.html#capturing-basic-arithmetic-of-mathbbn-in-mathsfpa-",
    "href": "027_Nov7_PA-proofs.html#capturing-basic-arithmetic-of-mathbbn-in-mathsfpa-",
    "title": "Math 557 Nov 7",
    "section": "",
    "text": "We saw in class that \\(\\mathsf{PA}^-\\) proves all true \\(\\Sigma_1\\)-statements about \\(\\mathbb{N}\\). This is due to two facts:\n\n\\(\\Delta_0\\)-formulas are absolute between structures and end-extensions thereof.\nAny model \\(\\mathcal{M}\\) of \\(\\mathsf{PA}^-\\) is an end-extension of (an isomorphic copy of) \\(\\mathbb{N}\\).\n\nTo prove the second fact, we need to show two things:\n\nThe mapping \\(\\iota: n \\mapsto \\underline{n}^{\\mathcal{M}}\\) is an embedding (so \\(\\iota(\\mathbb{N})\\) is a substructure of \\(\\mathcal{M}\\) isomorphic to \\(\\mathbb{N}\\)).\nAny element \\(y \\in M\\) with \\(y &lt;^{\\mathcal{M}} \\underline{n}^{\\mathcal{M}}\\) is itself some \\(\\underline{m}^{\\mathcal{M}}\\).\n\nThe first item is established in the next exercise.\n\n\n\n\n\n\n\nExercise 3 \nShow that for all natural numbers \\(n,k,l\\),\n\\[\n\\begin{aligned}\nn = k+l & \\quad \\Longrightarrow \\quad \\mathsf{PA}^- \\vdash \\underline{n}= \\underline{k}+ \\underline{l} \\\\\nn = k \\cdot l & \\quad \\Longrightarrow \\quad \\mathsf{PA}^- \\vdash \\underline{n}= \\underline{k} \\cdot \\underline{l} \\\\\nn &lt; k& \\quad \\Longrightarrow \\quad  \\mathsf{PA}^- \\vdash \\underline{n} &lt; \\underline{k}\\\\\n\\end{aligned}\n\\]\n(You prove this by induction in the metatheory. For example, for the first statement, the case \\(k=0\\) follows from axiom (A6). For the inductive step, use axiom (A1).)\n\n\n\n\nFor the second item:\n\n\n\n\n\n\n\nExercise 4 \nShow that for all \\(k \\in \\mathbb{N}\\),\n\\[\n\\mathsf{PA}^- \\vdash \\forall x \\:(x \\le  \\underline{k} \\to  (x = \\underline{0} \\; \\vee \\ldots \\vee \\; x = \\underline{k})\n\\]\nAgain, use (meta-) induction on \\(k\\). The case \\(k=0\\) follows from (A15). For the inductive step, show\n\\[\n\\mathsf{PA}^- \\vdash \\forall x,y \\: (y &gt; x \\to y \\geq x+1)\n\\]",
    "crumbs": [
      "11/7 - Practice on PA"
    ]
  },
  {
    "objectID": "027_Nov7_PA-proofs.html#more-on-the-limitations-of-mathsfpa-",
    "href": "027_Nov7_PA-proofs.html#more-on-the-limitations-of-mathsfpa-",
    "title": "Math 557 Nov 7",
    "section": "",
    "text": "Exercise 5 \nLet \\(R\\) be the ring \\(\\mathbb{Z}[X,Y]/(X^2-2Y^2)\\), i.e., \\(R\\) is the polynomial ring \\(\\mathbb{Z}[X,Y]\\) modulo the equivalence \\[\np(X,Y) \\sim q(X,Y) \\quad :\\iff \\quad p-q = r (X^2-2Y^2).\n\\] Show that \\(R\\) can be discretely ordered.\nInfer that \\[\n\\mathsf{PA}^- \\nvdash \\forall x,y \\: (x&gt; 1 \\to x^2 \\neq 2y^2)\n\\]\n\n\n\n\n(Is this fact provable in \\(\\mathsf{PA}\\)?)",
    "crumbs": [
      "11/7 - Practice on PA"
    ]
  },
  {
    "objectID": "027_Nov7_PA-proofs.html#number-theoretic-functions",
    "href": "027_Nov7_PA-proofs.html#number-theoretic-functions",
    "title": "Math 557 Nov 7",
    "section": "",
    "text": "Exercise 6 \nShow that the following relations and functions are primitive recursive.\n\\[\n\\begin{aligned}\n& x  \\text{ divides }  y \\\\\n& \\operatorname{rem}(x,y) \\text{ (remainder when $y$ is divided by $x$)} \\\\\n& x  \\text{ is prime}\\\\\n& n \\mapsto p_n, \\text{ where $p_n$ is the $n$th prime}\\\\\n\\end{aligned}\n\\]",
    "crumbs": [
      "11/7 - Practice on PA"
    ]
  },
  {
    "objectID": "027_Nov7_PA-proofs.html#gödels-lemma",
    "href": "027_Nov7_PA-proofs.html#gödels-lemma",
    "title": "Math 557 Nov 7",
    "section": "",
    "text": "If you feel like it, try your hands at proving Gödel’s famous Lemma on the \\(\\beta\\) function:\n\n\n\n\n\n\n\nLemma 1 (Gödel’s Lemma) \nThere exists a primitive recursive function \\(\\beta\\) such that for every \\(k\\) and for every finite sequence \\(x_0,x_1,\\ldots x_{k-1} \\in \\mathbb{N}\\), there exists a natural number \\(c\\) with \\[\n\\text{for all} \\;  i&lt;k: \\;  \\beta(c,i) = x_i.\n\\]\nIn fact, there exists a \\(\\Delta_0\\)-formula \\(\\theta(x,y,z)\\) such that \\[\n\\mathbb{N} \\models \\forall x,y \\;\\exists ! z \\, \\theta(x,y,z),\n\\] and the formula \\(\\theta(x,y,z)\\) defines the function \\(\\beta\\) over the natural numbers.\n\n\n\n\nHint: To code a sequence \\(x_0,x_1,\\ldots x_{k-1}\\) of natural numbers, set \\(m=b!\\) where \\(b = \\max(k,x_0,x_1,\\ldots x_{k-1})\\). Verify the numbers \\[\nm+1, 2m+1, \\ldots k \\cdot m+1\n\\] are pairwise coprime. Now try to apply the Chinese Remainder Theorem.",
    "crumbs": [
      "11/7 - Practice on PA"
    ]
  },
  {
    "objectID": "midterm_3_preparation.html",
    "href": "midterm_3_preparation.html",
    "title": "MATH 557 Midterm 3 Preparation",
    "section": "",
    "text": "The third midterm will again have two parts:",
    "crumbs": [
      "Midterm 3 Prep"
    ]
  },
  {
    "objectID": "midterm_3_preparation.html#notations-axioms",
    "href": "midterm_3_preparation.html#notations-axioms",
    "title": "MATH 557 Midterm 3 Preparation",
    "section": "Notations, Axioms",
    "text": "Notations, Axioms\nIn the following, \\(\\mathcal{L}_A = \\{0,1,+,\\cdot, &lt;\\}\\) denotes the language of \\(\\mathsf{PA}^-\\).\n\nThe axioms of \\(\\mathsf{PA}^-\\) are:\n\nA1: \\(\\quad (x +y)+z= x + (y+z)\\)\nA2: \\(\\quad (x \\cdot y) \\cdot z= x \\cdot (y \\cdot z)\\)\nA3: \\(\\quad x + y= y + x\\)\nA4: \\(\\quad x \\cdot y = y \\cdot x\\)\nA5: \\(\\quad x \\cdot (y+z) = x \\cdot y + x \\cdot z\\)\nA6: \\(\\quad x+0=x \\wedge x \\cdot 0 = 0\\)\nA7: \\(\\quad x \\cdot 1 = x\\)\nA8: \\(\\quad \\neg  \\; x &lt; x\\)\nA9: \\(\\quad x &lt; y \\wedge  y &lt; z \\to x &lt; z\\)\nA10: \\(\\quad x &lt; y \\vee x = y \\vee y &lt; x\\)\nA11: \\(\\quad x &lt; y \\to x+z &lt; y+z\\)\nA12: \\(\\quad 0 &lt; z \\wedge x &lt; y \\to x \\cdot z &lt;  y \\cdot z\\)\nA13: \\(\\quad x &lt; y \\to \\exists z \\; (x+z = y)\\)\nA14: \\(\\quad 0&lt;1 \\wedge \\forall x \\; (0 &lt; x \\to 1 \\le x)\\)\nA15: \\(\\quad \\forall x \\; (0 \\le x)\\)\n\nIf we add the induction scheme\n\nInd: \\(\\quad ( \\varphi(0,\\vec{y}) \\, \\wedge \\, \\forall x (\\varphi(x,\\vec{y}) \\to \\varphi(x+1,\\vec{y})) \\to \\forall x \\; \\varphi(x,\\vec{y})\\)\n\nwe obtain (a theory equivalent to) full \\(\\mathsf{PA}\\).",
    "crumbs": [
      "Midterm 3 Prep"
    ]
  },
  {
    "objectID": "midterm_3_preparation.html#theorems",
    "href": "midterm_3_preparation.html#theorems",
    "title": "MATH 557 Midterm 3 Preparation",
    "section": "Theorems",
    "text": "Theorems\n\nTheorem 1For every \\(\\Delta_0\\)-formula \\(\\theta(\\vec{v})\\), the relation \\[\nR(\\vec{a}) :\\iff \\mathbb{N} \\models \\theta(\\vec{a})\n\\] is primitive recursive.\n\n\n\nTheorem 2Let \\(\\mathcal{N}, \\mathcal{M}\\) be \\(\\mathcal{L}_A\\)-structures with \\(\\mathcal{N} \\subseteq_{end} \\mathcal{M}\\), and let \\(\\vec{a} \\in N\\). Then for every \\(\\Delta_0\\)-formula \\(\\varphi(\\vec{v})\\),\n\\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\iff \\mathcal{M}\\models \\varphi[\\vec{a}],\n\\]\n\n\n\nTheorem 3If \\(f:\\mathbb{N} \\to \\mathbb{N}\\) is recursive, then there exists a \\(\\Sigma_1\\)-formula \\(\\theta(x,y)\\) such that for all \\(m,n \\in \\mathbb{N}\\),\n\\[\nf(n) = m \\quad \\Rightarrow \\quad \\mathsf{PA}^- \\vdash \\theta(\\underline{n}, \\underline{m})\n\\]\n(This is one part of the Representability Theorem.)\n\n\n\nTheorem 4Let \\(T\\) be a recursive set of (Gödel numbers of) \\(\\mathcal{L}_A\\)-sentences such that:\n\n\\(T\\) is consistent, i.e., there is no \\(L\\)-sentence \\(\\sigma\\) with \\(\\ulcorner \\sigma \\urcorner \\in T\\) and at the same time \\(\\ulcorner \\neg \\sigma \\urcorner \\in T\\),\n\\(T\\) contains the deductive closure of \\(\\mathsf{PA}^-\\), \\(\\ulcorner (\\mathsf{PA}^-)^\\vdash \\urcorner \\subseteq T\\).\n\nThen \\(T\\) is incomplete, i.e., there exists a sentence \\(\\tau\\) with\n\\[\n\\ulcorner  \\tau \\urcorner  \\not \\in T \\text{ and } \\ulcorner \\neg \\tau \\urcorner  \\not \\in T.\n\\]\n(You can use the Representability Theorem as well as the Diagonal Lemma.)\n\n\n\nTheorem 5If \\(T\\) is a consistent theory in the language \\(\\mathcal{L}_A\\), then not both the diagonal function \\(d\\) and the set \\(\\ulcorner T^\\vdash \\urcorner\\) are representable in \\(T\\).",
    "crumbs": [
      "Midterm 3 Prep"
    ]
  },
  {
    "objectID": "midterm_3_preparation.html#problems",
    "href": "midterm_3_preparation.html#problems",
    "title": "MATH 557 Midterm 3 Preparation",
    "section": "Problems",
    "text": "Problems\n\nProblem 1Show that the functions \\[\n\\operatorname{rem}(x,y) = \\text{remainder when $y$ is divided by $x$}\n\\] (put \\(\\operatorname{rem}(0,y) = y\\) to make it total) and \\[\n\\operatorname{qt}(x,y) = \\text{quotient when $y$ is divided by $x$}\n\\] (put \\(\\operatorname{qt}(0,y) = 0\\)) are primitive recursive.\nIn other words, show that the uniquely determined functions (for \\(x \\geq 1\\)) satisfying \\[\ny = \\operatorname{qt}(x,y) \\cdot x + \\operatorname{rem}(x,y) \\qquad 0 \\leq \\operatorname{rem}(x,y) &lt; x\n\\] are primitive recursive.\nYou can use that the functions \\(x+y\\), \\(x\\cdot y\\), \\(\\max(x,y)\\), \\(\\min(x,y)\\), \\(|x-y|\\), \\(x \\dot{-} y\\), \\(\\operatorname{sg}(x)\\), \\(\\overline{\\operatorname{sg}}(x)\\) are primitive recursive.\n\n\n\n\n\nProblem 2Show that for all \\(k \\in \\mathbb{N}\\),\n\\[\n\\mathsf{PA}^- \\vdash \\forall x \\:(x \\le  \\underline{k} \\to  (x = \\underline{0} \\; \\vee \\ldots \\vee \\; x = \\underline{k})\n\\]\n(Hint: use (meta-)induction on \\(k\\). For the inductive step, show first that\n\\[\n\\mathsf{PA}^- \\vdash \\forall x,y \\: (y &gt; x \\to y \\geq x+1)\n\\]\n\n\n\nProblem 3Let \\(\\mathcal{M} \\models \\mathsf{PA}\\) be non-standard. A proper cut in \\(\\mathcal{M}\\) is a set \\(I \\subsetneq M\\) that is an initial segment of \\(M\\) and closed under successor, e.g. the standard model \\(\\mathbb{N}\\).\n\nShow that if \\(\\vec{a} \\in M\\) and \\(\\mathcal{M} \\models \\varphi(b,\\vec{a})\\) for all \\(b \\in I\\), then there is \\(c &gt; I\\) in \\(M\\) such that \\(\\mathcal{M} \\models \\forall x \\leq c \\: \\varphi(x,\\vec{a})\\).\nSuppose \\(\\mathcal{M} \\models \\mathsf{PA}^{-}\\) is non-standard and has the property that for any proper cut \\(I\\), if \\(\\varphi(x,y)\\) is a formula and \\(\\vec{a} \\in M\\) such that \\[\n\\mathcal{M} \\models \\varphi(b, \\vec{a}) \\quad \\text{for all } b \\in I,\n\\] then there is \\(c &gt; I\\) in \\(M\\) such that \\(\\mathcal{M} \\models \\forall x \\leq c \\: \\varphi(x,\\vec{a})\\) (in other words, \\(\\mathcal{M}\\) satisfies the conclusion of 1.). Show that then \\(\\mathcal{M} \\models \\mathsf{PA}\\).\n\n(Note: For (2.), it suffices to show \\(\\mathcal{M}\\) satisfies the induction scheme.)\n\n\n\nProblem 4Show that, for all functions \\(f : \\mathbb{N}^k \\to \\mathbb{N}\\) (where \\(k\\geq 1\\)), if \\(f\\) is representable in \\(\\mathsf{PA}^-\\) then \\(f\\) is computable.\n(You can argue by Church-Turing Thesis.)\n\n\n\nProblem 5(a) We say an \\(\\mathcal{L}_A\\)-theory \\(T'\\) is a finite extension of an \\(\\mathcal{L}_A\\)-theory \\(T\\) if \\(T' \\supseteq T\\) and \\(T' \\setminus T\\) is finite. Show that if \\(T\\) is decidable and \\(T'\\) is a finite extension of \\(T\\), then \\(T'\\) is decidable.\n(b) An \\(\\mathcal{L}_A\\)-structure \\(\\mathcal{A}\\) is strongly undecidable if every \\(\\mathcal{L}_A\\)-theory \\(T\\) with \\(\\mathcal{A} \\models T\\) is undecidable. Show that the standard model \\(\\mathbb{N}\\) is strongly undecidable.",
    "crumbs": [
      "Midterm 3 Prep"
    ]
  },
  {
    "objectID": "003_Sep03_validities.html",
    "href": "003_Sep03_validities.html",
    "title": "Math 557 Sep 3",
    "section": "",
    "text": "Validity: An \\(\\mathcal{L}\\)-formula \\(\\psi\\) that is valid in any \\(\\mathcal{L}\\)-structure under any assignment \\(\\alpha\\), i.e.\n\n\\[\\mathcal{M} \\models \\psi[\\alpha] \\quad \\text{ for any } \\mathcal{M}, \\alpha.\\]\n\nSources of validities:\n\nPropositional tautologies – e.g. formulas of the form \\(\\psi \\to \\psi\\) or \\(\\psi \\vee \\neg \\psi\\)\nEquality - the way \\(=\\) is interpreted implies formulas like \\(\\forall x \\; x=x\\) are validities.\n\nQuantifiers\n\nFundamental questions:\n\nCan we characterize the set of validities syntactically?\nIn particular, is there an algorithm that, on input \\(\\varphi\\), determines whether \\(\\varphi\\) is a validity or not?\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 (Warmup) \nDetermine whether the following formulas are validitites.\n\n\\(((\\varphi_1 \\, \\to \\, (\\varphi_2 \\, \\to \\, \\varphi_3)) \\, \\to \\, ((\\varphi_1 \\, \\to \\, \\varphi_2) \\, \\to \\, (\\varphi_1 \\, \\to \\, \\varphi_3)))\\)\n\\(\\exists x (\\varphi \\wedge \\psi) \\: \\leftrightarrow \\: (\\exists x \\varphi \\wedge \\exists x \\psi)\\)\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nLet \\(g ∶ \\{0, 1\\}^n → \\{0, 1\\}\\) be a Boolean function. Show that there exists a propositional formula \\(F(p_1, \\dots, p_n)\\) such that, for any assignment \\(\\delta\\) to the variables \\(p_1, \\dots, p_n\\),\n\\[\\delta^*(F) = g(\\delta(p_1), \\dots, \\delta(p_n)).\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nFormally verify that every propositional tautology is a validity.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nVerify, using the definition of the satisfaction relation \\(\\models\\), that\n\\[\\forall x,y (x = y \\: \\to \\: f(x)=f(y)) \\quad (\\text{$f$ unary function symbol})\\]\nand \\[\\forall x ( \\varphi \\to \\psi) \\; \\to \\; (\\varphi \\to \\forall x \\psi) \\quad (\\text{$x$ not free in $\\varphi$})\\]\nare validities.",
    "crumbs": [
      "9/3 - Validities"
    ]
  },
  {
    "objectID": "003_Sep03_validities.html#key-concepts",
    "href": "003_Sep03_validities.html#key-concepts",
    "title": "Math 557 Sep 3",
    "section": "",
    "text": "Validity: An \\(\\mathcal{L}\\)-formula \\(\\psi\\) that is valid in any \\(\\mathcal{L}\\)-structure under any assignment \\(\\alpha\\), i.e.\n\n\\[\\mathcal{M} \\models \\psi[\\alpha] \\quad \\text{ for any } \\mathcal{M}, \\alpha.\\]\n\nSources of validities:\n\nPropositional tautologies – e.g. formulas of the form \\(\\psi \\to \\psi\\) or \\(\\psi \\vee \\neg \\psi\\)\nEquality - the way \\(=\\) is interpreted implies formulas like \\(\\forall x \\; x=x\\) are validities.\n\nQuantifiers\n\nFundamental questions:\n\nCan we characterize the set of validities syntactically?\nIn particular, is there an algorithm that, on input \\(\\varphi\\), determines whether \\(\\varphi\\) is a validity or not?",
    "crumbs": [
      "9/3 - Validities"
    ]
  },
  {
    "objectID": "003_Sep03_validities.html#problems",
    "href": "003_Sep03_validities.html#problems",
    "title": "Math 557 Sep 3",
    "section": "",
    "text": "Exercise 1 (Warmup) \nDetermine whether the following formulas are validitites.\n\n\\(((\\varphi_1 \\, \\to \\, (\\varphi_2 \\, \\to \\, \\varphi_3)) \\, \\to \\, ((\\varphi_1 \\, \\to \\, \\varphi_2) \\, \\to \\, (\\varphi_1 \\, \\to \\, \\varphi_3)))\\)\n\\(\\exists x (\\varphi \\wedge \\psi) \\: \\leftrightarrow \\: (\\exists x \\varphi \\wedge \\exists x \\psi)\\)\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nLet \\(g ∶ \\{0, 1\\}^n → \\{0, 1\\}\\) be a Boolean function. Show that there exists a propositional formula \\(F(p_1, \\dots, p_n)\\) such that, for any assignment \\(\\delta\\) to the variables \\(p_1, \\dots, p_n\\),\n\\[\\delta^*(F) = g(\\delta(p_1), \\dots, \\delta(p_n)).\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nFormally verify that every propositional tautology is a validity.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nVerify, using the definition of the satisfaction relation \\(\\models\\), that\n\\[\\forall x,y (x = y \\: \\to \\: f(x)=f(y)) \\quad (\\text{$f$ unary function symbol})\\]\nand \\[\\forall x ( \\varphi \\to \\psi) \\; \\to \\; (\\varphi \\to \\forall x \\psi) \\quad (\\text{$x$ not free in $\\varphi$})\\]\nare validities.",
    "crumbs": [
      "9/3 - Validities"
    ]
  },
  {
    "objectID": "026_Nov5_definability.html",
    "href": "026_Nov5_definability.html",
    "title": "Math 557 Nov 5",
    "section": "",
    "text": "We now extend the connection between arithmetical formulas and computable functions significantly. Our goal is to show that the recursive relations on \\(\\mathbb{N}\\) are precisely those that are \\(\\Delta_1\\)-definable. At the core of this connection is the Definability Theorem. For a partial function \\(f\\), let \\(\\Gamma_f\\) denote the graph of \\(f\\), i.e., the relation \\[\n\\Gamma_f(\\vec{x},y): \\iff f(\\vec{x})=y.\n\\]\n\n\n\n\n\n\n\n\n\nTheorem 1 \nA partial function \\(f: \\subseteq \\mathbb{N} \\to \\mathbb{N}\\) is computable if and only if its graph \\(\\Gamma_f\\) over the natural numbers is definable by a \\(\\Sigma_1\\)-formula, i.e., if there exists a \\(\\Sigma_1\\)-formula \\(\\theta\\) such that for all \\(x, y \\in \\mathbb{N}\\):\n\\[\n\\Gamma_f(x, y) \\iff \\mathbb{N} \\models \\theta[x, y].\n\\]\n\n\n\n\nThe direction (\\(\\Leftarrow\\)) is relatively straightforward: Let \\(\\theta = \\exists z \\, \\psi\\) be a \\(\\Sigma_1\\)-formula that defines the graph \\(\\Gamma_f\\) of a partial function \\(f\\), where \\(\\psi(x, y, z)\\) is a \\(\\Delta_0\\)-formula. As \\(\\Delta_0\\)-formulas define primitive recursive relations, we obtain a computable function \\(g\\) by letting\n\\[\ng(x) = \\mu z \\, \\psi( x, (z)_0, (z)_1).\n\\]\nThen \\((g(x))_0\\) is the smallest \\(y\\) with \\(\\mathbb{N} \\models \\theta[x, y]\\), if such a \\(y\\) exists, and undefined otherwise, since for each \\(x \\in \\mathbb{N}\\) there is at most one \\(y\\) with \\(\\mathbb{N} \\models \\theta[x, y]\\). Thus \\((g(x))_0 \\cong f(x)\\), and therefore \\(f\\) is partial computable.\nFor the proof of (\\(\\Rightarrow\\)), we call partial functions \\(f\\) whose graph can be defined by a \\(\\Sigma_1\\)-formula over the natural numbers functions with a \\(\\Sigma_1\\)-graph. The obvious strategy is to show that the set of these functions contains the initial functions and is closed under composition, primitive recursion, and the \\(\\mu\\)-operator.\nMost cases are straightforward (just by writing out the definitions), but when we get to closure under primitive recursion, we run into difficulties: Suppose the function \\(f\\) arises from functions \\(g, h\\) by primitive recursion:\n\\[\n\\begin{aligned}\nf(x, 0) &\\cong g(x) \\\\\nf(x, y+1) &\\cong h(x, y, f(x, y))\n\\end{aligned}\n\\]\nWe may assume that the graphs of \\(g\\) and \\(h\\) are definable by \\(\\Sigma_1\\)-formulas. To describe the graph of \\(f\\) with this, we note that the value of \\(f(x, y)\\) is computed through the preceding values\n\\[\nu_0 = f(x, 0), \\, u_1 = f(x, 1), \\, \\ldots, \\, u_y = f(x, y),\n\\]\nWe somehow have to eliminate the function \\(f\\) from this sequence to obtain an explicit definition (in the language of arithmetic).\nThe idea is to express the following through a formula:\n\nThere exists a code \\(u\\) such that \\(u\\) codes a sequence of numbers \\((u_0, \\dots, u_y)\\) in which the \\(u_{i+1}\\) is obtained from \\(u_i\\) using a valid application of the primitive recursion scheme with respect to \\(g\\) and \\(h\\).\n\nThe problem is that we do not know a priori how long the sequence coded by \\(u\\) is. We therefore cannot use the preferred coding scheme\n\\[\n\\langle u_0, \\dots, u_y \\rangle\n\\]\nwhich is \\(\\Delta_0\\)-definable. The coding scheme \\[\n(n_0, n_1, \\ldots, n_k) \\quad \\text{by} \\quad p_0^{n_0+1} \\cdot p_1^{n_1+1}\\cdot  \\ldots \\cdot p_k^{n_k+1}.\n\\] on the other hand is uniform independent of the length of the sequence, but it uses exponentiation, which is not present in \\(\\mathsf{PA}^-\\) (and would have to be defined via recursion).\nThis is where Gödel, according to Mostowski, “had a phone call with God”.\n\n\n\n\n\n\n\n\n\nLemma 1 \nThere exists a primitive recursive function \\(\\beta\\) such that for every \\(k\\) and for every finite sequence \\(x_0,x_1,\\ldots x_{k-1} \\in \\mathbb{N}\\), there exists a natural number \\(c\\) with \\[\n\\text{for all} \\;  i&lt;k: \\;  \\beta(c,i) = x_i.\n\\]\nIn fact, there exists a \\(\\Delta_0\\)-formula \\(\\theta(x,y,z)\\) such that \\[\n\\mathbb{N} \\models \\forall x,y \\;\\exists ! z \\, \\theta(x,y,z),\n\\] and the formula \\(\\theta(x,y,z)\\) defines the function \\(\\beta\\) over the natural numbers.\n\n\n\n\n\nProof. Let \\(x_0,x_1,\\ldots x_{k-1}\\) be a sequence of natural numbers.\nSet \\(m:=b!\\) where \\(b: = \\max(k,x_0,x_1,\\ldots x_{k-1})\\). Then the sequence of numbers \\[\nm+1, 2m+1, \\ldots k \\cdot m+1\n\\] are pairwise coprime. By the theorem on simultaneous congruences (Chinese Remainder Theorem), there exists a natural number \\(a\\) with \\[\na \\equiv x_i  \\pmod{(i+1)m+1} \\quad \\text{for all } i &lt; k.\n\\] Now we can choose \\(\\langle a,m \\rangle\\) as a code for the sequence \\(x_0,x_1,\\ldots x_{k-1}\\), because from this we can recover each \\(x_i\\) for every \\(i&lt;k\\) as the remainder of the division of \\(a\\) by the number \\((i+1)m+1\\). If \\(rem(x:y)= z\\) denotes the remainder of the division of \\(x\\) by \\(y\\) (when \\(y \\ne 0\\) and \\(rem(x:0)=0\\)), then this is a p.r. function with a \\(\\Delta_0\\)-definition. We obtain another p.r. function by \\[\n\\alpha(a,m,i) =rem(a: (1+i)m+1).\n\\] Let \\(p_1,p_2\\) denote the inverse functions of the pairing function \\(\\langle x,y \\rangle\\) above, for which \\[\n\\langle p_1(x),p_2(x) \\rangle = x , \\quad  \\text{where} \\; p_1(x),p_2(x) \\le x,\n\\] these are also p.r., and we finally obtain the Gödel beta function as \\[\n\\beta(c,i) = \\alpha(p_1(c),p_2(c),i).\n\\]\n\n\n\n\nReturning to the sequence\n\\[\nu_0 = f(x, 0), \\, u_1 = f(x, 1), \\, \\ldots, \\, u_y = f(x, y),\n\\]\nwe can now use the \\(\\beta\\)-function to encode this by a single number \\(u\\). The first value \\(u_0\\) is determined by the graph of \\(g\\), and the further values \\(u_{i+1}\\) are determined from \\(u_i\\) according to the recursion conditions via the graph of \\(h\\):\n\\[\n\\forall i &lt; y \\, \\exists r, s \\, [\\beta(u, i) = r \\wedge \\beta(u, i+1) = s \\wedge \\Gamma_h(\\vec{x}, i, r, s)]\n\\]\nThis formula can be transformed (by choosing a sufficiently large \\(w\\)) into\n\\[\n\\exists w \\, \\forall i &lt; y \\, \\exists r, s &lt; w \\, [\\beta(u, i) = r \\wedge \\beta(u, i+1) = s \\wedge \\Gamma_h(\\vec{x}, i, r, s)].\n\\]\nThe last value of the sequence encoded by \\(u\\) is the function value of \\(f\\) at the point \\((x, y)\\). Thus we obtain the following description of the graph of \\(f\\):\n\\[\n\\begin{aligned}\n\\Gamma_f(\\vec{x}, y, z) \\iff \\; & \\exists u, v, w \\, (\\Gamma_g(\\vec{x}, v) \\wedge \\beta(u, 0) = v \\wedge \\beta(u, y) = z \\; \\wedge \\\\\n& \\forall i &lt; y \\, \\exists r, s &lt; w \\, [\\beta(u, i) = r \\wedge \\beta(u, i+1) = s \\wedge \\Gamma_h(\\vec{x}, i, r, s)]),\n\\end{aligned}\n\\]\nIt is not hard to transform this into an equivalent \\(\\Sigma_1\\)-formula.\n\n\n\nIf we call a set \\(A \\subseteq \\mathbb{N}^k\\) that is definable by a formula in \\(\\Gamma\\) over the natural numbers a \\(\\Gamma\\)-set, we obtain a new characterization of the first levels of the arithmetic hierarchy:\n\n\n\n\n\n\n\nCorollary 1 \n1. The \\(\\Sigma_1\\)-sets are precisely the r.e. (recursively enumerable) relations \\(R \\subseteq \\mathbb{N}^k\\).\n\nThe \\(\\Pi_1\\)-sets are the complements of r.e. relations.\nThe \\(\\Delta_1\\)-sets are precisely the recursive relations \\(R \\subseteq \\mathbb{N}^k\\).\n\n\n\n\n\nWe leave the short proof of (1) as an exercise. (2) follows from (1) by using negation, and for (3) use the fact that a set is computable if and only if the st and its complement are r.e.",
    "crumbs": [
      "11/5 - Definability of computable functions"
    ]
  },
  {
    "objectID": "026_Nov5_definability.html#the-definability-theorem",
    "href": "026_Nov5_definability.html#the-definability-theorem",
    "title": "Math 557 Nov 5",
    "section": "",
    "text": "Theorem 1 \nA partial function \\(f: \\subseteq \\mathbb{N} \\to \\mathbb{N}\\) is computable if and only if its graph \\(\\Gamma_f\\) over the natural numbers is definable by a \\(\\Sigma_1\\)-formula, i.e., if there exists a \\(\\Sigma_1\\)-formula \\(\\theta\\) such that for all \\(x, y \\in \\mathbb{N}\\):\n\\[\n\\Gamma_f(x, y) \\iff \\mathbb{N} \\models \\theta[x, y].\n\\]\n\n\n\n\nThe direction (\\(\\Leftarrow\\)) is relatively straightforward: Let \\(\\theta = \\exists z \\, \\psi\\) be a \\(\\Sigma_1\\)-formula that defines the graph \\(\\Gamma_f\\) of a partial function \\(f\\), where \\(\\psi(x, y, z)\\) is a \\(\\Delta_0\\)-formula. As \\(\\Delta_0\\)-formulas define primitive recursive relations, we obtain a computable function \\(g\\) by letting\n\\[\ng(x) = \\mu z \\, \\psi( x, (z)_0, (z)_1).\n\\]\nThen \\((g(x))_0\\) is the smallest \\(y\\) with \\(\\mathbb{N} \\models \\theta[x, y]\\), if such a \\(y\\) exists, and undefined otherwise, since for each \\(x \\in \\mathbb{N}\\) there is at most one \\(y\\) with \\(\\mathbb{N} \\models \\theta[x, y]\\). Thus \\((g(x))_0 \\cong f(x)\\), and therefore \\(f\\) is partial computable.\nFor the proof of (\\(\\Rightarrow\\)), we call partial functions \\(f\\) whose graph can be defined by a \\(\\Sigma_1\\)-formula over the natural numbers functions with a \\(\\Sigma_1\\)-graph. The obvious strategy is to show that the set of these functions contains the initial functions and is closed under composition, primitive recursion, and the \\(\\mu\\)-operator.\nMost cases are straightforward (just by writing out the definitions), but when we get to closure under primitive recursion, we run into difficulties: Suppose the function \\(f\\) arises from functions \\(g, h\\) by primitive recursion:\n\\[\n\\begin{aligned}\nf(x, 0) &\\cong g(x) \\\\\nf(x, y+1) &\\cong h(x, y, f(x, y))\n\\end{aligned}\n\\]\nWe may assume that the graphs of \\(g\\) and \\(h\\) are definable by \\(\\Sigma_1\\)-formulas. To describe the graph of \\(f\\) with this, we note that the value of \\(f(x, y)\\) is computed through the preceding values\n\\[\nu_0 = f(x, 0), \\, u_1 = f(x, 1), \\, \\ldots, \\, u_y = f(x, y),\n\\]\nWe somehow have to eliminate the function \\(f\\) from this sequence to obtain an explicit definition (in the language of arithmetic).\nThe idea is to express the following through a formula:\n\nThere exists a code \\(u\\) such that \\(u\\) codes a sequence of numbers \\((u_0, \\dots, u_y)\\) in which the \\(u_{i+1}\\) is obtained from \\(u_i\\) using a valid application of the primitive recursion scheme with respect to \\(g\\) and \\(h\\).\n\nThe problem is that we do not know a priori how long the sequence coded by \\(u\\) is. We therefore cannot use the preferred coding scheme\n\\[\n\\langle u_0, \\dots, u_y \\rangle\n\\]\nwhich is \\(\\Delta_0\\)-definable. The coding scheme \\[\n(n_0, n_1, \\ldots, n_k) \\quad \\text{by} \\quad p_0^{n_0+1} \\cdot p_1^{n_1+1}\\cdot  \\ldots \\cdot p_k^{n_k+1}.\n\\] on the other hand is uniform independent of the length of the sequence, but it uses exponentiation, which is not present in \\(\\mathsf{PA}^-\\) (and would have to be defined via recursion).\nThis is where Gödel, according to Mostowski, “had a phone call with God”.\n\n\n\n\n\n\n\n\n\nLemma 1 \nThere exists a primitive recursive function \\(\\beta\\) such that for every \\(k\\) and for every finite sequence \\(x_0,x_1,\\ldots x_{k-1} \\in \\mathbb{N}\\), there exists a natural number \\(c\\) with \\[\n\\text{for all} \\;  i&lt;k: \\;  \\beta(c,i) = x_i.\n\\]\nIn fact, there exists a \\(\\Delta_0\\)-formula \\(\\theta(x,y,z)\\) such that \\[\n\\mathbb{N} \\models \\forall x,y \\;\\exists ! z \\, \\theta(x,y,z),\n\\] and the formula \\(\\theta(x,y,z)\\) defines the function \\(\\beta\\) over the natural numbers.\n\n\n\n\n\nProof. Let \\(x_0,x_1,\\ldots x_{k-1}\\) be a sequence of natural numbers.\nSet \\(m:=b!\\) where \\(b: = \\max(k,x_0,x_1,\\ldots x_{k-1})\\). Then the sequence of numbers \\[\nm+1, 2m+1, \\ldots k \\cdot m+1\n\\] are pairwise coprime. By the theorem on simultaneous congruences (Chinese Remainder Theorem), there exists a natural number \\(a\\) with \\[\na \\equiv x_i  \\pmod{(i+1)m+1} \\quad \\text{for all } i &lt; k.\n\\] Now we can choose \\(\\langle a,m \\rangle\\) as a code for the sequence \\(x_0,x_1,\\ldots x_{k-1}\\), because from this we can recover each \\(x_i\\) for every \\(i&lt;k\\) as the remainder of the division of \\(a\\) by the number \\((i+1)m+1\\). If \\(rem(x:y)= z\\) denotes the remainder of the division of \\(x\\) by \\(y\\) (when \\(y \\ne 0\\) and \\(rem(x:0)=0\\)), then this is a p.r. function with a \\(\\Delta_0\\)-definition. We obtain another p.r. function by \\[\n\\alpha(a,m,i) =rem(a: (1+i)m+1).\n\\] Let \\(p_1,p_2\\) denote the inverse functions of the pairing function \\(\\langle x,y \\rangle\\) above, for which \\[\n\\langle p_1(x),p_2(x) \\rangle = x , \\quad  \\text{where} \\; p_1(x),p_2(x) \\le x,\n\\] these are also p.r., and we finally obtain the Gödel beta function as \\[\n\\beta(c,i) = \\alpha(p_1(c),p_2(c),i).\n\\]\n\n\n\n\nReturning to the sequence\n\\[\nu_0 = f(x, 0), \\, u_1 = f(x, 1), \\, \\ldots, \\, u_y = f(x, y),\n\\]\nwe can now use the \\(\\beta\\)-function to encode this by a single number \\(u\\). The first value \\(u_0\\) is determined by the graph of \\(g\\), and the further values \\(u_{i+1}\\) are determined from \\(u_i\\) according to the recursion conditions via the graph of \\(h\\):\n\\[\n\\forall i &lt; y \\, \\exists r, s \\, [\\beta(u, i) = r \\wedge \\beta(u, i+1) = s \\wedge \\Gamma_h(\\vec{x}, i, r, s)]\n\\]\nThis formula can be transformed (by choosing a sufficiently large \\(w\\)) into\n\\[\n\\exists w \\, \\forall i &lt; y \\, \\exists r, s &lt; w \\, [\\beta(u, i) = r \\wedge \\beta(u, i+1) = s \\wedge \\Gamma_h(\\vec{x}, i, r, s)].\n\\]\nThe last value of the sequence encoded by \\(u\\) is the function value of \\(f\\) at the point \\((x, y)\\). Thus we obtain the following description of the graph of \\(f\\):\n\\[\n\\begin{aligned}\n\\Gamma_f(\\vec{x}, y, z) \\iff \\; & \\exists u, v, w \\, (\\Gamma_g(\\vec{x}, v) \\wedge \\beta(u, 0) = v \\wedge \\beta(u, y) = z \\; \\wedge \\\\\n& \\forall i &lt; y \\, \\exists r, s &lt; w \\, [\\beta(u, i) = r \\wedge \\beta(u, i+1) = s \\wedge \\Gamma_h(\\vec{x}, i, r, s)]),\n\\end{aligned}\n\\]\nIt is not hard to transform this into an equivalent \\(\\Sigma_1\\)-formula.\n\n\n\nIf we call a set \\(A \\subseteq \\mathbb{N}^k\\) that is definable by a formula in \\(\\Gamma\\) over the natural numbers a \\(\\Gamma\\)-set, we obtain a new characterization of the first levels of the arithmetic hierarchy:\n\n\n\n\n\n\n\nCorollary 1 \n1. The \\(\\Sigma_1\\)-sets are precisely the r.e. (recursively enumerable) relations \\(R \\subseteq \\mathbb{N}^k\\).\n\nThe \\(\\Pi_1\\)-sets are the complements of r.e. relations.\nThe \\(\\Delta_1\\)-sets are precisely the recursive relations \\(R \\subseteq \\mathbb{N}^k\\).\n\n\n\n\n\nWe leave the short proof of (1) as an exercise. (2) follows from (1) by using negation, and for (3) use the fact that a set is computable if and only if the st and its complement are r.e.",
    "crumbs": [
      "11/5 - Definability of computable functions"
    ]
  },
  {
    "objectID": "005_Sep10_implication.html",
    "href": "005_Sep10_implication.html",
    "title": "Math 557 Sep 10",
    "section": "",
    "text": "Logical consequence:\n\nThis is the semantical implication we are often working with in mathematical practice. We say \\(T\\) logically implies \\(\\varphi\\), \\(T \\models \\varphi\\), if for structure \\(\\mathcal{M}\\), \\(\\mathcal{M} \\models T\\) implies \\(\\mathcal{M} \\models \\varphi\\).\n\nFormal proof:\n\n\\(T \\vdash \\varphi\\) means there is a formal (i.e. syntactical) derivation of \\(\\varphi\\) from \\(T\\) using the formulas of \\(T\\), the three kinds of logical axioms (propositional tautologies, equality and quantifier axioms), and the inference rules Modus Ponens and Generalization.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 (Warmup - Logical Implication) \nLet \\(T\\) be an \\(\\mathcal{L}\\)-theory. We say a theory \\(T'\\) is an axiomatization of \\(T\\) if for any \\(\\mathcal{L}\\)-structure \\(\\mathcal{M}\\),\n\\[\\mathcal{M} \\models T \\; \\iff \\; \\mathcal{M} \\models T'\\]\nShow that for any axiomatization \\(T'\\) of \\(T\\), for any \\(\\mathcal{L}\\)-sentence \\(\\sigma\\),\n\\[T \\models \\sigma \\; \\iff \\; T' \\models \\sigma\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 (Warmup 2) \nRecall that a model of a theory \\(T\\) is a structure \\(\\mathcal{M}\\) such that for any sentence \\(\\sigma \\in T\\), \\(\\mathcal{M} \\models \\sigma\\). In this case we write \\(\\mathcal{M} \\models T\\).\nArgue that if \\(T\\) does not have a model, every sentence is a logical implication of \\(T\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 (Formal notion of proof – Warmup) \nVerify that\n\\[\\{\\varphi, \\neg \\psi\\} \\vdash \\neg(\\varphi \\to \\psi)\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nArgue (semantically) that if \\(x\\) is not free in \\(\\psi\\),\n\\[\\{\\varphi \\to \\psi\\} \\models \\exists x \\varphi \\: \\to \\: \\psi\\]\nThen prove this syntactically, i.e. show (under the same assumption) that\n\\[\\{\\varphi \\to \\psi\\} \\vdash \\exists x \\varphi \\: \\to \\: \\psi\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nProve the Soundness Theorem, i.e. show that\n\\[T \\vdash \\varphi \\; \\Rightarrow \\; T \\models \\varphi\\]\n\n\n\n\n\n\n\n\n\n\nTake-home problem\n\n\n\n\nShow that\n\\[\\begin{aligned}\n\\{\\varphi \\to \\psi \\} & \\vdash \\exists x \\varphi \\: \\to \\: \\exists x \\psi \\\\\n\\{\\varphi \\to \\psi \\} & \\vdash \\forall x \\varphi \\: \\to \\: \\forall x \\psi \\\\\n\\end{aligned}\\]",
    "crumbs": [
      "9/10 - Logical implication"
    ]
  },
  {
    "objectID": "005_Sep10_implication.html#key-concepts",
    "href": "005_Sep10_implication.html#key-concepts",
    "title": "Math 557 Sep 10",
    "section": "",
    "text": "Logical consequence:\n\nThis is the semantical implication we are often working with in mathematical practice. We say \\(T\\) logically implies \\(\\varphi\\), \\(T \\models \\varphi\\), if for structure \\(\\mathcal{M}\\), \\(\\mathcal{M} \\models T\\) implies \\(\\mathcal{M} \\models \\varphi\\).\n\nFormal proof:\n\n\\(T \\vdash \\varphi\\) means there is a formal (i.e. syntactical) derivation of \\(\\varphi\\) from \\(T\\) using the formulas of \\(T\\), the three kinds of logical axioms (propositional tautologies, equality and quantifier axioms), and the inference rules Modus Ponens and Generalization.",
    "crumbs": [
      "9/10 - Logical implication"
    ]
  },
  {
    "objectID": "005_Sep10_implication.html#problems",
    "href": "005_Sep10_implication.html#problems",
    "title": "Math 557 Sep 10",
    "section": "",
    "text": "Exercise 1 (Warmup - Logical Implication) \nLet \\(T\\) be an \\(\\mathcal{L}\\)-theory. We say a theory \\(T'\\) is an axiomatization of \\(T\\) if for any \\(\\mathcal{L}\\)-structure \\(\\mathcal{M}\\),\n\\[\\mathcal{M} \\models T \\; \\iff \\; \\mathcal{M} \\models T'\\]\nShow that for any axiomatization \\(T'\\) of \\(T\\), for any \\(\\mathcal{L}\\)-sentence \\(\\sigma\\),\n\\[T \\models \\sigma \\; \\iff \\; T' \\models \\sigma\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 (Warmup 2) \nRecall that a model of a theory \\(T\\) is a structure \\(\\mathcal{M}\\) such that for any sentence \\(\\sigma \\in T\\), \\(\\mathcal{M} \\models \\sigma\\). In this case we write \\(\\mathcal{M} \\models T\\).\nArgue that if \\(T\\) does not have a model, every sentence is a logical implication of \\(T\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 (Formal notion of proof – Warmup) \nVerify that\n\\[\\{\\varphi, \\neg \\psi\\} \\vdash \\neg(\\varphi \\to \\psi)\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nArgue (semantically) that if \\(x\\) is not free in \\(\\psi\\),\n\\[\\{\\varphi \\to \\psi\\} \\models \\exists x \\varphi \\: \\to \\: \\psi\\]\nThen prove this syntactically, i.e. show (under the same assumption) that\n\\[\\{\\varphi \\to \\psi\\} \\vdash \\exists x \\varphi \\: \\to \\: \\psi\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nProve the Soundness Theorem, i.e. show that\n\\[T \\vdash \\varphi \\; \\Rightarrow \\; T \\models \\varphi\\]\n\n\n\n\n\n\n\n\n\n\nTake-home problem\n\n\n\n\nShow that\n\\[\\begin{aligned}\n\\{\\varphi \\to \\psi \\} & \\vdash \\exists x \\varphi \\: \\to \\: \\exists x \\psi \\\\\n\\{\\varphi \\to \\psi \\} & \\vdash \\forall x \\varphi \\: \\to \\: \\forall x \\psi \\\\\n\\end{aligned}\\]",
    "crumbs": [
      "9/10 - Logical implication"
    ]
  },
  {
    "objectID": "009_Sep19_Henkin_theories.html",
    "href": "009_Sep19_Henkin_theories.html",
    "title": "Math 557 Sep 19",
    "section": "",
    "text": "An \\(\\mathcal{L}\\)-theory \\(T\\) is a Henkin theory if for every sentence of the form \\(\\exists x \\psi\\) there exists a constant \\(\\mathcal{L}\\)-term \\(t\\) such that \\[\n  T \\vdash_{\\mathcal{L}} \\exists x \\psi \\; \\to \\; \\psi_{t/x}\n\\]\nQuestions:\n\nWhat are Henkin theories needed for?\nDo they exist?\nCan we extend a given consistent theory to a Henkin theory that is still consistent?\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 \nAs before, let \\(\\mathcal{A}_T\\) be the term model of \\(T\\). Pinpoint exactly where we might run into difficulties when we are trying to prove \\[\n\\mathcal{A}_T \\models \\exists x \\psi \\; \\iff \\; T \\vdash_{\\mathcal{L}} \\exists x \\psi\n\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 (Interlude) \nWhat if in \\(\\exists x \\psi\\) the variable \\(x\\) is not free? Does that make a difference regarding being a Henkin theory?\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nCan you find a couple of examples of Henkin theories?\n\n\n\n\nThe basic construction step for extending an \\(\\mathcal{L}\\)-theory \\(T\\) to a Henkin theory is for every sentence of the form \\(\\sigma \\equiv \\exists x \\psi\\),\n\nadd a new constant symbol \\(c_\\sigma\\) to \\(\\mathcal{L}\\)\nadd the formula \\(\\exists x \\psi \\; \\to \\; \\psi_{c_\\sigma/x}\\) to \\(T\\).\n\n\n\n\n\n\n\n\nExercise 4 \nWhy could the addition of a constant theoretically lead to \\(T\\) being inconsistent, even though \\(T\\) itself remains unchanged?\nAnd why does \\(T\\) actually remain consistent?\n\n\n\n\nThe Henkin extension \\(T_H\\) of \\(T\\) is obtained by an iterative process:\nSingle iteration step:\n\n\\(\\mathcal{L}' = \\mathcal{L} \\cup \\{c_\\sigma \\colon \\sigma \\: \\mathcal{L}\\text{-sentence of the form } \\exists x \\psi \\}\\)\n\\(\\Gamma = \\{ \\exists x \\psi(x) \\to \\psi_{c_\\sigma/x} \\colon \\sigma \\: \\mathcal{L}\\text{-sentence of the form } \\exists x \\psi \\}\\)\n\\(T' = T \\cup \\Gamma\\) (an \\(\\mathcal{L}'\\)-theory)\n\n\n\n\n\n\n\n\nExercise 5 \nWhy is \\(T'\\) above not necessarily a Henkin theory?\n\n\n\n\nIteration process:\n\n\\(\\mathcal{L}_0 = \\mathcal{L}, \\; T_0 = T\\)\n\\(\\mathcal{L}_{n+1} = \\mathcal{L}'_n, \\; T_{n+1} = T_n'\\)\n\\(\\textstyle \\mathcal{L}_H = \\bigcup_{n \\in \\mathbb{N}} \\mathcal{L}_n, \\; T_H = \\bigcup_{n \\in \\mathbb{N}} T_n\\)\n\n\n\n\n\n\n\n\nExercise 6 \nWhy is \\(T_H\\) a Henkin theory?\n\n\n\n\n\\(T_H\\) is no longer a purely symbolic extension of \\(T\\) (in the sense that we simply extend the language), since we add new sentences to \\(T\\) (the sentences in \\(\\Gamma\\) for each iteration step).\n\n\n\n\n\n\nTake-home Problem\n\n\n\n\nShow that for every \\(\\mathcal{L}\\)-formula \\(\\varphi\\), \\[\nT_H \\vdash_{\\mathcal{L}_H} \\varphi \\; \\iff \\; T \\vdash_{\\mathcal{L}} \\varphi\n\\]",
    "crumbs": [
      "9/19 - Henkin theories"
    ]
  },
  {
    "objectID": "009_Sep19_Henkin_theories.html#key-concepts",
    "href": "009_Sep19_Henkin_theories.html#key-concepts",
    "title": "Math 557 Sep 19",
    "section": "",
    "text": "An \\(\\mathcal{L}\\)-theory \\(T\\) is a Henkin theory if for every sentence of the form \\(\\exists x \\psi\\) there exists a constant \\(\\mathcal{L}\\)-term \\(t\\) such that \\[\n  T \\vdash_{\\mathcal{L}} \\exists x \\psi \\; \\to \\; \\psi_{t/x}\n\\]\nQuestions:\n\nWhat are Henkin theories needed for?\nDo they exist?\nCan we extend a given consistent theory to a Henkin theory that is still consistent?",
    "crumbs": [
      "9/19 - Henkin theories"
    ]
  },
  {
    "objectID": "009_Sep19_Henkin_theories.html#problems",
    "href": "009_Sep19_Henkin_theories.html#problems",
    "title": "Math 557 Sep 19",
    "section": "",
    "text": "Exercise 1 \nAs before, let \\(\\mathcal{A}_T\\) be the term model of \\(T\\). Pinpoint exactly where we might run into difficulties when we are trying to prove \\[\n\\mathcal{A}_T \\models \\exists x \\psi \\; \\iff \\; T \\vdash_{\\mathcal{L}} \\exists x \\psi\n\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 (Interlude) \nWhat if in \\(\\exists x \\psi\\) the variable \\(x\\) is not free? Does that make a difference regarding being a Henkin theory?\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nCan you find a couple of examples of Henkin theories?\n\n\n\n\nThe basic construction step for extending an \\(\\mathcal{L}\\)-theory \\(T\\) to a Henkin theory is for every sentence of the form \\(\\sigma \\equiv \\exists x \\psi\\),\n\nadd a new constant symbol \\(c_\\sigma\\) to \\(\\mathcal{L}\\)\nadd the formula \\(\\exists x \\psi \\; \\to \\; \\psi_{c_\\sigma/x}\\) to \\(T\\).\n\n\n\n\n\n\n\n\nExercise 4 \nWhy could the addition of a constant theoretically lead to \\(T\\) being inconsistent, even though \\(T\\) itself remains unchanged?\nAnd why does \\(T\\) actually remain consistent?\n\n\n\n\nThe Henkin extension \\(T_H\\) of \\(T\\) is obtained by an iterative process:\nSingle iteration step:\n\n\\(\\mathcal{L}' = \\mathcal{L} \\cup \\{c_\\sigma \\colon \\sigma \\: \\mathcal{L}\\text{-sentence of the form } \\exists x \\psi \\}\\)\n\\(\\Gamma = \\{ \\exists x \\psi(x) \\to \\psi_{c_\\sigma/x} \\colon \\sigma \\: \\mathcal{L}\\text{-sentence of the form } \\exists x \\psi \\}\\)\n\\(T' = T \\cup \\Gamma\\) (an \\(\\mathcal{L}'\\)-theory)\n\n\n\n\n\n\n\n\nExercise 5 \nWhy is \\(T'\\) above not necessarily a Henkin theory?\n\n\n\n\nIteration process:\n\n\\(\\mathcal{L}_0 = \\mathcal{L}, \\; T_0 = T\\)\n\\(\\mathcal{L}_{n+1} = \\mathcal{L}'_n, \\; T_{n+1} = T_n'\\)\n\\(\\textstyle \\mathcal{L}_H = \\bigcup_{n \\in \\mathbb{N}} \\mathcal{L}_n, \\; T_H = \\bigcup_{n \\in \\mathbb{N}} T_n\\)\n\n\n\n\n\n\n\n\nExercise 6 \nWhy is \\(T_H\\) a Henkin theory?\n\n\n\n\n\\(T_H\\) is no longer a purely symbolic extension of \\(T\\) (in the sense that we simply extend the language), since we add new sentences to \\(T\\) (the sentences in \\(\\Gamma\\) for each iteration step).\n\n\n\n\n\n\nTake-home Problem\n\n\n\n\nShow that for every \\(\\mathcal{L}\\)-formula \\(\\varphi\\), \\[\nT_H \\vdash_{\\mathcal{L}_H} \\varphi \\; \\iff \\; T \\vdash_{\\mathcal{L}} \\varphi\n\\]",
    "crumbs": [
      "9/19 - Henkin theories"
    ]
  },
  {
    "objectID": "007_Sep15_completeness_theorem.html",
    "href": "007_Sep15_completeness_theorem.html",
    "title": "Math 557 Sep 15",
    "section": "",
    "text": "The Completeness Theorem states that\n\n\\[T \\vdash_{\\mathcal{L}} \\varphi  \\; \\iff \\; T \\models \\varphi\\]\n\nThe \\(\\Rightarrow\\)-direction is Soundness, which we already proved.\nThe \\(\\Leftarrow\\)-direction is usually proved in the following form:\n\n\n   If \\(T\\) is consistent, then \\(T\\) has a model.\n\n\nTo construct a model of a consistent theory, we consider the constant terms \\[K := \\{ t \\colon t \\; \\mathcal{L}\\text{-term without variables}\\}\\] and identify provably equal terms: \\[s \\sim t \\; :\\iff \\; T \\vdash_{\\mathcal{L}} s = t\\]\nThe canonical term structure \\(\\mathcal{A}\\) of \\(T\\) has universe \\(A = K/\\sim\\).\nMoreover, we put\n\n\\(c^{\\mathcal{A}} := [c]\\)\n\\(f^{\\mathcal{A}}([t_1], \\dots, [t_n]) := [ft_1\\dots t_n]\\)\n\\(R^{\\mathcal{A}}([t_1], \\dots, [t_n]) \\; : \\iff \\; T \\vdash_{\\mathcal{L}} Rt_1\\dots t_n\\)\n\nIt holds that for any atomic sentence \\(\\sigma\\), \\[\\mathcal{A} \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]\n\n\n\n\n\n\n\n\n\n\nDiscuss\n\n\n\nWe all believe (I think) that \\((\\mathbb{Z}, +, 0)\\) is a model of the group axioms. To what extent does this prove that the group axioms are consistent?\n\n\n\n\n\n\n\n\n\nExercise 1 \nVerify that \\(\\sim\\) is an equivalence relation.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nVerify that the definition of \\(c^{\\mathcal{A}}, f^{\\mathcal{A}}, R^{\\mathcal{A}}\\) does not depend on the choice of representative for \\([c]\\) and \\([t_i]\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nVerify the claim that for atomic sentences, \\[\\mathcal{A}_T \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]",
    "crumbs": [
      "9/15 - Completeness theorem"
    ]
  },
  {
    "objectID": "007_Sep15_completeness_theorem.html#key-concepts",
    "href": "007_Sep15_completeness_theorem.html#key-concepts",
    "title": "Math 557 Sep 15",
    "section": "",
    "text": "The Completeness Theorem states that\n\n\\[T \\vdash_{\\mathcal{L}} \\varphi  \\; \\iff \\; T \\models \\varphi\\]\n\nThe \\(\\Rightarrow\\)-direction is Soundness, which we already proved.\nThe \\(\\Leftarrow\\)-direction is usually proved in the following form:\n\n\n   If \\(T\\) is consistent, then \\(T\\) has a model.\n\n\nTo construct a model of a consistent theory, we consider the constant terms \\[K := \\{ t \\colon t \\; \\mathcal{L}\\text{-term without variables}\\}\\] and identify provably equal terms: \\[s \\sim t \\; :\\iff \\; T \\vdash_{\\mathcal{L}} s = t\\]\nThe canonical term structure \\(\\mathcal{A}\\) of \\(T\\) has universe \\(A = K/\\sim\\).\nMoreover, we put\n\n\\(c^{\\mathcal{A}} := [c]\\)\n\\(f^{\\mathcal{A}}([t_1], \\dots, [t_n]) := [ft_1\\dots t_n]\\)\n\\(R^{\\mathcal{A}}([t_1], \\dots, [t_n]) \\; : \\iff \\; T \\vdash_{\\mathcal{L}} Rt_1\\dots t_n\\)\n\nIt holds that for any atomic sentence \\(\\sigma\\), \\[\\mathcal{A} \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]",
    "crumbs": [
      "9/15 - Completeness theorem"
    ]
  },
  {
    "objectID": "007_Sep15_completeness_theorem.html#problems",
    "href": "007_Sep15_completeness_theorem.html#problems",
    "title": "Math 557 Sep 15",
    "section": "",
    "text": "Discuss\n\n\n\nWe all believe (I think) that \\((\\mathbb{Z}, +, 0)\\) is a model of the group axioms. To what extent does this prove that the group axioms are consistent?\n\n\n\n\n\n\n\n\n\nExercise 1 \nVerify that \\(\\sim\\) is an equivalence relation.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nVerify that the definition of \\(c^{\\mathcal{A}}, f^{\\mathcal{A}}, R^{\\mathcal{A}}\\) does not depend on the choice of representative for \\([c]\\) and \\([t_i]\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nVerify the claim that for atomic sentences, \\[\\mathcal{A}_T \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]",
    "crumbs": [
      "9/15 - Completeness theorem"
    ]
  },
  {
    "objectID": "011_Sep24_compactness.html",
    "href": "011_Sep24_compactness.html",
    "title": "Math 557 Sep 24",
    "section": "",
    "text": "Theorem: A theory \\(T\\) has a model if and only if every finite subtheory \\(T_0 \\subseteq T\\) has a model.\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 \nLet \\(X\\) be the set of all maximally consistent \\(\\mathcal{L}\\)-theories. Recall that the sets \\[\\langle \\sigma \\rangle = \\{ T \\in X \\colon \\sigma \\in T\\} \\quad (\\sigma \\text{ $\\mathcal{L}$-sentence})\\] generate a Hausdorff topology on \\(X\\).\nShow that the topology is compact.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nOne can use the compactness theorem to construct non-standard models of arithmetic, i.e., models of \\(\\operatorname{Th}(\\mathbb{N}, 0, 1, +, \\cdot, &lt;)\\) not isomorphic to \\(\\mathbb{N}\\).\nUse the same technique for \\(\\operatorname{Th}(\\mathbb{R}, \\{c_a : a \\in \\mathbb{R}\\}, +, \\cdot, &lt;)\\), where for every \\(a \\in \\mathbb{R}\\) we add a constant symbol \\(c_a\\) to the language? What kind of structure do we obtain? Discuss.\n\n\n\n\n\n\n\n\n\n\nTake-home Problem\n\n\n\n\nUse the compactness theorem to show (without using the Axiom of Choice) that every set can be linearly ordered.\nTry to strengthen this to:\n\nEvery partial order can be extended to a linear order.",
    "crumbs": [
      "9/24 - Compactness theorem"
    ]
  },
  {
    "objectID": "011_Sep24_compactness.html#key-concepts",
    "href": "011_Sep24_compactness.html#key-concepts",
    "title": "Math 557 Sep 24",
    "section": "",
    "text": "Theorem: A theory \\(T\\) has a model if and only if every finite subtheory \\(T_0 \\subseteq T\\) has a model.",
    "crumbs": [
      "9/24 - Compactness theorem"
    ]
  },
  {
    "objectID": "011_Sep24_compactness.html#problems",
    "href": "011_Sep24_compactness.html#problems",
    "title": "Math 557 Sep 24",
    "section": "",
    "text": "Exercise 1 \nLet \\(X\\) be the set of all maximally consistent \\(\\mathcal{L}\\)-theories. Recall that the sets \\[\\langle \\sigma \\rangle = \\{ T \\in X \\colon \\sigma \\in T\\} \\quad (\\sigma \\text{ $\\mathcal{L}$-sentence})\\] generate a Hausdorff topology on \\(X\\).\nShow that the topology is compact.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nOne can use the compactness theorem to construct non-standard models of arithmetic, i.e., models of \\(\\operatorname{Th}(\\mathbb{N}, 0, 1, +, \\cdot, &lt;)\\) not isomorphic to \\(\\mathbb{N}\\).\nUse the same technique for \\(\\operatorname{Th}(\\mathbb{R}, \\{c_a : a \\in \\mathbb{R}\\}, +, \\cdot, &lt;)\\), where for every \\(a \\in \\mathbb{R}\\) we add a constant symbol \\(c_a\\) to the language? What kind of structure do we obtain? Discuss.\n\n\n\n\n\n\n\n\n\n\nTake-home Problem\n\n\n\n\nUse the compactness theorem to show (without using the Axiom of Choice) that every set can be linearly ordered.\nTry to strengthen this to:\n\nEvery partial order can be extended to a linear order.",
    "crumbs": [
      "9/24 - Compactness theorem"
    ]
  },
  {
    "objectID": "midterm_2_preparation.html",
    "href": "midterm_2_preparation.html",
    "title": "MATH 557 Midterm 2 Preparation",
    "section": "",
    "text": "The second midterm will have two parts:",
    "crumbs": [
      "Midterm 2 Prep"
    ]
  },
  {
    "objectID": "midterm_2_preparation.html#theorems",
    "href": "midterm_2_preparation.html#theorems",
    "title": "MATH 557 Midterm 2 Preparation",
    "section": "Theorems",
    "text": "Theorems\n\nTheorem 1Any two countable models of \\(\\operatorname{DLO}\\) are isomorphic.\n\n\n\nTheorem 2Suppose for \\(\\mathcal{L}\\)-theories \\(\\mathcal{M}, \\mathcal{N}\\), \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) and for any formula \\(\\psi(x, \\vec{y})\\) and any \\(\\vec{a} \\in M\\), if there exists \\(b \\in N\\) such that \\(\\mathcal{N} \\models \\psi[b, \\vec{a}]\\), then there also exists \\(c \\in M\\) such that \\(\\mathcal{N} \\models \\psi[c, \\vec{a}]\\). Then \\(\\mathcal{M} \\preceq \\mathcal{N}\\).\n\n\n\nTheorem 3Let \\(\\mathcal{A}\\) be an \\(\\mathcal{L}\\)-structure, \\(\\kappa\\) an infinite cardinal with \\(\\operatorname{card}(\\mathcal{L}) \\le \\kappa\\) and \\(\\kappa \\le \\operatorname{card}(A)\\). Then there exists a structure \\(\\mathcal{B}\\) with \\[\n\\mathcal{B} \\preceq  \\mathcal{A} \\; , \\; \\operatorname{card}(B) = \\kappa.\n\\]\n\n\n\nTheorem 4Let \\(\\mathcal{A}\\) be an infinite \\(\\mathcal{L}\\)-structure, \\(\\kappa\\) a cardinal with \\(\\operatorname{card}(\\mathcal{L}) \\le \\kappa\\) and \\(\\operatorname{card}(A) \\le \\kappa\\). Then there exists a structure \\(\\mathcal{B}\\) with \\[\n\\mathcal{A} \\preceq  \\mathcal{B} \\; , \\;  \\operatorname{card}(B) = \\kappa.\n\\]\n\n\n\nTheorem 5Suppose \\(T\\) is a consistent \\(\\mathcal{L}\\)-theory with no finite models. If \\(T\\) is \\(\\kappa\\)-categorical for some \\(\\kappa \\geq |\\mathcal{L}|\\), then \\(T\\) is complete.\n\n\n\nTheorem 6Let \\(\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\\) be an ultraproduct. For every \\(\\mathcal{L}\\)-formula \\(\\varphi(x_1,\\dots,x_n)\\) and tuples\n\\(\\vec a \\in \\prod_{i \\in I} M_i\\), \\[\n\\mathcal{M}/\\mathcal{U} \\models \\varphi[\\vec a_{\\mathcal{U}}]\n\\iff\n\\{\\, i \\in I : \\mathcal{M}_i \\models \\varphi[\\vec a_i]\\,\\} \\in \\mathcal{U}.\n\\]\n\n\n\nTheorem 7Any two countable homogeneous structures with the same age are isomorphic.",
    "crumbs": [
      "Midterm 2 Prep"
    ]
  },
  {
    "objectID": "midterm_2_preparation.html#problems",
    "href": "midterm_2_preparation.html#problems",
    "title": "MATH 557 Midterm 2 Preparation",
    "section": "Problems",
    "text": "Problems\n\nProblem 1Let \\(\\mathcal{L}\\) be an arbitrary language. Show that for finite \\(\\mathcal{L}\\)-structures \\(\\mathcal{M}, \\mathcal{N}\\), \\[\n\\mathcal{M} \\equiv \\mathcal{N} \\; \\iff \\; \\mathcal{M} \\cong \\mathcal{N}\n\\]\n\n\n\nProblem 2\nA model \\(\\mathcal{M}\\) of an \\(\\mathcal{L}\\)-theory \\(T\\) is prime if for every \\(\\mathcal{N} \\models T\\), there exists an elementary embedding of \\(\\mathcal{M}\\) into \\(\\mathcal{N}\\).\n\nShow that \\(\\mathbb{N}\\) is a prime model of \\(\\operatorname{Th}(\\mathbb{N},+,\\cdot, 0, 1)\\).\nShow that if \\(T\\) is an \\(\\omega\\)-categorical theory over a countable language and has no finite models, \\(T\\) has a prime model.\n\n\n\n\nProblem 3If we take an ultraproduct over the same structure \\(\\mathcal{M}\\) along an index set \\(I\\), we call this an ultrapower, denoted by \\[\n\\mathcal{M}^I/\\mathcal{U}\n\\]\nLet \\(\\mathcal{U}\\) be a free ultrafilter on an (infinite) set \\(I\\). The map \\(j: b \\mapsto (b)_{i \\in I}/\\mathcal{U}\\) defines an elementary embedding of \\(\\mathcal{M}\\) into \\(\\mathcal{M}^I/\\mathcal{U}\\) (i.e. it is injective and the image is an elementary substructure).\nShow that if \\(\\mathcal{M}\\) is infinite and \\(I = \\mathbb{N}\\), \\(j\\) is not a surjection.\n\n\n\nProblem 4Let \\(G_N\\) be the set of all simple graphs on the vertex set \\(\\{1, \\dots, N\\}\\). Let \\(\\mathbb{P}_N(\\sigma)\\) be the probability that an \\(\\mathcal{L}_G\\)-sentence \\(\\sigma\\) holds for a random graph in \\(G_N\\), i.e. \\[\n\\mathbb{P}_N(\\sigma)=  \\frac{|\\{ \\mathcal{G} \\in G_N : \\mathcal{G} \\models \\sigma\\}|}{|G_N|}.\n\\]\nShow that for any \\(\\mathcal{L}_G\\)-sentence \\(\\sigma\\), \\[\n\\text{either } \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 0 \\text{ or } \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 1.\n\\]",
    "crumbs": [
      "Midterm 2 Prep"
    ]
  },
  {
    "objectID": "006_Sep12_completeness.html",
    "href": "006_Sep12_completeness.html",
    "title": "Math 557 Sep 12",
    "section": "",
    "text": "Consistency:\nA theory \\(T\\) is consistent if there does not exist a formula \\(\\psi\\) such that \\(T \\vdash \\psi\\) and \\(T \\vdash \\neg \\psi\\).\nCompleteness:\nA theory \\(T\\) is complete if it is consistent and for every sentence \\(\\sigma\\), \\(T \\vdash \\sigma\\) or \\(T \\vdash \\neg \\sigma\\).\nIn a complete theory, every statement is determined, in the sense that is either true or false in the theory.\nAn important example of a complete theory is the theory of a fixed structure \\(\\mathcal{M}\\),\n\n\\[\\operatorname{Th}(\\mathcal{M}) = \\{ \\sigma \\colon \\mathcal{M} \\models \\sigma \\}\\]\n\nIf, on the other hand, we are given a complete theory \\(T\\), does \\(T\\) have a model? This is the subject of the Completeness Theorem. It actually shows that any consistent theory has a model.\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 (Carry-over from Sep 10) \nProve the Soundness Theorem, i.e. show that\n\\[T \\vdash \\varphi \\; \\Rightarrow \\; T \\models \\varphi\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nWhy is the theory of a structure, \\(\\operatorname{Th}(\\mathcal{M})\\), indeed a complete theory?\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nShow that a theory \\(T\\) is inconsistent iff for every formula \\(\\psi\\), \\(T \\vdash \\psi\\)\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nFor each of the following classes \\(\\mathbf{K}\\) of structures, determine whether they are axiomatizable, i.e. whether there exists a theory \\(T\\) (in the language of the structures) such that\n\\[\\mathbf{K} = \\{ \\mathcal{M} \\colon \\mathcal{M} \\models T \\}\\]\n(In this case \\(K\\) is also called elementary.)\nIf \\(\\mathbf{K}\\) is axiomatizable, discuss whether it is actually finitely axiomatizable (i.e. can \\(T\\) be chosen finite). And is \\(T\\) complete?\n\n\\(\\mathbf{K} =\\) Abelian groups\n\\(\\mathbf{K} =\\) infinite sets\n\\(\\mathbf{K} =\\) fields of characteristic \\(p\\) (\\(p\\) prime)\n\\(\\mathbf{K} =\\) bipartite graphs\n\\(\\mathbf{K} =\\) torsion groups (all elements have finite order)\n\\(\\mathbf{K} =\\) algebraically closed fields of characteristic \\(0\\)\n\n(Note: We do not yet have the tools to rigorously answer all these questions, but try an “educated” guess.)\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nSuppose that \\(T \\cup \\{\\neg\\varphi\\}\\) is inconsistent. Show that \\(T \\vdash \\varphi\\).\n(This is a technical formulation of the legitimacy of proofs by contradiction.)",
    "crumbs": [
      "9/12 - Complete theories"
    ]
  },
  {
    "objectID": "006_Sep12_completeness.html#key-concepts",
    "href": "006_Sep12_completeness.html#key-concepts",
    "title": "Math 557 Sep 12",
    "section": "",
    "text": "Consistency:\nA theory \\(T\\) is consistent if there does not exist a formula \\(\\psi\\) such that \\(T \\vdash \\psi\\) and \\(T \\vdash \\neg \\psi\\).\nCompleteness:\nA theory \\(T\\) is complete if it is consistent and for every sentence \\(\\sigma\\), \\(T \\vdash \\sigma\\) or \\(T \\vdash \\neg \\sigma\\).\nIn a complete theory, every statement is determined, in the sense that is either true or false in the theory.\nAn important example of a complete theory is the theory of a fixed structure \\(\\mathcal{M}\\),\n\n\\[\\operatorname{Th}(\\mathcal{M}) = \\{ \\sigma \\colon \\mathcal{M} \\models \\sigma \\}\\]\n\nIf, on the other hand, we are given a complete theory \\(T\\), does \\(T\\) have a model? This is the subject of the Completeness Theorem. It actually shows that any consistent theory has a model.",
    "crumbs": [
      "9/12 - Complete theories"
    ]
  },
  {
    "objectID": "006_Sep12_completeness.html#problems",
    "href": "006_Sep12_completeness.html#problems",
    "title": "Math 557 Sep 12",
    "section": "",
    "text": "Exercise 1 (Carry-over from Sep 10) \nProve the Soundness Theorem, i.e. show that\n\\[T \\vdash \\varphi \\; \\Rightarrow \\; T \\models \\varphi\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nWhy is the theory of a structure, \\(\\operatorname{Th}(\\mathcal{M})\\), indeed a complete theory?\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nShow that a theory \\(T\\) is inconsistent iff for every formula \\(\\psi\\), \\(T \\vdash \\psi\\)\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nFor each of the following classes \\(\\mathbf{K}\\) of structures, determine whether they are axiomatizable, i.e. whether there exists a theory \\(T\\) (in the language of the structures) such that\n\\[\\mathbf{K} = \\{ \\mathcal{M} \\colon \\mathcal{M} \\models T \\}\\]\n(In this case \\(K\\) is also called elementary.)\nIf \\(\\mathbf{K}\\) is axiomatizable, discuss whether it is actually finitely axiomatizable (i.e. can \\(T\\) be chosen finite). And is \\(T\\) complete?\n\n\\(\\mathbf{K} =\\) Abelian groups\n\\(\\mathbf{K} =\\) infinite sets\n\\(\\mathbf{K} =\\) fields of characteristic \\(p\\) (\\(p\\) prime)\n\\(\\mathbf{K} =\\) bipartite graphs\n\\(\\mathbf{K} =\\) torsion groups (all elements have finite order)\n\\(\\mathbf{K} =\\) algebraically closed fields of characteristic \\(0\\)\n\n(Note: We do not yet have the tools to rigorously answer all these questions, but try an “educated” guess.)\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nSuppose that \\(T \\cup \\{\\neg\\varphi\\}\\) is inconsistent. Show that \\(T \\vdash \\varphi\\).\n(This is a technical formulation of the legitimacy of proofs by contradiction.)",
    "crumbs": [
      "9/12 - Complete theories"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "001_Aug27_syntax.html",
    "href": "001_Aug27_syntax.html",
    "title": "Math 557 August 27",
    "section": "",
    "text": "Problems\n\n\n\n\n\n\n\nExercise 1 \nThe set of \\(\\cal{L}\\)-terms \\(\\mathcal{T}^{\\mathcal{L}}\\) is defined as the smallest set (with respect to \\(\\subseteq\\)) containing variables and constant symbols and that is closed under function symbol application.\n\nWhy do this set exist?\nDoes a similar argument work for the set of \\(\\mathcal{L}\\)-formulas?\nFind an example of a (non-empty) family of sets and a property \\(P\\) (applicable to the sets in the family) such that a \\(\\subseteq\\)-smallest set with property \\(P\\) does not exist.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nProve the Readbility Lemma: For any term \\(t\\), exactly one of the following holds.\n\nThere exists a \\(v \\in \\mathcal{V}\\) such that \\(t \\equiv v\\).\nThere exists a \\(c \\in \\mathcal{C}^{\\mathcal{L}}\\) such that \\(t \\equiv c\\).\nThere exists a number \\(n \\in \\mathbb{N}\\), a function symbol \\(f\n\\in F_n^{\\mathcal{L}}\\), and terms \\(t_1,\n\\dots, t_n\\) such that \\(t \\equiv ft_1\\dots t_n\\).\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nShow that no proper initial segment of a term is a term. (Use induction on the length of a term.)\nDeduce unique readability: The decomposition in (3.) above is unique.\n\n\n\n\n\n\n\n\n\n\nTake-home Problem\n\n\n\n\nProve unique readability for the set of \\(\\mathcal{L}\\)-formulas.\n\n\n\n\n\n\n\n\n\nExercise 4 \nThe set \\(C\\) is defined as the smallest set of finite strings over the alphabet \\(\\{\\times, \\circ\\}\\) such that\n\n(C1) \\(\\times \\in  C\\),\n(C2) \\(\\circ \\in C\\),\n(C3) if \\(s , t \\in C\\) and the last symbol in \\(s\\) differs from the the first symbol in \\(t\\), then \\(s t \\in C\\) (where \\(st\\) is the concatenation of \\(s\\) and \\(t\\)).\n\nFormulate the property of unique readability for the system (C1)-(C3) and argue that it does not hold for this system.\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nLet \\(\\mathcal{L} = (0,&lt;)\\) be a language with one constant symbol \\(0\\) and one binary relation symbol \\(&lt;\\). In the following, for sake of (human) readability, we write \\(0 &lt; v_1\\) instead of \\(&lt; 0 v_1\\).\nConsider the expression\n\\[\\phi \\equiv  (\\exists v_2 \\; v_1 &lt; v_2 \\wedge \\exists v_1 \\;v_2 &lt; 0).\\]\n\nIs this a correct \\(\\mathcal{L}\\)-formula?\nCharacterize every variable occurrence in \\(\\phi\\) as free or bound.",
    "crumbs": [
      "8/27 - Syntax of first order logic"
    ]
  },
  {
    "objectID": "029_Nov14_Goedel_numbers.html",
    "href": "029_Nov14_Goedel_numbers.html",
    "title": "Math 557 Nov 14",
    "section": "",
    "text": "We can code formulas of the language of \\(\\mathsf{PA}^-\\) as natural numbers, the so-called Gödel numbers. They let us express syntactical properties of arithmetic formulas as number-theoretic properties in the language of arithmetic. This will be important for the self-referential argument at the heart of the first incompleteness theorem. Below, “term” and “formula” always refer to the language \\(\\mathcal{L} = \\{0,1,+,*, &lt;\\}\\).\n\n\nUsing primitive recursion, we assign every term \\(t\\) a Gödel-Nummer \\(\\ulcorner t \\urcorner\\):\n\\[\n\\begin{aligned}\n\\ulcorner 0 \\urcorner \\; \\; &= \\; \\;  1\\\\\n\\ulcorner 1 \\urcorner \\; \\; &= \\; \\;  3\\\\\n\\ulcorner v_i \\urcorner \\; \\; &= \\; \\;  3^2 \\cdot 5^i\\\\\n\\ulcorner s+t \\urcorner \\; \\; &= \\; \\;  3^3 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\\\\\n\\ulcorner s \\cdot t \\urcorner \\; \\; &= \\; \\;  3^4 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\nExample 1 \\[\\ulcorner v_3 + 1 \\urcorner = 3^3 \\cdot 5^{3^2 \\cdot 5^3}  \\cdot 7^3\\]\n\n\n\n\nUsing the Gödel numbers of terms, we can again recursively assign each formula \\(\\varphi\\) a Gödel number \\(\\ulcorner \\varphi \\urcorner\\):\n\\[\n\\begin{aligned}\n\\ulcorner s=t \\urcorner \\; \\; &= \\; \\;  2 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\\\\\n\\ulcorner s&lt;t \\urcorner \\; \\; &= \\; \\;  2 \\cdot 3 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\\\\\n\\ulcorner \\neg \\varphi \\urcorner \\; \\; &= \\; \\;  2 \\cdot 3^2 \\cdot 5^{\\ulcorner s \\urcorner} \\\\\n\\ulcorner (\\varphi \\land \\psi \\urcorner) \\; \\; &= \\; \\;  2 \\cdot 3^3 \\cdot 5^{\\ulcorner \\varphi \\urcorner}  \\cdot 7^{\\ulcorner \\psi \\urcorner}\\\\\n\\ulcorner \\exists v_i \\varphi \\urcorner \\; \\; &= \\; \\;  2 \\cdot 3^4 \\cdot 5^i \\cdot 7^{\\ulcorner \\varphi \\urcorner}\\\\\n\\end{aligned}\n\\]\nThere are, of course, other coding schemes for formulas that work equally well. The crucial property of any suitable numbering is that we are able to effectively recognize Gödel numbers of basic syntactical objects.\n\n\n\nBased on the simple recursive definition of \\(\\ulcorner . \\urcorner\\), we have\n\n\n\n\n\n\n\nProposition 1 \nThe following sets are recursive, in fact, primitve recursive:\n\n\\(\\{ m : m \\text{ is the Gödel number of a term } t \\}\\)\n\\(\\{ m : m \\text{ is the Gödel number of a formula } \\varphi \\}\\)\n\\(\\{ \\langle m,n \\rangle : m \\text{ is the Gödel number of a formula } \\varphi \\text{ in which } n \\text{ variables occur}   \\}\\)\n\\(\\{ \\langle m,k \\rangle : m \\text{ is the Gödel number of a formula } \\varphi \\text{ in which } k \\text{ variables occur free}   \\}\\)\n\\(\\{ m : m \\text{ is the Gödel number of a sentence } \\sigma \\}\\)\n\n\n\n\n\nWe can appeal to the Church-Turing Thesis to prove this (you should think of informal algorithms to compute these sets). To show the sets are actually primitive recursive, you can use recursion and bounded search - the Gödel numbers of subformulas (subterms) are smaller than the Gödel number of the overall formula (term). Work by induction on height – show that the properties for all formulas (terms) of a fixed height are primitive recursive. Finally, note that the height is always bounded by the length of a formula (term). We leave the details as an exercise.\nWe can also show that the set of Gödel numbers of logical axioms is primitive recursive. This is relatively straightforward for the equality and quantifier axioms, as these are defined according to a syntactic scheme. The set of tautologies is a little trickier, since this is defined semantically.\n\n\n\n\n\n\n\nExercise 1 Show that the set\n\\[\n\\operatorname{Taut} = \\{ \\ulcorner \\varphi \\urcorner : \\: \\varphi \\text{ is a tautology} \\}\n\\]\nis (primitive) recursive.\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 The set\n\\[\n\\operatorname{Ax} = \\{ \\ulcorner \\varphi \\urcorner : \\: \\varphi \\text{ is a logical axiom} \\}\n\\]\nis (primitive) recursive.\n\n\n\n\nGiven a finite sequence of Gödel numbers of formulas,\n\\[\n\\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner\n\\]\nwe can use the usual sequence coding to code this as a single number denoted as\n\\[\n\\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle.\n\\]\n\n\n\n\n\n\n\nLemma 1 The relation\n\\[\n\\operatorname{Prf}(x,y) :\\ \\iff x = \\ulcorner \\psi \\urcorner, y = \\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle, \\varphi_1, \\dots, \\varphi_n \\text{ is a proof of } \\psi\n\\]\nis (primitive) recursive.\n\n\n\n\n\nProof (sketch). Given \\((x,y)\\), one first checks if \\(x\\) is the Gödel number of a formula \\(\\psi\\). If yes, it suffices to decode and to test whether all components of \\(y\\) are Gödel numbers of formulas \\(\\varphi_i\\), the last one being equal to \\(\\psi\\), and whether for every \\(i\\), either \\(\\varphi_i\\) is a logical axiom (which is primitive recursive by Theorem 1) or whether it can be obtained using deduction rules from previous formulas.\n\n\n\n\nRecall that given a theory \\(T\\), its deductive closure is defined as \\[\nT^\\vdash = \\{ \\sigma : T \\vdash \\sigma \\}.\n\\]\nFor any set of formulas \\(S\\), let \\[\n\\ulcorner S \\urcorner = \\{ \\ulcorner \\varphi \\urcorner : \\varphi \\in S \\}.\n\\]\n\n\n\n\n\n\n\nDefinition 1 \nLet \\(T\\) be a theory in the language of \\(\\mathsf{PA}^-\\).\n\n\\(T\\) is recursive if \\(\\{ \\ulcorner \\sigma \\urcorner : \\sigma \\in T \\}\\) is a recursive set.\n\\(T\\) is recursively axiomatizable if there exists a recursive \\(\\widetilde{T}\\) with \\((\\widetilde{T})^\\vdash = T^\\vdash\\).\n\\(T\\) is decidable if the set \\(\\{ \\ulcorner \\sigma \\urcorner : T \\vdash \\sigma \\}\\) is recursive.\n\n\n\n\n\nSimilarly to Lemma 1, one can show\n\n\n\n\n\n\n\nLemma 2 \nIf \\(T\\) is a recursive theory, then the relation\n\\[\n\\operatorname{Prf}_T(x,y) :\\ \\iff x = \\ulcorner \\psi \\urcorner, y = \\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle, \\varphi_1, \\dots, \\varphi_n \\text{ is a $T$-proof of } \\psi\n\\]\nis recursive.\n\n\n\n\n\n\n\n\n\n\n\nTheorem 2 \nIf \\(T\\) is recursively axiomatizable, then \\(\\ulcorner T^\\vdash \\urcorner\\) is recursively enumerable.\n\n\n\n\n\nProof. Let \\(\\widetilde{T}\\) be a recursive theory such that \\((\\widetilde{T})^\\vdash = T^\\vdash\\). We have \\(\\varphi \\in T^\\vdash\\) if and only if \\(\\varphi\\) is a sentence and there exists a proof of \\(\\varphi\\) in \\(\\widetilde{T}\\). Hence, by Proposition 1 and Lemma 2, \\(\\varphi \\in T^\\vdash\\) can be expressed via an existential quantifier over a recursive property, which implies it is recursively enumerable.\n\n\n\n\n\n\n\n\nTheorem 3 \nIf \\(T\\) is recursively axiomatizable and complete, then \\(T\\) is decidable.\n\n\n\n\n\nProof. Since by Theorem 2, \\(\\ulcorner T^\\vdash \\urcorner\\) is r.e., it suffices to show that \\(\\mathbb{N} \\setminus \\ulcorner T^\\vdash \\urcorner\\) is r.e.\nSince \\(T\\) is complete, \\(\\mathbb{N} \\setminus \\ulcorner T^\\vdash \\urcorner\\) is the union of \\(A= \\{ \\ulcorner \\varphi \\urcorner : \\neg \\varphi \\in T^\\vdash\\}\\) and \\(B= \\{ x : x \\text{ is not the Gödel number of a sentence} \\}\\). \\(B\\) is primitive recursive, while \\(A\\) is r.e.: simply enumerate \\(\\ulcorner T^\\vdash \\urcorner\\), and whenever a sentence of the form \\(\\neg \\varphi\\) is listed, enumerate \\(\\varphi\\) into \\(A\\).",
    "crumbs": [
      "11/14 - Gödelization"
    ]
  },
  {
    "objectID": "029_Nov14_Goedel_numbers.html#gödel-numbers",
    "href": "029_Nov14_Goedel_numbers.html#gödel-numbers",
    "title": "Math 557 Nov 14",
    "section": "",
    "text": "Using primitive recursion, we assign every term \\(t\\) a Gödel-Nummer \\(\\ulcorner t \\urcorner\\):\n\\[\n\\begin{aligned}\n\\ulcorner 0 \\urcorner \\; \\; &= \\; \\;  1\\\\\n\\ulcorner 1 \\urcorner \\; \\; &= \\; \\;  3\\\\\n\\ulcorner v_i \\urcorner \\; \\; &= \\; \\;  3^2 \\cdot 5^i\\\\\n\\ulcorner s+t \\urcorner \\; \\; &= \\; \\;  3^3 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\\\\\n\\ulcorner s \\cdot t \\urcorner \\; \\; &= \\; \\;  3^4 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\n\\end{aligned}\n\\]\n\n\n\n\n\n\n\nExample 1 \\[\\ulcorner v_3 + 1 \\urcorner = 3^3 \\cdot 5^{3^2 \\cdot 5^3}  \\cdot 7^3\\]\n\n\n\n\nUsing the Gödel numbers of terms, we can again recursively assign each formula \\(\\varphi\\) a Gödel number \\(\\ulcorner \\varphi \\urcorner\\):\n\\[\n\\begin{aligned}\n\\ulcorner s=t \\urcorner \\; \\; &= \\; \\;  2 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\\\\\n\\ulcorner s&lt;t \\urcorner \\; \\; &= \\; \\;  2 \\cdot 3 \\cdot 5^{\\ulcorner s \\urcorner}  \\cdot 7^{\\ulcorner t \\urcorner}\\\\\n\\ulcorner \\neg \\varphi \\urcorner \\; \\; &= \\; \\;  2 \\cdot 3^2 \\cdot 5^{\\ulcorner s \\urcorner} \\\\\n\\ulcorner (\\varphi \\land \\psi \\urcorner) \\; \\; &= \\; \\;  2 \\cdot 3^3 \\cdot 5^{\\ulcorner \\varphi \\urcorner}  \\cdot 7^{\\ulcorner \\psi \\urcorner}\\\\\n\\ulcorner \\exists v_i \\varphi \\urcorner \\; \\; &= \\; \\;  2 \\cdot 3^4 \\cdot 5^i \\cdot 7^{\\ulcorner \\varphi \\urcorner}\\\\\n\\end{aligned}\n\\]\nThere are, of course, other coding schemes for formulas that work equally well. The crucial property of any suitable numbering is that we are able to effectively recognize Gödel numbers of basic syntactical objects.",
    "crumbs": [
      "11/14 - Gödelization"
    ]
  },
  {
    "objectID": "029_Nov14_Goedel_numbers.html#computability-of-syntactic-properties",
    "href": "029_Nov14_Goedel_numbers.html#computability-of-syntactic-properties",
    "title": "Math 557 Nov 14",
    "section": "",
    "text": "Based on the simple recursive definition of \\(\\ulcorner . \\urcorner\\), we have\n\n\n\n\n\n\n\nProposition 1 \nThe following sets are recursive, in fact, primitve recursive:\n\n\\(\\{ m : m \\text{ is the Gödel number of a term } t \\}\\)\n\\(\\{ m : m \\text{ is the Gödel number of a formula } \\varphi \\}\\)\n\\(\\{ \\langle m,n \\rangle : m \\text{ is the Gödel number of a formula } \\varphi \\text{ in which } n \\text{ variables occur}   \\}\\)\n\\(\\{ \\langle m,k \\rangle : m \\text{ is the Gödel number of a formula } \\varphi \\text{ in which } k \\text{ variables occur free}   \\}\\)\n\\(\\{ m : m \\text{ is the Gödel number of a sentence } \\sigma \\}\\)\n\n\n\n\n\nWe can appeal to the Church-Turing Thesis to prove this (you should think of informal algorithms to compute these sets). To show the sets are actually primitive recursive, you can use recursion and bounded search - the Gödel numbers of subformulas (subterms) are smaller than the Gödel number of the overall formula (term). Work by induction on height – show that the properties for all formulas (terms) of a fixed height are primitive recursive. Finally, note that the height is always bounded by the length of a formula (term). We leave the details as an exercise.\nWe can also show that the set of Gödel numbers of logical axioms is primitive recursive. This is relatively straightforward for the equality and quantifier axioms, as these are defined according to a syntactic scheme. The set of tautologies is a little trickier, since this is defined semantically.\n\n\n\n\n\n\n\nExercise 1 Show that the set\n\\[\n\\operatorname{Taut} = \\{ \\ulcorner \\varphi \\urcorner : \\: \\varphi \\text{ is a tautology} \\}\n\\]\nis (primitive) recursive.\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 The set\n\\[\n\\operatorname{Ax} = \\{ \\ulcorner \\varphi \\urcorner : \\: \\varphi \\text{ is a logical axiom} \\}\n\\]\nis (primitive) recursive.\n\n\n\n\nGiven a finite sequence of Gödel numbers of formulas,\n\\[\n\\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner\n\\]\nwe can use the usual sequence coding to code this as a single number denoted as\n\\[\n\\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle.\n\\]\n\n\n\n\n\n\n\nLemma 1 The relation\n\\[\n\\operatorname{Prf}(x,y) :\\ \\iff x = \\ulcorner \\psi \\urcorner, y = \\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle, \\varphi_1, \\dots, \\varphi_n \\text{ is a proof of } \\psi\n\\]\nis (primitive) recursive.\n\n\n\n\n\nProof (sketch). Given \\((x,y)\\), one first checks if \\(x\\) is the Gödel number of a formula \\(\\psi\\). If yes, it suffices to decode and to test whether all components of \\(y\\) are Gödel numbers of formulas \\(\\varphi_i\\), the last one being equal to \\(\\psi\\), and whether for every \\(i\\), either \\(\\varphi_i\\) is a logical axiom (which is primitive recursive by Theorem 1) or whether it can be obtained using deduction rules from previous formulas.",
    "crumbs": [
      "11/14 - Gödelization"
    ]
  },
  {
    "objectID": "029_Nov14_Goedel_numbers.html#decidable-theories",
    "href": "029_Nov14_Goedel_numbers.html#decidable-theories",
    "title": "Math 557 Nov 14",
    "section": "",
    "text": "Recall that given a theory \\(T\\), its deductive closure is defined as \\[\nT^\\vdash = \\{ \\sigma : T \\vdash \\sigma \\}.\n\\]\nFor any set of formulas \\(S\\), let \\[\n\\ulcorner S \\urcorner = \\{ \\ulcorner \\varphi \\urcorner : \\varphi \\in S \\}.\n\\]\n\n\n\n\n\n\n\nDefinition 1 \nLet \\(T\\) be a theory in the language of \\(\\mathsf{PA}^-\\).\n\n\\(T\\) is recursive if \\(\\{ \\ulcorner \\sigma \\urcorner : \\sigma \\in T \\}\\) is a recursive set.\n\\(T\\) is recursively axiomatizable if there exists a recursive \\(\\widetilde{T}\\) with \\((\\widetilde{T})^\\vdash = T^\\vdash\\).\n\\(T\\) is decidable if the set \\(\\{ \\ulcorner \\sigma \\urcorner : T \\vdash \\sigma \\}\\) is recursive.\n\n\n\n\n\nSimilarly to Lemma 1, one can show\n\n\n\n\n\n\n\nLemma 2 \nIf \\(T\\) is a recursive theory, then the relation\n\\[\n\\operatorname{Prf}_T(x,y) :\\ \\iff x = \\ulcorner \\psi \\urcorner, y = \\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle, \\varphi_1, \\dots, \\varphi_n \\text{ is a $T$-proof of } \\psi\n\\]\nis recursive.\n\n\n\n\n\n\n\n\n\n\n\nTheorem 2 \nIf \\(T\\) is recursively axiomatizable, then \\(\\ulcorner T^\\vdash \\urcorner\\) is recursively enumerable.\n\n\n\n\n\nProof. Let \\(\\widetilde{T}\\) be a recursive theory such that \\((\\widetilde{T})^\\vdash = T^\\vdash\\). We have \\(\\varphi \\in T^\\vdash\\) if and only if \\(\\varphi\\) is a sentence and there exists a proof of \\(\\varphi\\) in \\(\\widetilde{T}\\). Hence, by Proposition 1 and Lemma 2, \\(\\varphi \\in T^\\vdash\\) can be expressed via an existential quantifier over a recursive property, which implies it is recursively enumerable.\n\n\n\n\n\n\n\n\nTheorem 3 \nIf \\(T\\) is recursively axiomatizable and complete, then \\(T\\) is decidable.\n\n\n\n\n\nProof. Since by Theorem 2, \\(\\ulcorner T^\\vdash \\urcorner\\) is r.e., it suffices to show that \\(\\mathbb{N} \\setminus \\ulcorner T^\\vdash \\urcorner\\) is r.e.\nSince \\(T\\) is complete, \\(\\mathbb{N} \\setminus \\ulcorner T^\\vdash \\urcorner\\) is the union of \\(A= \\{ \\ulcorner \\varphi \\urcorner : \\neg \\varphi \\in T^\\vdash\\}\\) and \\(B= \\{ x : x \\text{ is not the Gödel number of a sentence} \\}\\). \\(B\\) is primitive recursive, while \\(A\\) is r.e.: simply enumerate \\(\\ulcorner T^\\vdash \\urcorner\\), and whenever a sentence of the form \\(\\neg \\varphi\\) is listed, enumerate \\(\\varphi\\) into \\(A\\).",
    "crumbs": [
      "11/14 - Gödelization"
    ]
  },
  {
    "objectID": "019_Oct15_fraisse_limits.html",
    "href": "019_Oct15_fraisse_limits.html",
    "title": "MATH 557 Oct 15",
    "section": "",
    "text": "Let \\(\\overline{K}\\) be a class of finitely generated structures. \\(\\overline{K}\\) is called an amalgamation class if it has the following three properties:\n\n\n\n\n\n\n(HP) Hereditary Property\n\n\n\nIf \\(A \\in \\overline{K}\\), \\(\\mathcal{B} \\cong \\mathcal{C} \\in A\\), and \\(\\mathcal{C}\\) is finitely generated, then \\(\\mathcal{B} \\in \\overline{K}\\).\n\n\n\n\n\n\n\n\n(JEP) Joint Embedding Property\n\n\n\nIf \\(A, \\mathcal{B} \\in \\overline{K}\\), then there exists \\(\\mathcal{C} \\in \\overline{K}\\) and embeddings \\[f_0: A \\to \\mathcal{C}, \\quad f_1: \\mathcal{B} \\to \\mathcal{C}\\]\n\n\n\n\n\n\n\n\n(AP) Amalgamation Property\n\n\n\nIf \\(A, \\mathcal{B}, \\mathcal{C} \\in \\overline{K}\\) with embeddings \\(f_0: A \\to \\mathcal{B}\\) and \\(f_1: A \\to \\mathcal{C}\\), then there exists \\(\\mathcal{D} \\in \\overline{K}\\) and embeddings \\[g_0: \\mathcal{B} \\to \\mathcal{D}, \\quad g_1: \\mathcal{C} \\to \\mathcal{D}\\] such that \\(g_0 \\circ f_0 = g_1 \\circ f_1\\).\n\n\n\n\n\n\n\n\n\nExercise 1 \nShow that (AP) does not imply (JEP).\n(Hint: finite fields)\n\n\n\n\n\n\n\n\n\n\n\nExample 1 \n\\(\\overline{K} = \\{ (Z,&lt;): (Z,&lt;) \\text{ finite linear order} \\}\\) forms an amalgamation class.\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 Let \\(\\overline{K}\\) be a class of finitely generated \\(\\mathcal{L}\\)-structures such that there are only countably many isomorphism types in \\(\\overline{K}\\).\nThen: \\(\\overline{K}\\) is an amalgamation class \\(\\Leftrightarrow\\) \\(\\overline{K}\\) is the age of a countable homogeneous \\(\\mathcal{L}\\)-structure.\n\n\n\n\n\nProof. (\\(\\Leftarrow\\)): Suppose \\(\\overline{K} = \\text{age}(\\mathcal{M})\\) where \\(\\mathcal{M}\\) is countable and homogeneous.\n(HP): Holds by definition of age.\n(JEP): Let \\(\\mathcal{A}, \\mathcal{B} \\in \\text{age}(\\mathcal{M})\\). Then \\(A \\cong \\langle A \\rangle^{\\mathcal{M}}\\) and \\(\\mathcal{B} \\cong \\langle B \\rangle^{\\mathcal{M}}\\), with \\(A,B \\subseteq M\\) finite. Then \\(\\mathcal{A}\\) and \\(\\mathcal{B}\\) embed into \\(\\langle A \\cup B \\rangle^{\\mathcal{M}}\\).\n(AP): Suppose \\(f_0: \\mathcal{A} \\to \\mathcal{B}\\) and \\(f_1: \\mathcal{A} \\to \\mathcal{C}\\) are embeddings, where \\(\\mathcal{A}, \\mathcal{B}, \\mathcal{C} \\in \\text{age}(\\mathcal{M})\\).\n\nWithout loss of generality, \\(\\mathcal{A}, \\mathcal{B}, \\mathcal{C} \\subseteq \\mathcal{M}\\) and \\(f_0 = \\text{id}_A\\).\nSince \\(\\mathcal{M}\\) is homogeneous, there exists an automorphism \\(\\pi: \\mathcal{M} \\overset{\\sim}{\\to} \\mathcal{M}\\) such that \\(\\pi^{-1}|_A = f_1\\) (i.e., \\(\\pi\\) extends \\(f_1^{-1}\\)).\nConsider \\(\\mathcal{D} = \\langle B \\cup \\pi^{-1}(C) \\rangle^{\\mathcal{M}}\\). \\(\\mathcal{D}\\) amalgamates \\(\\mathcal{B}\\) and \\(\\mathcal{C}\\) via \\(\\text{id}_{\\mathcal{B}}: \\mathcal{B} \\to \\mathcal{D}\\) and \\(\\pi^{-1}|_C: \\mathcal{C} \\to \\mathcal{D}\\).\n\n(\\(\\Rightarrow\\)): Assume \\(\\overline{K}\\) is an amalgamation class. We construct a structure \\(\\mathcal{N}\\) with \\(\\text{age}(\\mathcal{N}) = \\overline{K}\\) where \\(\\mathcal{N}\\) is homogeneous and has domain \\(N \\subset \\mathbb{N}\\).\nSince \\(\\overline{K}\\) has countably many isomorphism types, we enumerate the elements of \\(\\overline{K}\\) (up to isomorphism) as \\((\\mathcal{K}_e: e \\in \\mathbb{N})\\) where \\(K_e \\subseteq \\mathbb{N}\\).\nConsider tuples \\((\\bar{a}, \\bar{b}, f)\\) where \\(\\bar{a}_i, \\bar{b}_i\\) are finite subsets of \\(\\mathbb{N}\\) and \\(f\\) is a partial function with \\(\\operatorname{dom}(f) = \\bar{a}\\) and \\(\\text{ran}(f) \\subseteq \\bar{b}\\). Enumerate all such triples as \\((\\bar{a}_e, \\bar{b}_e, f_e)\\) so that every \\((\\bar{a}, \\bar{b}, f)\\) occurs infinitely often.\n\\(\\mathcal{N}\\) will be the union of an increasing sequence \\((\\mathcal{C}_n)_{n \\in \\mathbb{N}}\\) where \\(\\mathcal{C}_n \\in \\overline{K}\\).\nInitialize: \\(\\mathcal{C}_0 = \\mathcal{K}_0\\)\nNow assume we have defined \\(\\mathcal{C}_n\\).\nCase \\(n = 2\\ell\\) (even): Apply (JEP) to \\(\\mathcal{C}_n, \\mathcal{K}_\\ell\\) to obtain \\(\\mathcal{C}_{n+1}\\).\nCase \\(n = 2\\ell + 1\\) (odd): If \\(\\bar{a}_\\ell\\) or \\(\\bar{b}_\\ell \\nsubseteq C_n\\), put \\(\\mathcal{C}_{n+1} = \\mathcal{C}_n\\). If \\(\\bar{a}_\\ell, \\bar{b}_\\ell \\subseteq C_n\\), let \\(\\mathcal{A}_\\ell = \\langle \\bar{a}_\\ell \\rangle^{\\mathcal{C}_n}\\) and \\(\\mathcal{B}_\\ell = \\langle \\bar{b}_\\ell \\rangle^{\\mathcal{C}_n} \\subseteq \\mathcal{C}_n\\). Apply (AP) to the embeddings \\(\\operatorname{id}: \\mathcal{A}_\\ell \\to \\mathcal{C}_n\\) and \\(f: \\mathcal{A}_\\ell \\to \\mathcal{B}_\\ell\\) (induced by \\(f_\\ell: \\bar{a}_\\ell \\to \\bar{b}_\\ell\\)). This yields a structure \\(\\mathcal{C}_{n+1} \\in \\overline{K}\\). Renaming if necessary, we can assume \\(\\mathcal{C}_n \\subseteq \\mathcal{C}_{n+1}\\).\nDefine \\(\\mathcal{N} = \\bigcup_{n \\in \\mathbb{N}} \\mathcal{C}_n\\).\nClaim 1: \\(\\text{age}(\\mathcal{N}) = \\overline{K}\\).\nIn the even steps \\(n = 2\\ell\\), we ensure \\(K_\\ell \\subseteq \\mathcal{N}\\), so all structures isomorphic to \\(K_\\ell\\) also enter \\(\\text{age}(\\mathcal{N})\\). Since the \\((K_e)_{e \\in \\mathbb{N}}\\) enumerates all isomorphism types of \\(\\overline{K}\\), we get \\(\\text{age}(\\mathcal{N}) = \\overline{K}\\).\nClaim 2: \\(\\mathcal{N}\\) is homogeneous.\nLet \\(\\tau: A \\to \\mathcal{B}\\) be an isomorphism between finitely generated substructures \\(\\mathcal{A} = \\langle \\bar{a} \\rangle^{\\mathcal{N}}\\) and \\(\\mathcal{B} = \\langle \\bar{b} \\rangle^{\\mathcal{N}}\\) where \\(\\bar{a}, \\bar{b} \\in N\\) are finite. We show that for any \\(c_0 \\in N \\setminus B\\), there exists a partial isomorphism \\(\\tau': \\mathcal{A}' \\to \\mathcal{B}'\\) where \\(\\mathcal{A}', \\mathcal{B}'\\) are finitely generated, \\(\\tau' \\supseteq \\tau\\), and \\(c_0 \\in \\operatorname{dom}(\\tau')\\). (This suffices since we can continue via back-and-forth.)\nThere exists \\(\\ell\\) such that \\(f_\\ell\\) induces an embedding \\(f: A \\to \\langle \\mathcal{B} \\cup \\{c_0\\} \\rangle^{\\mathcal{N}}\\) (since every triple occurs infinitely often in the enumeration, in particular the triple \\((\\bar{a}, \\bar{b} \\cup \\{c_0\\}, f)\\)).\nIn step \\(n = 2\\ell + 1\\), \\(\\mathcal{B}_\\ell =  \\in \\langle \\mathcal{B} \\cup \\{c_0\\} \\rangle^{\\mathcal{N}}\\) and \\(\\mathcal{C}_n\\) are amalgamated over \\(A_\\ell\\). This yields embeddings: \\[\n\\begin{aligned}\n\\operatorname{id}: & \\;  \\mathcal{A} \\hookrightarrow \\mathcal{C}_{n+1} \\\\\ng: & \\; \\mathcal{B} \\hookrightarrow \\mathcal{C}_{n+1}  \\text{ where } g \\circ f_\\ell = \\operatorname{id}_A \\\\\n\\end{aligned}\n\\] Let \\(a_0 = g(c_0)\\). Then \\((g|_{\\mathcal{B}})^{-1}: \\langle \\bar{a} \\cup \\{a_0\\} \\rangle^{\\mathcal{N}} \\overset{\\sim}{\\to} \\langle \\bar{b} \\cup \\{c_0\\} \\rangle^{\\mathcal{N}}\\) is the desired isomorphism.",
    "crumbs": [
      "10/15 - Fraïssé limits"
    ]
  },
  {
    "objectID": "019_Oct15_fraisse_limits.html#fraïssés-theorem",
    "href": "019_Oct15_fraisse_limits.html#fraïssés-theorem",
    "title": "MATH 557 Oct 15",
    "section": "",
    "text": "Theorem 1 Let \\(\\overline{K}\\) be a class of finitely generated \\(\\mathcal{L}\\)-structures such that there are only countably many isomorphism types in \\(\\overline{K}\\).\nThen: \\(\\overline{K}\\) is an amalgamation class \\(\\Leftrightarrow\\) \\(\\overline{K}\\) is the age of a countable homogeneous \\(\\mathcal{L}\\)-structure.\n\n\n\n\n\nProof. (\\(\\Leftarrow\\)): Suppose \\(\\overline{K} = \\text{age}(\\mathcal{M})\\) where \\(\\mathcal{M}\\) is countable and homogeneous.\n(HP): Holds by definition of age.\n(JEP): Let \\(\\mathcal{A}, \\mathcal{B} \\in \\text{age}(\\mathcal{M})\\). Then \\(A \\cong \\langle A \\rangle^{\\mathcal{M}}\\) and \\(\\mathcal{B} \\cong \\langle B \\rangle^{\\mathcal{M}}\\), with \\(A,B \\subseteq M\\) finite. Then \\(\\mathcal{A}\\) and \\(\\mathcal{B}\\) embed into \\(\\langle A \\cup B \\rangle^{\\mathcal{M}}\\).\n(AP): Suppose \\(f_0: \\mathcal{A} \\to \\mathcal{B}\\) and \\(f_1: \\mathcal{A} \\to \\mathcal{C}\\) are embeddings, where \\(\\mathcal{A}, \\mathcal{B}, \\mathcal{C} \\in \\text{age}(\\mathcal{M})\\).\n\nWithout loss of generality, \\(\\mathcal{A}, \\mathcal{B}, \\mathcal{C} \\subseteq \\mathcal{M}\\) and \\(f_0 = \\text{id}_A\\).\nSince \\(\\mathcal{M}\\) is homogeneous, there exists an automorphism \\(\\pi: \\mathcal{M} \\overset{\\sim}{\\to} \\mathcal{M}\\) such that \\(\\pi^{-1}|_A = f_1\\) (i.e., \\(\\pi\\) extends \\(f_1^{-1}\\)).\nConsider \\(\\mathcal{D} = \\langle B \\cup \\pi^{-1}(C) \\rangle^{\\mathcal{M}}\\). \\(\\mathcal{D}\\) amalgamates \\(\\mathcal{B}\\) and \\(\\mathcal{C}\\) via \\(\\text{id}_{\\mathcal{B}}: \\mathcal{B} \\to \\mathcal{D}\\) and \\(\\pi^{-1}|_C: \\mathcal{C} \\to \\mathcal{D}\\).\n\n(\\(\\Rightarrow\\)): Assume \\(\\overline{K}\\) is an amalgamation class. We construct a structure \\(\\mathcal{N}\\) with \\(\\text{age}(\\mathcal{N}) = \\overline{K}\\) where \\(\\mathcal{N}\\) is homogeneous and has domain \\(N \\subset \\mathbb{N}\\).\nSince \\(\\overline{K}\\) has countably many isomorphism types, we enumerate the elements of \\(\\overline{K}\\) (up to isomorphism) as \\((\\mathcal{K}_e: e \\in \\mathbb{N})\\) where \\(K_e \\subseteq \\mathbb{N}\\).\nConsider tuples \\((\\bar{a}, \\bar{b}, f)\\) where \\(\\bar{a}_i, \\bar{b}_i\\) are finite subsets of \\(\\mathbb{N}\\) and \\(f\\) is a partial function with \\(\\operatorname{dom}(f) = \\bar{a}\\) and \\(\\text{ran}(f) \\subseteq \\bar{b}\\). Enumerate all such triples as \\((\\bar{a}_e, \\bar{b}_e, f_e)\\) so that every \\((\\bar{a}, \\bar{b}, f)\\) occurs infinitely often.\n\\(\\mathcal{N}\\) will be the union of an increasing sequence \\((\\mathcal{C}_n)_{n \\in \\mathbb{N}}\\) where \\(\\mathcal{C}_n \\in \\overline{K}\\).\nInitialize: \\(\\mathcal{C}_0 = \\mathcal{K}_0\\)\nNow assume we have defined \\(\\mathcal{C}_n\\).\nCase \\(n = 2\\ell\\) (even): Apply (JEP) to \\(\\mathcal{C}_n, \\mathcal{K}_\\ell\\) to obtain \\(\\mathcal{C}_{n+1}\\).\nCase \\(n = 2\\ell + 1\\) (odd): If \\(\\bar{a}_\\ell\\) or \\(\\bar{b}_\\ell \\nsubseteq C_n\\), put \\(\\mathcal{C}_{n+1} = \\mathcal{C}_n\\). If \\(\\bar{a}_\\ell, \\bar{b}_\\ell \\subseteq C_n\\), let \\(\\mathcal{A}_\\ell = \\langle \\bar{a}_\\ell \\rangle^{\\mathcal{C}_n}\\) and \\(\\mathcal{B}_\\ell = \\langle \\bar{b}_\\ell \\rangle^{\\mathcal{C}_n} \\subseteq \\mathcal{C}_n\\). Apply (AP) to the embeddings \\(\\operatorname{id}: \\mathcal{A}_\\ell \\to \\mathcal{C}_n\\) and \\(f: \\mathcal{A}_\\ell \\to \\mathcal{B}_\\ell\\) (induced by \\(f_\\ell: \\bar{a}_\\ell \\to \\bar{b}_\\ell\\)). This yields a structure \\(\\mathcal{C}_{n+1} \\in \\overline{K}\\). Renaming if necessary, we can assume \\(\\mathcal{C}_n \\subseteq \\mathcal{C}_{n+1}\\).\nDefine \\(\\mathcal{N} = \\bigcup_{n \\in \\mathbb{N}} \\mathcal{C}_n\\).\nClaim 1: \\(\\text{age}(\\mathcal{N}) = \\overline{K}\\).\nIn the even steps \\(n = 2\\ell\\), we ensure \\(K_\\ell \\subseteq \\mathcal{N}\\), so all structures isomorphic to \\(K_\\ell\\) also enter \\(\\text{age}(\\mathcal{N})\\). Since the \\((K_e)_{e \\in \\mathbb{N}}\\) enumerates all isomorphism types of \\(\\overline{K}\\), we get \\(\\text{age}(\\mathcal{N}) = \\overline{K}\\).\nClaim 2: \\(\\mathcal{N}\\) is homogeneous.\nLet \\(\\tau: A \\to \\mathcal{B}\\) be an isomorphism between finitely generated substructures \\(\\mathcal{A} = \\langle \\bar{a} \\rangle^{\\mathcal{N}}\\) and \\(\\mathcal{B} = \\langle \\bar{b} \\rangle^{\\mathcal{N}}\\) where \\(\\bar{a}, \\bar{b} \\in N\\) are finite. We show that for any \\(c_0 \\in N \\setminus B\\), there exists a partial isomorphism \\(\\tau': \\mathcal{A}' \\to \\mathcal{B}'\\) where \\(\\mathcal{A}', \\mathcal{B}'\\) are finitely generated, \\(\\tau' \\supseteq \\tau\\), and \\(c_0 \\in \\operatorname{dom}(\\tau')\\). (This suffices since we can continue via back-and-forth.)\nThere exists \\(\\ell\\) such that \\(f_\\ell\\) induces an embedding \\(f: A \\to \\langle \\mathcal{B} \\cup \\{c_0\\} \\rangle^{\\mathcal{N}}\\) (since every triple occurs infinitely often in the enumeration, in particular the triple \\((\\bar{a}, \\bar{b} \\cup \\{c_0\\}, f)\\)).\nIn step \\(n = 2\\ell + 1\\), \\(\\mathcal{B}_\\ell =  \\in \\langle \\mathcal{B} \\cup \\{c_0\\} \\rangle^{\\mathcal{N}}\\) and \\(\\mathcal{C}_n\\) are amalgamated over \\(A_\\ell\\). This yields embeddings: \\[\n\\begin{aligned}\n\\operatorname{id}: & \\;  \\mathcal{A} \\hookrightarrow \\mathcal{C}_{n+1} \\\\\ng: & \\; \\mathcal{B} \\hookrightarrow \\mathcal{C}_{n+1}  \\text{ where } g \\circ f_\\ell = \\operatorname{id}_A \\\\\n\\end{aligned}\n\\] Let \\(a_0 = g(c_0)\\). Then \\((g|_{\\mathcal{B}})^{-1}: \\langle \\bar{a} \\cup \\{a_0\\} \\rangle^{\\mathcal{N}} \\overset{\\sim}{\\to} \\langle \\bar{b} \\cup \\{c_0\\} \\rangle^{\\mathcal{N}}\\) is the desired isomorphism.",
    "crumbs": [
      "10/15 - Fraïssé limits"
    ]
  },
  {
    "objectID": "030_Nov17_diagonal_lemma.html",
    "href": "030_Nov17_diagonal_lemma.html",
    "title": "Math 557 Nov 17",
    "section": "",
    "text": "The Diagonal Lemma\nIn the following, we consider the diagonal function \\(d\\), defined by\n\\[\nd(n)= \\begin{cases}\n  \\ulcorner \\forall y\\, (y = \\underline{n} \\to \\sigma(y)) \\urcorner    & \\text{if} \\; n = \\ulcorner \\sigma(v_0)  \\urcorner \\; \\text{for an $L$-formula} \\; \\sigma(v_0)\\\\\n    0  & \\text{otherwise}.\n    \\end{cases}\n\\]\n\n\n\n\n\n\n\nLemma 1 \nLet \\(T\\) be an \\(L\\)-theory, \\(\\theta(v_0)\\) an \\(L\\)-formula with the single free variable \\(v_0\\). If the diagonal function \\(d\\) is representable in \\(T\\), then there exists an \\(L\\)-sentence \\(G\\) with the property\n\\[\nT \\vdash G \\leftrightarrow \\theta(\\underline{\\ulcorner G \\urcorner}).\n\\]\nIf \\(\\theta(v_0)\\) is a \\(\\Pi_1\\)-formula, then \\(G\\) can also be chosen as a \\(\\Pi_1\\)-sentence.\n\n\n\n\n\nProof. If \\(d\\) is represented in \\(T\\) by the formula \\(\\delta(x,y)\\), then define\n\\[\n\\psi(v_0):= \\forall y \\,(\\delta(v_0,y) \\to \\theta(y)),\n\\]\nand set \\(n:= \\ulcorner \\psi(v_0) \\urcorner\\).\nNote: \\(n\\) is actually a number in which the variable \\(v_0\\) does not occur; however, the Gödel number of \\(v_0\\) does enter into the calculation of \\(n\\).\nFor \\(G\\), we now choose the sentence\n\\[\nG:= \\forall y \\, (y = \\underline{n} \\to \\psi(y)).\n\\]\nThen \\(G\\) has Gödel number \\(d(\\ulcorner \\psi(v_0) \\urcorner)\\). If \\(\\delta(x,y)\\) is a \\(\\Sigma_1\\)-formula and \\(\\theta(v)\\) is a \\(\\Pi_1\\)-formula, then \\(\\psi\\) and \\(G\\) are (equivalent to) \\(\\Pi_1\\)-formulas. Thus it remains to show that \\(T \\vdash G \\leftrightarrow \\theta(\\underline{\\ulcorner G \\urcorner})\\):\nIt is clear that\n\\[\n\\begin{aligned}\n&T \\vdash G \\leftrightarrow  \\psi(\\underline{n}), && \\text{i.e., by the definition of } \\psi\\\\\n\\text{(1)} \\quad &T \\vdash G \\leftrightarrow  \\forall y (\\delta(\\underline{n},y) \\to \\theta(y)).\n\\end{aligned}\n\\]\nBut the fact that \\(d\\) is represented in \\(T\\) by \\(\\delta(x,y)\\) means\n\\[\nd(n)= \\ulcorner G \\urcorner \\Rightarrow T \\vdash \\delta(\\underline{n},\\underline{\\ulcorner G \\urcorner}) \\quad \\text{ and }  \\quad T  \\vdash \\exists! y \\; \\delta(\\underline{n},y).\n\\]\nThus in particular\n\\[\n\\begin{aligned}\n\\text{(2)} \\quad &T \\vdash \\forall y \\; ( \\delta(\\underline{n},y) \\leftrightarrow y = \\underline{\\ulcorner G \\urcorner}) && \\text{and together with (1) it follows}\\\\\n&T \\vdash G \\leftrightarrow \\forall y \\; ( y = \\underline{\\ulcorner G \\urcorner} \\to \\theta(y)), && \\text{hence}\\\\\n&T \\vdash G \\leftrightarrow \\theta(\\underline{\\ulcorner G \\urcorner}).\n\\end{aligned}\n\\]",
    "crumbs": [
      "11/17 - Diagonal Lemma"
    ]
  },
  {
    "objectID": "018_Oct13_homogeneous_structures.html",
    "href": "018_Oct13_homogeneous_structures.html",
    "title": "Math 557 Oct 13",
    "section": "",
    "text": "Recall: We have seen that DLO is \\(\\omega\\)-categorical, meaning up to isomorphism there is only one countable model. Since there are no finite models, by Vaught’s test, DLO is complete.\nQuestion: Are there other examples like this?\nLet \\(\\mathcal{L}\\) be a language and \\(\\mathcal{M}\\) be an \\(\\mathcal{L}\\)-structure.\n\n\n\n\n\n\n\nDefinition 1 \nFor \\(A \\subseteq M\\), we denote by \\(\\langle A \\rangle^{\\mathcal{M}}\\) the smallest substructure of \\(\\mathcal{M}\\) whose domain contains \\(A\\).\nWe say \\(\\mathcal{N} \\subseteq \\mathcal{M}\\) is finitely generated if \\(\\mathcal{N} = \\langle A \\rangle^{\\mathcal{M}}\\) for some finite \\(A \\subseteq M\\).\n\n\n\n\n\n\n\n\n\n\n\nDefinition 2 \nWe say \\(\\mathcal{M}\\) is homogeneous if any isomorphism between finitely generated substructures of \\(\\mathcal{M}\\) can be extended to an automorphism of \\(\\mathcal{M}\\).\n\n\n\n\n\n\nLet \\(\\mathcal{L} = \\{&lt;\\}\\) and \\(\\mathcal{M} = (\\mathbb{Q}, &lt;)\\). The finitely generated substructures coincide with the finite substructures.\n\n\n\nIn the back-and-forth proof of \\(\\omega\\)-categoricity of DLO, we used a homogeneity property, similarly for the proof that \\((\\mathbb{Q}, &lt;) \\cong (\\mathbb{R}, &lt;)\\).\n\n\n\n\n\n\n\nDefinition 3 \nThe age of \\(\\mathcal{M}\\), denoted \\(\\mathrm{age}(\\mathcal{M})\\), is the class of all finitely generated \\(\\mathcal{L}\\)-structures isomorphic to a substructure of \\(\\mathcal{M}\\).\n\n\n\n\n\n\n\\(\\mathrm{age}(\\mathbb{Q}, &lt;)\\) is the class of all finite linear orders.\n\n\n\n\n\n\n\n\nLemma 1 \nAny two countable homogeneous structures with the same age are isomorphic.\n\n\n\n\n\nProof (Sketch). Let \\(\\mathcal{A} \\subseteq \\mathcal{M}\\) and \\(\\mathcal{B} \\subseteq \\mathcal{N}\\) be finitely generated, and let \\(\\pi: \\mathcal{A} \\to \\mathcal{B}\\) be an isomorphism.\nLet \\(a \\in M \\setminus A\\). We need to show that \\(\\pi\\) can be extended to an isomorphism \\(\\mathcal{A} \\cup \\{a\\} \\to \\mathcal{B}'\\). This suffices, since we can then use the back-and-forth argument (remember our structures are countable) to extend everything to an automorphism of \\(\\mathcal{M}\\).\nSuppose \\(\\mathcal{A} = \\langle E \\rangle^{\\mathcal{M}}\\) and \\(\\mathcal{B} = \\langle F \\rangle^{\\mathcal{N}}\\). \nLet \\(\\mathcal{A}' = \\langle E \\cup \\{a\\} \\rangle^{\\mathcal{M}} \\subseteq \\mathcal{M}\\). Since \\(\\mathcal{M}\\) and \\(\\mathcal{N}\\) have the same age, there exists \\(\\mathcal{C} \\subseteq \\mathcal{N}\\) finitely generated such that \\(\\mathcal{A}' \\cong \\mathcal{C}\\) via some isomorphism \\(g\\).\nThe map \\(g\\) is uniquely determined by its values on \\(E \\cup \\{a\\}\\). The restriction \\(g|_E\\) induces an isomorphism \\(\\langle E \\rangle^{\\mathcal{M}} \\xrightarrow{\\cong} \\langle g(E) \\rangle^{\\mathcal{N}}\\).\nTherefore, \\(\\pi \\circ (g|_E)^{-1}\\) is an isomorphism \\(\\langle g(E) \\rangle^{\\mathcal{N}} \\xrightarrow{\\cong} \\mathcal{B}\\). Call this map \\(\\tau\\). Note that \\(\\langle g(E) \\rangle^{\\mathcal{N}}\\) is a finitely generated subset of \\(\\mathcal{N}\\). Since \\(\\mathcal{N}\\) is homogeneous, \\(\\tau\\) extends to an automorphism \\(\\overline{\\tau}: \\mathcal{N} \\to \\mathcal{N}\\). Let \\(\\mathcal{B}'\\) be the image of \\(\\mathcal{C}\\) under \\(\\overline{\\tau}\\). By definition of \\(\\overline{\\tau}\\), \\(\\mathcal{B} \\subset \\mathcal{B}'\\) and \\(\\mathcal{A}'\\) is isomorphic to \\(\\mathcal{B}'\\) via the map \\(\\overline{\\tau} \\circ g\\).\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat do ages of countable homogeneous structures look like?",
    "crumbs": [
      "10/13 - Homogeneous structures"
    ]
  },
  {
    "objectID": "018_Oct13_homogeneous_structures.html#the-age-of-a-structure",
    "href": "018_Oct13_homogeneous_structures.html#the-age-of-a-structure",
    "title": "Math 557 Oct 13",
    "section": "",
    "text": "In the back-and-forth proof of \\(\\omega\\)-categoricity of DLO, we used a homogeneity property, similarly for the proof that \\((\\mathbb{Q}, &lt;) \\cong (\\mathbb{R}, &lt;)\\).\n\n\n\n\n\n\n\nDefinition 3 \nThe age of \\(\\mathcal{M}\\), denoted \\(\\mathrm{age}(\\mathcal{M})\\), is the class of all finitely generated \\(\\mathcal{L}\\)-structures isomorphic to a substructure of \\(\\mathcal{M}\\).\n\n\n\n\n\n\n\\(\\mathrm{age}(\\mathbb{Q}, &lt;)\\) is the class of all finite linear orders.\n\n\n\n\n\n\n\n\nLemma 1 \nAny two countable homogeneous structures with the same age are isomorphic.\n\n\n\n\n\nProof (Sketch). Let \\(\\mathcal{A} \\subseteq \\mathcal{M}\\) and \\(\\mathcal{B} \\subseteq \\mathcal{N}\\) be finitely generated, and let \\(\\pi: \\mathcal{A} \\to \\mathcal{B}\\) be an isomorphism.\nLet \\(a \\in M \\setminus A\\). We need to show that \\(\\pi\\) can be extended to an isomorphism \\(\\mathcal{A} \\cup \\{a\\} \\to \\mathcal{B}'\\). This suffices, since we can then use the back-and-forth argument (remember our structures are countable) to extend everything to an automorphism of \\(\\mathcal{M}\\).\nSuppose \\(\\mathcal{A} = \\langle E \\rangle^{\\mathcal{M}}\\) and \\(\\mathcal{B} = \\langle F \\rangle^{\\mathcal{N}}\\). \nLet \\(\\mathcal{A}' = \\langle E \\cup \\{a\\} \\rangle^{\\mathcal{M}} \\subseteq \\mathcal{M}\\). Since \\(\\mathcal{M}\\) and \\(\\mathcal{N}\\) have the same age, there exists \\(\\mathcal{C} \\subseteq \\mathcal{N}\\) finitely generated such that \\(\\mathcal{A}' \\cong \\mathcal{C}\\) via some isomorphism \\(g\\).\nThe map \\(g\\) is uniquely determined by its values on \\(E \\cup \\{a\\}\\). The restriction \\(g|_E\\) induces an isomorphism \\(\\langle E \\rangle^{\\mathcal{M}} \\xrightarrow{\\cong} \\langle g(E) \\rangle^{\\mathcal{N}}\\).\nTherefore, \\(\\pi \\circ (g|_E)^{-1}\\) is an isomorphism \\(\\langle g(E) \\rangle^{\\mathcal{N}} \\xrightarrow{\\cong} \\mathcal{B}\\). Call this map \\(\\tau\\). Note that \\(\\langle g(E) \\rangle^{\\mathcal{N}}\\) is a finitely generated subset of \\(\\mathcal{N}\\). Since \\(\\mathcal{N}\\) is homogeneous, \\(\\tau\\) extends to an automorphism \\(\\overline{\\tau}: \\mathcal{N} \\to \\mathcal{N}\\). Let \\(\\mathcal{B}'\\) be the image of \\(\\mathcal{C}\\) under \\(\\overline{\\tau}\\). By definition of \\(\\overline{\\tau}\\), \\(\\mathcal{B} \\subset \\mathcal{B}'\\) and \\(\\mathcal{A}'\\) is isomorphic to \\(\\mathcal{B}'\\) via the map \\(\\overline{\\tau} \\circ g\\).\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat do ages of countable homogeneous structures look like?",
    "crumbs": [
      "10/13 - Homogeneous structures"
    ]
  },
  {
    "objectID": "004_Sep05_substitution.html",
    "href": "004_Sep05_substitution.html",
    "title": "Math 557 Sep 5",
    "section": "",
    "text": "Substitution:\n\nBasic idea: \\(\\varphi_{\\bar{s}/\\bar{x}}\\) is obtained by replacing all occurrences of the variable \\(x_i\\) by the term \\(s_i\\).\nUncontrolled substitution may cause issues with quantifiers. If we try to substitute a variable into the range of a quantifier, we rename the quantified variable to an unused variable (\\(\\exists x \\dots\\) becomes \\(\\exists u \\dots\\)).\n\nSubstitution Lemma:\n\nSubstitution behaves “as expected” with respect to evaluation and satisfaction.\nEvaluating a substituted term yields the same value as evaluating the original term under the “substituted” assignment (i.e. the assignment in which we replace the assignment to \\(x\\) by the value of \\(s\\) under \\(\\alpha\\)).\nA substituted formula holds in \\(\\mathcal{M}\\) under assignment \\(\\alpha\\) iff the original formula holds in \\(\\mathcal{M}\\) under the “substituted” assignment.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 (Carry-over from Sep 3) \nShow that if \\(x\\) is not free in \\(\\varphi\\), \\(\\mathcal{M} \\models \\varphi[\\alpha]\\) implies \\(\\mathcal{M} \\models \\forall x \\, \\varphi [\\alpha]\\).\nThen verify that\n\\[\\forall x ( \\varphi \\to \\psi) \\; \\to \\; (\\varphi \\to \\forall x \\psi) \\quad (\\text{$x$ not free in $\\varphi$})\\]\nis a validity.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2  \n\nShow that if \\(t\\) is a term, then \\(t_{\\bar{s}/\\bar{x}}\\) is a term.\nShow that if \\(\\varphi\\) is a formula, \\(\\varphi_{\\bar{s}/\\bar{x}}\\) is a formula of the same height.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nUse the Substitution Lemma to verify that \\[\\varphi_{t/x} \\: \\to \\: \\exists x \\, \\varphi\\] is a validity.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nShow that if \\(y\\) does not occur in \\(\\psi\\),\n\\[\n[\\psi_{y/x}]_{x/y} \\equiv \\psi\n\\]\nFind a counterexample that shows this no longer holds if \\(y\\) does occur in \\(\\psi\\).",
    "crumbs": [
      "9/5 - Substitution"
    ]
  },
  {
    "objectID": "004_Sep05_substitution.html#key-concepts",
    "href": "004_Sep05_substitution.html#key-concepts",
    "title": "Math 557 Sep 5",
    "section": "",
    "text": "Substitution:\n\nBasic idea: \\(\\varphi_{\\bar{s}/\\bar{x}}\\) is obtained by replacing all occurrences of the variable \\(x_i\\) by the term \\(s_i\\).\nUncontrolled substitution may cause issues with quantifiers. If we try to substitute a variable into the range of a quantifier, we rename the quantified variable to an unused variable (\\(\\exists x \\dots\\) becomes \\(\\exists u \\dots\\)).\n\nSubstitution Lemma:\n\nSubstitution behaves “as expected” with respect to evaluation and satisfaction.\nEvaluating a substituted term yields the same value as evaluating the original term under the “substituted” assignment (i.e. the assignment in which we replace the assignment to \\(x\\) by the value of \\(s\\) under \\(\\alpha\\)).\nA substituted formula holds in \\(\\mathcal{M}\\) under assignment \\(\\alpha\\) iff the original formula holds in \\(\\mathcal{M}\\) under the “substituted” assignment.",
    "crumbs": [
      "9/5 - Substitution"
    ]
  },
  {
    "objectID": "004_Sep05_substitution.html#problems",
    "href": "004_Sep05_substitution.html#problems",
    "title": "Math 557 Sep 5",
    "section": "",
    "text": "Exercise 1 (Carry-over from Sep 3) \nShow that if \\(x\\) is not free in \\(\\varphi\\), \\(\\mathcal{M} \\models \\varphi[\\alpha]\\) implies \\(\\mathcal{M} \\models \\forall x \\, \\varphi [\\alpha]\\).\nThen verify that\n\\[\\forall x ( \\varphi \\to \\psi) \\; \\to \\; (\\varphi \\to \\forall x \\psi) \\quad (\\text{$x$ not free in $\\varphi$})\\]\nis a validity.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2  \n\nShow that if \\(t\\) is a term, then \\(t_{\\bar{s}/\\bar{x}}\\) is a term.\nShow that if \\(\\varphi\\) is a formula, \\(\\varphi_{\\bar{s}/\\bar{x}}\\) is a formula of the same height.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nUse the Substitution Lemma to verify that \\[\\varphi_{t/x} \\: \\to \\: \\exists x \\, \\varphi\\] is a validity.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nShow that if \\(y\\) does not occur in \\(\\psi\\),\n\\[\n[\\psi_{y/x}]_{x/y} \\equiv \\psi\n\\]\nFind a counterexample that shows this no longer holds if \\(y\\) does occur in \\(\\psi\\).",
    "crumbs": [
      "9/5 - Substitution"
    ]
  },
  {
    "objectID": "010_Sep22_model_existence.html",
    "href": "010_Sep22_model_existence.html",
    "title": "Math 557 Sep 22",
    "section": "",
    "text": "Extend \\(T\\) to a Henkin theory \\(T_H\\), then complete it to a theory \\(T'\\).\n\\(T'\\) is a complete Henkin theory for the extended language \\(\\mathcal{L}_H\\).\nFor \\(T'\\), its term model \\(\\mathcal{A}_{T'}\\) satisfies \\[\n\\mathcal{A}_{T'} \\models \\sigma \\; \\iff \\; T' \\vdash_{\\mathcal{L}_H} \\sigma\n\\] for all \\(\\mathcal{L}_H\\)-sentences \\(\\sigma\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 \nHow do we obtain a model for \\(T\\) from a model for \\(T'\\)?\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nWhy is \\(\\mathcal{A}_{T'}\\) countable if \\(\\mathcal{L}\\) is countable?\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nLet \\(X\\) be the set of all maximally consistent \\(\\mathcal{L}\\)-theories. Recall that the sets \\[\\langle \\sigma \\rangle = \\{ T \\in X \\colon \\sigma \\in T\\} \\quad (\\sigma \\text{ $\\mathcal{L}$-sentence})\\] generate a Hausdorff topology on \\(X\\).\nShow that the topology is compact.",
    "crumbs": [
      "9/22 - Model existence theorem"
    ]
  },
  {
    "objectID": "010_Sep22_model_existence.html#key-concepts",
    "href": "010_Sep22_model_existence.html#key-concepts",
    "title": "Math 557 Sep 22",
    "section": "",
    "text": "Extend \\(T\\) to a Henkin theory \\(T_H\\), then complete it to a theory \\(T'\\).\n\\(T'\\) is a complete Henkin theory for the extended language \\(\\mathcal{L}_H\\).\nFor \\(T'\\), its term model \\(\\mathcal{A}_{T'}\\) satisfies \\[\n\\mathcal{A}_{T'} \\models \\sigma \\; \\iff \\; T' \\vdash_{\\mathcal{L}_H} \\sigma\n\\] for all \\(\\mathcal{L}_H\\)-sentences \\(\\sigma\\).",
    "crumbs": [
      "9/22 - Model existence theorem"
    ]
  },
  {
    "objectID": "010_Sep22_model_existence.html#problems",
    "href": "010_Sep22_model_existence.html#problems",
    "title": "Math 557 Sep 22",
    "section": "",
    "text": "Exercise 1 \nHow do we obtain a model for \\(T\\) from a model for \\(T'\\)?\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nWhy is \\(\\mathcal{A}_{T'}\\) countable if \\(\\mathcal{L}\\) is countable?\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nLet \\(X\\) be the set of all maximally consistent \\(\\mathcal{L}\\)-theories. Recall that the sets \\[\\langle \\sigma \\rangle = \\{ T \\in X \\colon \\sigma \\in T\\} \\quad (\\sigma \\text{ $\\mathcal{L}$-sentence})\\] generate a Hausdorff topology on \\(X\\).\nShow that the topology is compact.",
    "crumbs": [
      "9/22 - Model existence theorem"
    ]
  },
  {
    "objectID": "032_Nov21_second_incompleteness.html",
    "href": "032_Nov21_second_incompleteness.html",
    "title": "Math 557 Nov 21",
    "section": "",
    "text": "As we saw previously, for a recursivley axiomatizable theory \\(T\\), the relation\n\\[\n\\operatorname{Prf}(x,y) :\\ \\iff x = \\ulcorner \\psi \\urcorner, y = \\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle, \\varphi_1, \\dots, \\varphi_n \\text{ is a $T$-proof of } \\psi\n\\]\nis recursive. It follows that for such \\(T\\), the relation\n\\[\n\\begin{aligned}\n\\operatorname{prov}_T(v) & : \\Leftrightarrow \\text{\"v is the Gödel number of a formula $\\varphi$ and $\\varphi$ is provable in $T$\"} \\\\\n& \\;\\; \\Leftrightarrow \\exists y \\; \\operatorname{Prf}(x,y)\n\\end{aligned}\n\\]\nis r.e. and thus definable by a \\(\\Sigma_1\\)-formula \\(\\theta(v)\\).\nIn \\(\\mathsf{PA}\\)1 one can verify the following derivability conditions:\n\\[\n\\begin{aligned}\n(D1)& \\quad  T  \\vdash \\sigma \\;  \\Rightarrow \\;  T \\vdash \\theta(\\ulcorner \\sigma \\urcorner) \\\\\n(D2)& \\quad T  \\vdash \\; \\theta(\\ulcorner \\sigma \\to \\tau \\urcorner)  \\to (\\theta( \\ulcorner \\sigma \\urcorner) \\to \\theta( \\ulcorner \\tau \\urcorner))\\\\\n(D3) & \\quad T \\vdash \\; \\theta(\\ulcorner \\sigma \\urcorner)  \\to \\theta(\\ulcorner \\theta(\\ulcorner \\sigma \\urcorner) \\urcorner)\n\\end{aligned}\n\\]\nHere \\(\\sigma, \\tau\\) are arbitrary sentences of the language \\(\\mathcal{L}_A\\), and the Gödel numbers \\(n\\) should be replaced in these formulas by the corresponding terms \\(\\underline{n}\\).\nUsing such a proof predicate, one can also formalize the consistency of a theory, for example: \\[\n\\mathrm{Con}_T \\quad : \\Leftrightarrow \\quad \\neg \\theta( \\ulcorner 0=1 \\urcorner).\n\\]\n\n\n\n\n\n\n\nTheorem 1 (Second Gödel Incompleteness Theorem) \nLet \\(T\\) be a theory in the language \\(L\\) for which there exists a formal proof predicate \\(\\theta\\) as defined above (e.g., \\(T = \\mathsf{PA}\\)). Then:\n\\[\nT \\text{ consistent} \\quad \\Longrightarrow \\quad T \\nvdash \\mathrm{Con}_T.\n\\]\n\n\n\n\n\nProof (Sketch). By the Diagonalization Lemma, there exists a sentence \\(\\tau\\) such that\n\\[\nT \\vdash \\tau \\; \\leftrightarrow \\; \\neg \\theta(\\underline{\\ulcorner \\tau \\urcorner})\n\\tag{1}\\]\nIf \\(T \\vdash \\tau\\), it follows from \\((D1)\\) that \\[\nT \\vdash \\theta(\\underline{\\ulcorner \\tau \\urcorner})\n\\]\nBy (1), this implies \\(T \\vdash \\neg \\tau\\), hence \\(T\\) is inconsistent. This yields\n\\[\nT \\text{ consistent } \\; \\; \\Rightarrow \\; \\;  T \\nvdash \\tau.\n\\tag{2}\\]\nOne can show that this proof can be formalized and represented in \\(T\\) using the proof predicate \\(\\theta\\), thus\n\\[\nT  \\vdash \\mathrm{Con}_T  \\to \\neg \\theta(\\underline{\\ulcorner \\tau \\urcorner}).\n\\tag{3}\\]\nIf \\(T\\) is consistent, by (2), \\(T\\nvdash \\tau\\). Using (1), this implies \\(T \\nvdash \\neg \\theta(\\underline{\\ulcorner \\tau \\urcorner})\\). Thus, by (3), \\(T  \\nvdash \\mathrm{Con}_T\\).\n\n\n\n\nWhile the usual syntactic concepts formed for a formal language \\(\\mathcal{L}\\) can be defined in the language of number theory and their essential properties can be proven in \\(\\mathsf{PA}\\), this is not possible for the semantic notion of truth:\n\n\n\n\n\n\n\nTheorem 2 (Tarski’s Undefinability Theorem) \nLet \\(\\mathcal{M} \\models \\mathsf{PA}^-\\). Then there is no \\(\\mathcal{L}_A\\)-formula \\(\\theta(v)\\) such that for all natural numbers \\(n\\)\n\\[\n\\mathcal{M} \\models \\theta(\\underline{n}) \\iff n = \\ulcorner \\sigma \\urcorner \\text{ for an sentence } \\sigma \\text{ with } \\mathcal{M} \\models \\sigma.\n\\]\n\n\n\n\n\nProof. If there were such a truth definition \\(\\theta\\), then by the Diagonal Lemma we could find a sentence \\(G\\) such that \\[\n\\mathsf{PA}^- \\vdash G  \\leftrightarrow \\neg \\theta(\\underline{\\ulcorner G \\urcorner}),\n\\] in particular,\n\\[\n\\mathcal{M} \\models G \\; \\iff \\;  \\mathcal{M} \\models \\neg \\theta(\\underline{ \\ulcorner G \\urcorner}).\n\\]\nOn the other hand, for the truth definition we would need: \\[\n\\mathcal{M} \\models G \\iff \\mathcal{M} \\models  \\theta(\\underline{ \\ulcorner G \\urcorner}),\n\\] which yields a contradiction.\n\n\n\n\n\n\n\n\n\n\n\nTheorem 3 \nIf \\(T\\) is a consistent theory in the language \\(\\mathcal{L}_A\\), then not both the diagonal function \\(d\\) and the set \\(\\ulcorner T^\\vdash \\urcorner\\) are representable in \\(T\\).\n\n\n\n\n\nProof. We assume that \\(d\\) is represented by a formula \\(\\delta(x,y)\\) and the set \\(\\ulcorner T \\urcorner\\) is represented by a formula \\(\\varphi_T(v_0)\\) in \\(T\\), and we choose \\(\\theta = \\neg \\varphi_T\\), so that from the Diagonal Lemma we obtain the existence of a formula \\(G\\) such that \\[\nT \\vdash G \\leftrightarrow \\neg \\varphi_T(\\underline{\\ulcorner G \\urcorner}).\n\\tag{4}\\]\nCase 1: \\(T \\vdash G\\), thus \\(\\ulcorner G \\urcorner \\in \\ulcorner T^\\vdash \\urcorner\\). Then by representability, \\(T \\vdash \\varphi_T(\\underline{\\ulcorner G \\urcorner})\\) and with (4) also \\(T  \\vdash \\neg G\\), i.e., \\(T\\) would be inconsistent.\nCase 2: \\(T \\not \\vdash G\\), thus \\(\\ulcorner G \\urcorner \\not \\in \\ulcorner T^\\vdash \\urcorner\\). Then again by representability, \\(T \\vdash \\neg \\varphi_T(\\underline{\\ulcorner G \\urcorner})\\), and with (4) \\(T  \\vdash G\\), contradiction!\n\n\n\n\n\n\n\n\nCorollary 1 (Church) \nIf \\(T\\) is a consistent theory in the language \\(\\mathcal{L}_A\\) which extends \\(\\mathsf{PA}^-\\), then \\(T\\) is undecidable.\n\n\n\n\n\nProof. If \\(T\\) extends \\(\\mathsf{PA}^-\\), every recursive function, including \\(d\\), is representable in \\(T\\). Hence, by Theorem 3, \\(\\ulcorner T^\\vdash \\urcorner\\) is not representable. It follows that \\(\\ulcorner T^\\vdash \\urcorner\\) is not recursive (since all recursive sets are representable in any consistent extension of \\(\\mathsf{PA}^-\\).\n\n\n\n\n\n\n\n\nCorollary 2 (Church) \nThe set\n\\[\n\\operatorname{VAL} := \\{\\ulcorner \\sigma \\urcorner : \\sigma \\;\\; \\mathcal{L}_A\\text{-sentence with } \\vdash \\sigma\\}\n\\] (i.e. the set of all sentences that are validities) is not recursive.\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 We say an \\(\\mathcal{L}_A\\)-theory \\(T'\\) is a finite extension of an \\(\\mathcal{L}_A\\)-theory \\(T\\) if \\(T' \\supseteq T\\) and \\(T' \\setminus T\\) is finite. Show that if \\(T\\) is decidable and \\(T'\\) is a finite extension of \\(T\\), then \\(T'\\) is decidable.\n\n\n\n\n\nProof (Corollary 2). Since \\(\\mathsf{PA}^-\\) is finite, it is a finite extension of the empty theory \\(T = \\emptyset\\). Since \\(\\operatorname{VAL} = \\emptyset^\\vdash\\), by Exercise 1, if \\(\\operatorname{VAL}\\) were recursive so would be \\((\\mathsf{PA}^-)^\\vdash\\), contradicting Corollary 1.",
    "crumbs": [
      "11/19 - Consistency and Decidability"
    ]
  },
  {
    "objectID": "032_Nov21_second_incompleteness.html#the-second-incompleteness-theorem",
    "href": "032_Nov21_second_incompleteness.html#the-second-incompleteness-theorem",
    "title": "Math 557 Nov 21",
    "section": "",
    "text": "As we saw previously, for a recursivley axiomatizable theory \\(T\\), the relation\n\\[\n\\operatorname{Prf}(x,y) :\\ \\iff x = \\ulcorner \\psi \\urcorner, y = \\langle \\ulcorner \\varphi_1 \\urcorner, \\dots, \\ulcorner \\varphi_n \\urcorner \\rangle, \\varphi_1, \\dots, \\varphi_n \\text{ is a $T$-proof of } \\psi\n\\]\nis recursive. It follows that for such \\(T\\), the relation\n\\[\n\\begin{aligned}\n\\operatorname{prov}_T(v) & : \\Leftrightarrow \\text{\"v is the Gödel number of a formula $\\varphi$ and $\\varphi$ is provable in $T$\"} \\\\\n& \\;\\; \\Leftrightarrow \\exists y \\; \\operatorname{Prf}(x,y)\n\\end{aligned}\n\\]\nis r.e. and thus definable by a \\(\\Sigma_1\\)-formula \\(\\theta(v)\\).\nIn \\(\\mathsf{PA}\\)1 one can verify the following derivability conditions:\n\\[\n\\begin{aligned}\n(D1)& \\quad  T  \\vdash \\sigma \\;  \\Rightarrow \\;  T \\vdash \\theta(\\ulcorner \\sigma \\urcorner) \\\\\n(D2)& \\quad T  \\vdash \\; \\theta(\\ulcorner \\sigma \\to \\tau \\urcorner)  \\to (\\theta( \\ulcorner \\sigma \\urcorner) \\to \\theta( \\ulcorner \\tau \\urcorner))\\\\\n(D3) & \\quad T \\vdash \\; \\theta(\\ulcorner \\sigma \\urcorner)  \\to \\theta(\\ulcorner \\theta(\\ulcorner \\sigma \\urcorner) \\urcorner)\n\\end{aligned}\n\\]\nHere \\(\\sigma, \\tau\\) are arbitrary sentences of the language \\(\\mathcal{L}_A\\), and the Gödel numbers \\(n\\) should be replaced in these formulas by the corresponding terms \\(\\underline{n}\\).\nUsing such a proof predicate, one can also formalize the consistency of a theory, for example: \\[\n\\mathrm{Con}_T \\quad : \\Leftrightarrow \\quad \\neg \\theta( \\ulcorner 0=1 \\urcorner).\n\\]\n\n\n\n\n\n\n\nTheorem 1 (Second Gödel Incompleteness Theorem) \nLet \\(T\\) be a theory in the language \\(L\\) for which there exists a formal proof predicate \\(\\theta\\) as defined above (e.g., \\(T = \\mathsf{PA}\\)). Then:\n\\[\nT \\text{ consistent} \\quad \\Longrightarrow \\quad T \\nvdash \\mathrm{Con}_T.\n\\]\n\n\n\n\n\nProof (Sketch). By the Diagonalization Lemma, there exists a sentence \\(\\tau\\) such that\n\\[\nT \\vdash \\tau \\; \\leftrightarrow \\; \\neg \\theta(\\underline{\\ulcorner \\tau \\urcorner})\n\\tag{1}\\]\nIf \\(T \\vdash \\tau\\), it follows from \\((D1)\\) that \\[\nT \\vdash \\theta(\\underline{\\ulcorner \\tau \\urcorner})\n\\]\nBy (1), this implies \\(T \\vdash \\neg \\tau\\), hence \\(T\\) is inconsistent. This yields\n\\[\nT \\text{ consistent } \\; \\; \\Rightarrow \\; \\;  T \\nvdash \\tau.\n\\tag{2}\\]\nOne can show that this proof can be formalized and represented in \\(T\\) using the proof predicate \\(\\theta\\), thus\n\\[\nT  \\vdash \\mathrm{Con}_T  \\to \\neg \\theta(\\underline{\\ulcorner \\tau \\urcorner}).\n\\tag{3}\\]\nIf \\(T\\) is consistent, by (2), \\(T\\nvdash \\tau\\). Using (1), this implies \\(T \\nvdash \\neg \\theta(\\underline{\\ulcorner \\tau \\urcorner})\\). Thus, by (3), \\(T  \\nvdash \\mathrm{Con}_T\\).",
    "crumbs": [
      "11/19 - Consistency and Decidability"
    ]
  },
  {
    "objectID": "032_Nov21_second_incompleteness.html#truth-is-not-definable",
    "href": "032_Nov21_second_incompleteness.html#truth-is-not-definable",
    "title": "Math 557 Nov 21",
    "section": "",
    "text": "While the usual syntactic concepts formed for a formal language \\(\\mathcal{L}\\) can be defined in the language of number theory and their essential properties can be proven in \\(\\mathsf{PA}\\), this is not possible for the semantic notion of truth:\n\n\n\n\n\n\n\nTheorem 2 (Tarski’s Undefinability Theorem) \nLet \\(\\mathcal{M} \\models \\mathsf{PA}^-\\). Then there is no \\(\\mathcal{L}_A\\)-formula \\(\\theta(v)\\) such that for all natural numbers \\(n\\)\n\\[\n\\mathcal{M} \\models \\theta(\\underline{n}) \\iff n = \\ulcorner \\sigma \\urcorner \\text{ for an sentence } \\sigma \\text{ with } \\mathcal{M} \\models \\sigma.\n\\]\n\n\n\n\n\nProof. If there were such a truth definition \\(\\theta\\), then by the Diagonal Lemma we could find a sentence \\(G\\) such that \\[\n\\mathsf{PA}^- \\vdash G  \\leftrightarrow \\neg \\theta(\\underline{\\ulcorner G \\urcorner}),\n\\] in particular,\n\\[\n\\mathcal{M} \\models G \\; \\iff \\;  \\mathcal{M} \\models \\neg \\theta(\\underline{ \\ulcorner G \\urcorner}).\n\\]\nOn the other hand, for the truth definition we would need: \\[\n\\mathcal{M} \\models G \\iff \\mathcal{M} \\models  \\theta(\\underline{ \\ulcorner G \\urcorner}),\n\\] which yields a contradiction.",
    "crumbs": [
      "11/19 - Consistency and Decidability"
    ]
  },
  {
    "objectID": "032_Nov21_second_incompleteness.html#undecidability",
    "href": "032_Nov21_second_incompleteness.html#undecidability",
    "title": "Math 557 Nov 21",
    "section": "",
    "text": "Theorem 3 \nIf \\(T\\) is a consistent theory in the language \\(\\mathcal{L}_A\\), then not both the diagonal function \\(d\\) and the set \\(\\ulcorner T^\\vdash \\urcorner\\) are representable in \\(T\\).\n\n\n\n\n\nProof. We assume that \\(d\\) is represented by a formula \\(\\delta(x,y)\\) and the set \\(\\ulcorner T \\urcorner\\) is represented by a formula \\(\\varphi_T(v_0)\\) in \\(T\\), and we choose \\(\\theta = \\neg \\varphi_T\\), so that from the Diagonal Lemma we obtain the existence of a formula \\(G\\) such that \\[\nT \\vdash G \\leftrightarrow \\neg \\varphi_T(\\underline{\\ulcorner G \\urcorner}).\n\\tag{4}\\]\nCase 1: \\(T \\vdash G\\), thus \\(\\ulcorner G \\urcorner \\in \\ulcorner T^\\vdash \\urcorner\\). Then by representability, \\(T \\vdash \\varphi_T(\\underline{\\ulcorner G \\urcorner})\\) and with (4) also \\(T  \\vdash \\neg G\\), i.e., \\(T\\) would be inconsistent.\nCase 2: \\(T \\not \\vdash G\\), thus \\(\\ulcorner G \\urcorner \\not \\in \\ulcorner T^\\vdash \\urcorner\\). Then again by representability, \\(T \\vdash \\neg \\varphi_T(\\underline{\\ulcorner G \\urcorner})\\), and with (4) \\(T  \\vdash G\\), contradiction!\n\n\n\n\n\n\n\n\nCorollary 1 (Church) \nIf \\(T\\) is a consistent theory in the language \\(\\mathcal{L}_A\\) which extends \\(\\mathsf{PA}^-\\), then \\(T\\) is undecidable.\n\n\n\n\n\nProof. If \\(T\\) extends \\(\\mathsf{PA}^-\\), every recursive function, including \\(d\\), is representable in \\(T\\). Hence, by Theorem 3, \\(\\ulcorner T^\\vdash \\urcorner\\) is not representable. It follows that \\(\\ulcorner T^\\vdash \\urcorner\\) is not recursive (since all recursive sets are representable in any consistent extension of \\(\\mathsf{PA}^-\\).\n\n\n\n\n\n\n\n\nCorollary 2 (Church) \nThe set\n\\[\n\\operatorname{VAL} := \\{\\ulcorner \\sigma \\urcorner : \\sigma \\;\\; \\mathcal{L}_A\\text{-sentence with } \\vdash \\sigma\\}\n\\] (i.e. the set of all sentences that are validities) is not recursive.\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 We say an \\(\\mathcal{L}_A\\)-theory \\(T'\\) is a finite extension of an \\(\\mathcal{L}_A\\)-theory \\(T\\) if \\(T' \\supseteq T\\) and \\(T' \\setminus T\\) is finite. Show that if \\(T\\) is decidable and \\(T'\\) is a finite extension of \\(T\\), then \\(T'\\) is decidable.\n\n\n\n\n\nProof (Corollary 2). Since \\(\\mathsf{PA}^-\\) is finite, it is a finite extension of the empty theory \\(T = \\emptyset\\). Since \\(\\operatorname{VAL} = \\emptyset^\\vdash\\), by Exercise 1, if \\(\\operatorname{VAL}\\) were recursive so would be \\((\\mathsf{PA}^-)^\\vdash\\), contradicting Corollary 1.",
    "crumbs": [
      "11/19 - Consistency and Decidability"
    ]
  },
  {
    "objectID": "032_Nov21_second_incompleteness.html#footnotes",
    "href": "032_Nov21_second_incompleteness.html#footnotes",
    "title": "Math 557 Nov 21",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n\\(\\mathsf{PA}^-\\) is not strong enough for this↩︎",
    "crumbs": [
      "11/19 - Consistency and Decidability"
    ]
  },
  {
    "objectID": "024_Oct31_arithmetical_formulas.html",
    "href": "024_Oct31_arithmetical_formulas.html",
    "title": "Math 557 Oct 31",
    "section": "",
    "text": "Problem 1In \\(\\mathsf{PA}\\), we can define \\(1 := S(0)\\).\nShow that \\[\n\\mathsf{PA} \\vdash \\forall x \\: (x \\cdot 1 = x)\n\\]\n\n\n\nProblem 2: Non-standard models of \\(\\mathsf{PA}^-\\)\nThe set \\(\\mathbb{Z}[X]\\) of polynomials in one variable \\(X\\) with integer coefficients is a commutative ring with the usual operations. One can order this ring by setting for a polynomial \\(p=a_n X^n+\\ldots a_1 X + a_0\\) with leading coefficient \\(a_n \\ne 0\\): \\[\n   a_n X^n+\\ldots a_1 X + a_0 &gt; 0 :\\iff a_n&gt;0\n   \\] and thus ordering polynomials \\(p,q \\in \\mathbb{Z}[X]\\) by \\(p&lt;q: \\iff q-p&gt;0\\).\n\nVerify that the subset \\(\\mathbb{Z}[X]^+\\) of polynomials \\(p\\in \\mathbb{Z}[X]\\) with \\(p\\ge 0\\) is a model of \\(\\mathsf{PA}^-\\).\nWhat does the natural number \\(n\\) correspond to in \\(\\mathbb{Z}[X]^+\\)? In other words, what is the interpretation of the constant term \\(\\underline{n}\\)?\nIdentify an element of \\(\\mathbb{Z}[X]^+\\) that is larger than any “natural number” and thus “infinitely large”.\nIs \\(\\mathbb{Z}[X]^+\\) a model of \\(\\mathsf{PA}\\)?\n\n\n\n\nProblem 3: OverspillLet \\(\\mathcal{M} \\models \\mathsf{PA}\\) be non-standard. A proper cut in \\(\\mathcal{M}\\) is a set \\(I \\subsetneq M\\) that is an initial segment of \\(M\\) and closed under successor, e.g. the standard model \\(\\mathbb{N}\\).\nShow that if \\(\\vec{a} \\in M\\) and \\(\\mathcal{M} \\models \\varphi(b,\\vec{a})\\) for all \\(b \\in I\\), then there is \\(c &gt; I\\) in \\(M\\) such that \\(\\mathcal{M} \\models \\forall x \\leq c \\varphi(x,\\vec{a})\\).\n\n\n\nTake-Home 1Show that if \\(\\mathcal{M} \\models \\mathsf{PA}^{-}\\), is non-standard, and satisfies the conclusion of the previous problem, then \\(\\mathcal{M} \\models \\mathsf{PA}\\).",
    "crumbs": [
      "10/31 - Arithmetical formulas"
    ]
  },
  {
    "objectID": "024_Oct31_arithmetical_formulas.html#problems-on-mathsfpa-and-mathsfpa-",
    "href": "024_Oct31_arithmetical_formulas.html#problems-on-mathsfpa-and-mathsfpa-",
    "title": "Math 557 Oct 31",
    "section": "",
    "text": "Problem 1In \\(\\mathsf{PA}\\), we can define \\(1 := S(0)\\).\nShow that \\[\n\\mathsf{PA} \\vdash \\forall x \\: (x \\cdot 1 = x)\n\\]\n\n\n\nProblem 2: Non-standard models of \\(\\mathsf{PA}^-\\)\nThe set \\(\\mathbb{Z}[X]\\) of polynomials in one variable \\(X\\) with integer coefficients is a commutative ring with the usual operations. One can order this ring by setting for a polynomial \\(p=a_n X^n+\\ldots a_1 X + a_0\\) with leading coefficient \\(a_n \\ne 0\\): \\[\n   a_n X^n+\\ldots a_1 X + a_0 &gt; 0 :\\iff a_n&gt;0\n   \\] and thus ordering polynomials \\(p,q \\in \\mathbb{Z}[X]\\) by \\(p&lt;q: \\iff q-p&gt;0\\).\n\nVerify that the subset \\(\\mathbb{Z}[X]^+\\) of polynomials \\(p\\in \\mathbb{Z}[X]\\) with \\(p\\ge 0\\) is a model of \\(\\mathsf{PA}^-\\).\nWhat does the natural number \\(n\\) correspond to in \\(\\mathbb{Z}[X]^+\\)? In other words, what is the interpretation of the constant term \\(\\underline{n}\\)?\nIdentify an element of \\(\\mathbb{Z}[X]^+\\) that is larger than any “natural number” and thus “infinitely large”.\nIs \\(\\mathbb{Z}[X]^+\\) a model of \\(\\mathsf{PA}\\)?\n\n\n\n\nProblem 3: OverspillLet \\(\\mathcal{M} \\models \\mathsf{PA}\\) be non-standard. A proper cut in \\(\\mathcal{M}\\) is a set \\(I \\subsetneq M\\) that is an initial segment of \\(M\\) and closed under successor, e.g. the standard model \\(\\mathbb{N}\\).\nShow that if \\(\\vec{a} \\in M\\) and \\(\\mathcal{M} \\models \\varphi(b,\\vec{a})\\) for all \\(b \\in I\\), then there is \\(c &gt; I\\) in \\(M\\) such that \\(\\mathcal{M} \\models \\forall x \\leq c \\varphi(x,\\vec{a})\\).\n\n\n\nTake-Home 1Show that if \\(\\mathcal{M} \\models \\mathsf{PA}^{-}\\), is non-standard, and satisfies the conclusion of the previous problem, then \\(\\mathcal{M} \\models \\mathsf{PA}\\).",
    "crumbs": [
      "10/31 - Arithmetical formulas"
    ]
  },
  {
    "objectID": "024_Oct31_arithmetical_formulas.html#arithmetical-formulas",
    "href": "024_Oct31_arithmetical_formulas.html#arithmetical-formulas",
    "title": "Math 557 Oct 31",
    "section": "Arithmetical Formulas",
    "text": "Arithmetical Formulas\n\nBounded Quantifiers\nFor terms \\(t\\) and formulas \\(\\varphi\\) in the language of \\(\\mathsf{PA}^-\\), we write \\[\n\\begin{aligned}\n\\exists x &lt; t \\;  \\varphi & \\text{ for } & \\exists x (x &lt; t \\wedge \\varphi)\\\\\n\\forall x &lt; t \\;  \\varphi & \\text{ for } & \\forall x (x &lt; t \\to \\varphi)\n\\end{aligned}\n\\] and call \\(\\exists x &lt; t\\) and \\(\\forall x &lt; t\\) bounded quantifiers.\n\n\nArithmetical Hierarchy\n\nDefinition 1\n\n\\(\\varphi\\) is a \\(\\Delta_0\\)-formula: \\(\\iff\\) \\(\\varphi\\) contains at most bounded quantifiers,\n\\(\\varphi\\) is a \\(\\Sigma_1\\)-formula: \\(\\iff\\) \\(\\varphi = \\exists \\vec{x} \\; \\psi\\) for a \\(\\Delta_0\\)-formula \\(\\psi\\),\n\\(\\varphi\\) is a \\(\\Pi_1\\)-formula: \\(\\iff\\) \\(\\varphi = \\forall \\vec{x}  \\;\\psi\\) for a \\(\\Delta_0\\)-formula \\(\\psi\\).\n\n\n\nThis is the beginning of the arithmetical hierarchy. Setting \\[\n\\Sigma_0 = \\Pi_0 = \\Delta_0,\n\\] we can continue:\n\n\\(\\varphi\\) is a \\(\\Sigma_{n+1}\\)-formula \\(\\iff\\) \\(\\varphi = \\exists \\vec{x} \\; \\psi\\) for a \\(\\Pi_n\\)-formula \\(\\psi\\),\n\\(\\varphi\\) is a \\(\\Pi_{n+1}\\)-formula \\(\\iff\\) \\(\\varphi = \\forall \\vec{x} \\; \\psi\\) for a \\(\\Sigma_n\\)-formula \\(\\psi\\).\n\nThus, a \\(\\Sigma_3\\)-formula has the form \\(\\exists \\vec{x} \\; \\forall \\vec{y}\\; \\exists \\vec{z} \\; \\psi\\), where \\(\\psi\\) contains at most bounded quantifiers. This means that bounded quantifiers are not counted; \\(\\Sigma\\) or \\(\\Pi\\) indicates whether the formula begins with a (finite) sequence of \\(\\exists\\)-quantifiers or \\(\\forall\\)-quantifiers respectively, and the index counts the quantifier blocks. So it depends less on the number of quantifiers than on the number of quantifier alternations.\nIn this classification, we do not distinguish between logically equivalent formulas, so that every \\(\\Pi_n\\)-formula for \\(n&lt;m\\) is also a \\(\\Sigma_m\\)- and \\(\\Pi_m\\)-formula (by simply prefixing the formula with additional quantifiers over variables that do not occur). Thus we can also define the formula classes \\[\n\\Delta_n = \\Sigma_n \\cap \\Pi_n.\n\\]\nThis gives us the following picture of the arithmetical hierarchy:\n\n\n\nArithmetical Hierarchy\n\n\nMany fundamental properties of natural numbers can be expressed using \\(\\Delta_0\\)-formulas, e.g.: \\[\nx \\text{ is irreducible} \\iff 1 &lt; x \\wedge \\forall u&lt;x \\; \\forall v&lt;x \\; \\neg (u \\cdot v = x).\n\\]\n\n\nComputability of arithmetical predicates\nWe will show that the recursive relations coincide with the sets that can be defined by \\(\\Delta_1\\)-formulas, and that the graph of a recursive function can be defined by a \\(\\Sigma_1\\)-formula. We start by showing that \\(\\Delta_0\\)-definable functions are primitive recursive.\n\nLemma 2For every \\(\\Delta_0\\)-formula \\(\\theta(\\vec{v})\\), the relation \\[\nR(\\vec{a}) :\\iff \\mathbb{N} \\models \\theta(\\vec{a})\n\\] is primitive recursive.\n\n\n\nProof. We show by induction on the height of \\(\\theta\\) that the associated characteristic function \\[\nc_{\\theta}(\\vec{x}) =\n\\begin{cases}\n    1  &  \\text{if } \\mathbb{N} \\models \\theta(\\vec{x})\\\\\n    0   &   \\text{otherwise}\n\\end{cases}\n\\] is primitive recursive.\nFirst, the functions \\(x+1, x+y, x \\cdot y\\) are p.r., and thus every term in \\(\\mathbb{N}\\) defines a primitive recursive function. Since the functions \\(\\text{eq}(x,y)=\\overline{\\text{sg}}(|x-y|)\\) and \\(\\text{sg}(y \\stackrel{.}{-} x)\\) are primitive recursive and the primitive recursive functions are closed under composition, the claim holds for the atomic formulas \\(t=s, t &lt; s\\).\nFor the case of propositional operations, use \\[\n\\begin{aligned}\nc_{\\neg \\theta}(\\vec{x}) & = 1 \\stackrel{.}{-} c_{\\theta}(\\vec{x}) \\\\\nc_{\\theta \\wedge \\psi}(\\vec{x}) & = c_{\\theta}(\\vec{x}) \\cdot c_{\\psi}(\\vec{x}) \\\\\nc_{\\theta \\vee \\psi}(\\vec{x}) & = \\min(c_{\\theta}(\\vec{x}),c_{\\psi}(\\vec{x}))\n\\end{aligned}\n\\]\nFinally, if \\(\\psi\\) is a \\(\\Delta_0\\)-formula, \\(t\\) is a term and \\(\\theta(\\vec{x}) = \\forall y &lt; t(\\vec{x}) \\; \\psi(\\vec{x},y)\\), then the claim follows from \\[\nc_{\\theta}(\\vec{x}) = \\text{eq}( t(\\vec{x}) , (\\mu y &lt; t(\\vec{x}) (c_{\\psi}(\\vec{x},y) = 0)).\n\\] One argues similarly in the case of the formula \\(\\exists y &lt; t(\\vec{x}) \\; \\psi(\\vec{x},y)\\) (or reduces this case to the earlier one using negation).\n\nRemark: The converse of the above lemma does not hold: there are primitive recursive sets that cannot be defined by any \\(\\Delta_0\\)-formula in the natural numbers.\n\n\n\n\n\n\n\nExercise 1 \nShow that the following relations and functions are primitive recursive.\n\\[\n\\begin{aligned}\n& x  \\text{ divides }  y \\\\\n& \\operatorname{rem}(x,y) \\text{ (remainder when $y$ is divided by $x$)} \\\\\n& x  \\text{ is prime}\\\\\n& n \\mapsto p_n, \\text{ where $p_n$ is the $n$th prime}\\\\\n\\end{aligned}\n\\]\n\n\n\n\n\n\nCoding Sequences\nThe fact that basic number-theoretic functions are primitive recursive allows for primitive recursive encodings of finite sequences of natural numbers by numbers, e.g. \\[\n(n_0, n_1, \\ldots, n_k) \\quad \\text{by} \\quad p_0^{n_0+1} \\cdot p_1^{n_1+1}\\cdot  \\ldots \\cdot p_k^{n_k+1}.\n\\]\nIf we define for \\(x,y \\in \\mathbb{N}\\) \\[\n\\langle x,y \\rangle := \\frac{(x+y)(x+y+1)}{2} + y,\n\\] we obtain a primitive recursive bijection (pairing function) \\(\\mathbb{N}^2 \\leftrightarrow  \\mathbb{N}\\). We denote the inverse projections by \\((z)_i\\), \\(i = 0,1\\), that is, \\[\n\\langle (z)_0, (z)_1 \\rangle = z.\n\\]\nWe can extended this to tuples of arbitrary (but fixed) length by iterating: \\[\n\\langle x_1, x_2, \\ldots x_k  \\rangle = \\langle x_1, \\langle x_2, \\ldots x_k \\rangle \\rangle\n\\]\nUsing these primitive recursive bijections, we can generally assume functions to be defined on (subsets of) \\(\\mathbb{N}\\). We can also use it to “compress” quantifiers: For example, \\(\\exists x \\exists y \\psi(x,y)\\) can be replaced by \\(\\exists z \\psi\\left((z)_0, (z)_1\\right)\\) without affecting the arithmetical complexity.",
    "crumbs": [
      "10/31 - Arithmetical formulas"
    ]
  },
  {
    "objectID": "024_Oct31_arithmetical_formulas.html#take-home-problems",
    "href": "024_Oct31_arithmetical_formulas.html#take-home-problems",
    "title": "Math 557 Oct 31",
    "section": "Take-Home Problems",
    "text": "Take-Home Problems\n\nTake-Home 2Show that the Euler totient function \\[  \n        \\phi (x) = \\text{ \\# of $m \\leq x$ relatively prime to $x$}\n\\] is primitive recursive.\n\n\n\nTake-Home 3Show that the set of generalized Mersenne primes, \\[\n    \\left \\{ N \\text{ prime } \\colon N = \\dfrac{p^n -1}{p-1} \\text{ for some prime $p$ and $n \\geq 2$} \\right \\}\n\\] is primitive recursive.",
    "crumbs": [
      "10/31 - Arithmetical formulas"
    ]
  },
  {
    "objectID": "008_Sep17_completing_theories.html",
    "href": "008_Sep17_completing_theories.html",
    "title": "Math 557 Sep 17",
    "section": "",
    "text": "We previously defined the term model \\(\\mathcal{A}\\). It holds that for any atomic sentence \\(\\sigma\\), \\[\\mathcal{A} \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]\nTrying to extend this to arbitrary sentence via induction, the negation case looks like \\[\\mathcal{A} \\models \\neg\\sigma \\; \\iff \\;  \\mathcal{A} \\nvDash \\sigma \\; \\overset{\\text{ind hyp}}{\\iff} \\; T \\nvdash \\sigma\\] We would like to show that this is equivalent to \\(T \\vdash \\neg\\sigma\\).\nOne direction follows from \\(T\\) being consistent, but for the other direction, \\(T\\) may not be strong enough to prove this.\nWe therefore need to extend \\(T\\) to a complete theory.\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 \nVerify that indeed for all atomic sentences \\(\\sigma\\), \\[\\mathcal{A} \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nRecall that a theory \\(T\\) is maximally consistent if it is consistent but does not have any consistent proper extensions. \\(T\\) is called deductively closed if the deductive closure of \\(T\\), \\[T^{\\vdash} = \\{ \\sigma : T \\vdash \\sigma \\}\\] is equal to \\(T\\).\n\nShow that a maximally consistent theory is complete and deductively closed.\nShow that if \\(T\\) is complete, then \\(T^{\\vdash}\\) is maximally consistent.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nIs every consistent, deductively closed theory complete?\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nShow that the union of an increasing sequence of consistent theories is consistent.\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nExtend Lindebaum’s theorem on the existence of maximally consistent extension from countable to arbitrary languages.\n\n\n\n\n\n\n\n\n\n\n\nExercise 6 \nFix a language \\(\\mathcal{L}\\). Let \\(X\\) be the set of all maximally consistent \\(\\mathcal{L}\\)-theories. For an \\(\\mathcal{L}\\)-sentence \\(\\sigma\\), let \\[\\langle \\sigma \\rangle = \\{ T \\in X \\colon \\sigma \\in T\\}\\]\nShow that\n\n\\(\\langle \\sigma \\land \\tau \\rangle = \\langle \\sigma \\rangle \\cap \\langle \\tau \\rangle\\)\n\\(\\langle \\neg\\sigma \\rangle = X \\setminus \\langle \\sigma \\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 7 \nContinuing the previous exercise, let \\(\\mathcal{O}\\) be the topology generated by the sets \\(\\langle \\sigma \\rangle\\). Show that\n\neach \\(\\langle \\sigma \\rangle\\) is clopen,\nthe \\(\\langle \\sigma \\rangle\\) form a basis for \\(\\mathcal{O}\\),\n\\(\\mathcal{O}\\) is Hausdorff.",
    "crumbs": [
      "9/17 - Completing theories"
    ]
  },
  {
    "objectID": "008_Sep17_completing_theories.html#key-concepts",
    "href": "008_Sep17_completing_theories.html#key-concepts",
    "title": "Math 557 Sep 17",
    "section": "",
    "text": "We previously defined the term model \\(\\mathcal{A}\\). It holds that for any atomic sentence \\(\\sigma\\), \\[\\mathcal{A} \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]\nTrying to extend this to arbitrary sentence via induction, the negation case looks like \\[\\mathcal{A} \\models \\neg\\sigma \\; \\iff \\;  \\mathcal{A} \\nvDash \\sigma \\; \\overset{\\text{ind hyp}}{\\iff} \\; T \\nvdash \\sigma\\] We would like to show that this is equivalent to \\(T \\vdash \\neg\\sigma\\).\nOne direction follows from \\(T\\) being consistent, but for the other direction, \\(T\\) may not be strong enough to prove this.\nWe therefore need to extend \\(T\\) to a complete theory.",
    "crumbs": [
      "9/17 - Completing theories"
    ]
  },
  {
    "objectID": "008_Sep17_completing_theories.html#problems",
    "href": "008_Sep17_completing_theories.html#problems",
    "title": "Math 557 Sep 17",
    "section": "",
    "text": "Exercise 1 \nVerify that indeed for all atomic sentences \\(\\sigma\\), \\[\\mathcal{A} \\models \\sigma \\quad \\iff \\quad T \\vdash \\sigma\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nRecall that a theory \\(T\\) is maximally consistent if it is consistent but does not have any consistent proper extensions. \\(T\\) is called deductively closed if the deductive closure of \\(T\\), \\[T^{\\vdash} = \\{ \\sigma : T \\vdash \\sigma \\}\\] is equal to \\(T\\).\n\nShow that a maximally consistent theory is complete and deductively closed.\nShow that if \\(T\\) is complete, then \\(T^{\\vdash}\\) is maximally consistent.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 \nIs every consistent, deductively closed theory complete?\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nShow that the union of an increasing sequence of consistent theories is consistent.\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 \nExtend Lindebaum’s theorem on the existence of maximally consistent extension from countable to arbitrary languages.\n\n\n\n\n\n\n\n\n\n\n\nExercise 6 \nFix a language \\(\\mathcal{L}\\). Let \\(X\\) be the set of all maximally consistent \\(\\mathcal{L}\\)-theories. For an \\(\\mathcal{L}\\)-sentence \\(\\sigma\\), let \\[\\langle \\sigma \\rangle = \\{ T \\in X \\colon \\sigma \\in T\\}\\]\nShow that\n\n\\(\\langle \\sigma \\land \\tau \\rangle = \\langle \\sigma \\rangle \\cap \\langle \\tau \\rangle\\)\n\\(\\langle \\neg\\sigma \\rangle = X \\setminus \\langle \\sigma \\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 7 \nContinuing the previous exercise, let \\(\\mathcal{O}\\) be the topology generated by the sets \\(\\langle \\sigma \\rangle\\). Show that\n\neach \\(\\langle \\sigma \\rangle\\) is clopen,\nthe \\(\\langle \\sigma \\rangle\\) form a basis for \\(\\mathcal{O}\\),\n\\(\\mathcal{O}\\) is Hausdorff.",
    "crumbs": [
      "9/17 - Completing theories"
    ]
  },
  {
    "objectID": "023_Oct29_peano_arithmetic.html",
    "href": "023_Oct29_peano_arithmetic.html",
    "title": "Math 557 Oct 29",
    "section": "",
    "text": "While the algebraic theories of groups, rings, fields, … have many models, (elementary) number theory studies properties of one model, which is called the standard model of number theory:\n\\[\n\\mathcal{N} = (\\mathbb{N},+,\\cdot,+1,0).\n\\]\nLet \\(\\mathcal{L}_{\\mathsf{PA}}\\) be the associated language, for which we also choose \\(+,\\cdot,0\\) as (non-logical) symbols, but \\(S\\) for the unary successor operation \\(+1\\). The theory of the standard model, \\(\\operatorname{Th}(\\mathcal{N})\\), is the set of \\(L_{\\mathsf{PA}}\\)-sentences that hold in this model. We have already seen as a consequence of the compactness theorem that there exist non-standard models, i.e., models that are not isomorphic to the standard model, because they have “infinitely large” numbers.\nMoreover, \\(\\operatorname{Th}(\\mathcal{N})\\) as a theory, while complete, is rather mysterious, since we do not know a priori which sentences exactly it comprises. The most important properties of the standard model are captured by the Peano Axioms.\n\nDefinition 1: Peano AxiomsP1. \\(Sx \\ne 0\\)\nP2. \\(Sx=Sy \\to x=y\\)\nP3. \\(x+0 = x\\)\nP4. \\(x+Sy =S(x+y)\\)\nP5. \\(x \\cdot 0 = 0\\)\nP6. \\(x \\cdot Sy = x \\cdot y + x\\)\nTo these we add the infinitely many induction axioms:\nInd. \\(\\varphi(0) \\, \\wedge \\, \\forall x (\\varphi(x) \\to \\varphi(Sx)) \\to \\forall x \\; \\varphi(x)\\)\n\n\nThe theory comprising these axioms is called \\(\\mathsf{PA}\\), Peano Arithmetic. As every model of \\(\\operatorname{Th}(\\mathcal{N})\\) is also a model of \\(\\mathsf{PA}\\), it follows from the compactness theorem that there are non-standard models of \\(\\mathsf{PA}\\).\n\nTheorem 2There exists a (countable) model \\(\\mathcal{N}^*\\) of \\(\\mathsf{PA}\\) which is not isomorphic to \\(\\mathcal{N}\\).\n\n\n(In fact, we know by Loewenheim-Skolem that there exists a non-standard model in every infinite cardinality.)\nThese results can be interpreted as an expressive weakness of the language of first-order logic, because if one moves to a language of second order, in which one additionally has the possibility of using second-order quantifiers \\(\\exists X, \\forall Y\\) to quantify over subsets of the respective domain, then one can uniquely characterize (up to isomorphism) the standard model in this stronger theory:\n\nDefinition 3: Second-Order Peano AxiomsThe theory \\(\\mathsf{PA}^{(2)}\\) (Peano Axioms of second order) has the following axioms:\nP1. \\(\\forall x \\; 0 \\ne Sx\\)\nP2. \\(\\forall x \\forall y (Sx = Sy \\to x = y)\\)\nIND. \\(\\forall X (0 \\in X \\wedge \\forall x ( x \\in X \\to Sx \\in X) \\to \\forall x \\; x \\in X)\\)\n\n\n\nTheorem 4Every model of \\(\\mathsf{PA}^{(2)}\\) is isomorphic to the standard model \\((\\mathbb{N},S,0)\\).\n\n\nThe second-order induction axiom (actually a set-theoretic axiom) is thus significantly more expressive than the corresponding induction schema, in which only first-order properties are allowed, which can only quantify over elements (instead of also over subsets) of natural numbers.\nOn the other hand, second-order logic has other disadvantages – most prominently, no completeness theorem holds.\n\n\n\\(\\mathsf{PA}\\) still has infinitely many (induction) axioms. We will introduce a finite subtheory that turns out is strong enough to capture many essential properties of arithmetic.\nThis theory is formalized in a language \\(\\mathcal{L}\\) with the symbols \\(0,1,&lt;,+, \\cdot\\). The first axioms state that addition and multiplication are associative and commutative and satisfy the distributive law, and furthermore that 0 and 1 are neutral elements for the respective operations and 0 is a zero divisor:\nAxioms A1-A7:\n\nA1: \\((x +y)+z= x + (y+z)\\)\nA2: \\((x \\cdot y) \\cdot z= x \\cdot (y \\cdot z)\\)\nA3: \\(x + y= y + x\\)\nA4: \\(x \\cdot y = y \\cdot x\\)\nA5: \\(x \\cdot (y+z) = x \\cdot y + x \\cdot z\\)\nA6: \\(x+0=x \\wedge x \\cdot 0 = 0\\)\nA7: \\(x \\cdot 1 = x\\)\n\nHere we use the usual algebraic bracket conventions (\\(\\cdot\\) binds more strongly than \\(+\\)). For the \\(&lt;\\)-relation, the axioms state that it is a linear order compatible with addition and multiplication:\nAxioms A8-A12:\n\nA8: \\(\\neg  \\; x &lt; x\\)\nA9: \\(x &lt; y \\wedge  y &lt; z \\to x &lt; z\\)\nA10: \\(x &lt; y \\vee x = y \\vee y &lt; x\\)\nA11: \\(x &lt; y \\to x+z &lt; y+z\\)\nA12: \\(0 &lt; z \\wedge x &lt; y \\to x \\cdot z &lt;  y \\cdot z\\)\n\nA number can be subtracted from a larger one:\nAxiom A13:\n\nA13: \\(x &lt; y \\to \\exists z \\; (x+z = y)\\)\n\nAnd finally, \\(1\\) is the successor of \\(0\\) and \\(0\\) is the smallest element (where as usual \\(x \\le y: \\iff x &lt; y \\vee x = y\\)):\nAxioms A14-A15:\n\nA14: \\(0&lt;1 \\wedge \\forall x \\; (0 &lt; x \\to 1 \\le x)\\)\nA15: \\(\\forall x \\; (0 \\le x)\\)\n\nFrom A14 it follows with A11 that more generally \\(x+1\\) is the successor of \\(x\\), and thus the order is discrete: \\[\nx &lt; x+1 \\wedge \\forall y \\; (x &lt; y \\to x+1 \\le y).\n\\]\n\n\n\nIn Peano Arithmetic \\(\\mathsf{PA}\\), one can define the \\(&lt;\\)-relation by \\(x&lt;y \\leftrightarrow \\exists z \\; (x+z+1 = y)\\) and thus obtain all axioms of \\(\\mathsf{PA}^-\\). In particular, the standard model \\(\\mathbb{N}\\) with the usual \\(&lt;\\)-relation, the usual operations, and the natural numbers 0,1 is a model of \\(\\mathsf{PA}^-\\).\nThe set \\(\\mathbb{Z}[X]\\) of polynomials in one variable \\(X\\) with integer coefficients is a commutative ring with the usual operations. One can order this ring by setting for a polynomial \\(p=a_n X^n+\\ldots a_1 X + a_0\\) with leading coefficient \\(a_n \\ne 0\\): \\[\na_n X^n+\\ldots a_1 X + a_0 &gt; 0 :\\iff a_n&gt;0\n\\] and thus ordering polynomials \\(p,q \\in \\mathbb{Z}[X]\\) by \\(p&lt;q: \\iff q-p&gt;0\\). The subset \\(\\mathbb{Z}[X]^+\\) of polynomials \\(p\\in \\mathbb{Z}[X]\\) with \\(p\\ge 0\\) then becomes a model of \\(\\mathsf{PA}^-\\), in which the polynomial \\(X\\) is larger than all constant polynomials and thus “infinitely large”.\n\n\n\n\nIn a ring, there is a group with respect to addition, while A13 only allows a restricted inverse formation. If one replaces axioms A13 and A15 in \\(\\mathsf{PA}^-\\) with the axiom\nAxiom A16:\n\nA16: \\(\\forall x \\; \\exists z \\; (x+z = 0)\\)\n\none obtains the algebraic theory DOR of discretely ordered rings, whose models include, for example, the rings \\(\\mathbb{Z}\\) and \\(\\mathbb{Z}[X]\\). Every model \\(\\mathcal{M}\\) of \\(\\mathsf{PA}^-\\) can be extended to a model \\(\\mathcal{R}\\) of the theory DOR (following the same pattern by which one extends the natural numbers to the ring of integers), such that the non-negative elements of \\(\\mathcal{R}\\) coincide with the original model. Conversely, for every model \\(\\mathcal{R}\\) of the theory DOR, the restriction to the non-negative elements is a model of \\(\\mathsf{PA}^-\\), so that one can describe \\(\\mathsf{PA}^-\\) as the theory of (the non-negative part of) discretely ordered rings.",
    "crumbs": [
      "10/29 - Peano Arithmetic"
    ]
  },
  {
    "objectID": "023_Oct29_peano_arithmetic.html#mathsfpa--peano-arithmetic-without-induction",
    "href": "023_Oct29_peano_arithmetic.html#mathsfpa--peano-arithmetic-without-induction",
    "title": "Math 557 Oct 29",
    "section": "",
    "text": "\\(\\mathsf{PA}\\) still has infinitely many (induction) axioms. We will introduce a finite subtheory that turns out is strong enough to capture many essential properties of arithmetic.\nThis theory is formalized in a language \\(\\mathcal{L}\\) with the symbols \\(0,1,&lt;,+, \\cdot\\). The first axioms state that addition and multiplication are associative and commutative and satisfy the distributive law, and furthermore that 0 and 1 are neutral elements for the respective operations and 0 is a zero divisor:\nAxioms A1-A7:\n\nA1: \\((x +y)+z= x + (y+z)\\)\nA2: \\((x \\cdot y) \\cdot z= x \\cdot (y \\cdot z)\\)\nA3: \\(x + y= y + x\\)\nA4: \\(x \\cdot y = y \\cdot x\\)\nA5: \\(x \\cdot (y+z) = x \\cdot y + x \\cdot z\\)\nA6: \\(x+0=x \\wedge x \\cdot 0 = 0\\)\nA7: \\(x \\cdot 1 = x\\)\n\nHere we use the usual algebraic bracket conventions (\\(\\cdot\\) binds more strongly than \\(+\\)). For the \\(&lt;\\)-relation, the axioms state that it is a linear order compatible with addition and multiplication:\nAxioms A8-A12:\n\nA8: \\(\\neg  \\; x &lt; x\\)\nA9: \\(x &lt; y \\wedge  y &lt; z \\to x &lt; z\\)\nA10: \\(x &lt; y \\vee x = y \\vee y &lt; x\\)\nA11: \\(x &lt; y \\to x+z &lt; y+z\\)\nA12: \\(0 &lt; z \\wedge x &lt; y \\to x \\cdot z &lt;  y \\cdot z\\)\n\nA number can be subtracted from a larger one:\nAxiom A13:\n\nA13: \\(x &lt; y \\to \\exists z \\; (x+z = y)\\)\n\nAnd finally, \\(1\\) is the successor of \\(0\\) and \\(0\\) is the smallest element (where as usual \\(x \\le y: \\iff x &lt; y \\vee x = y\\)):\nAxioms A14-A15:\n\nA14: \\(0&lt;1 \\wedge \\forall x \\; (0 &lt; x \\to 1 \\le x)\\)\nA15: \\(\\forall x \\; (0 \\le x)\\)\n\nFrom A14 it follows with A11 that more generally \\(x+1\\) is the successor of \\(x\\), and thus the order is discrete: \\[\nx &lt; x+1 \\wedge \\forall y \\; (x &lt; y \\to x+1 \\le y).\n\\]\n\n\n\nIn Peano Arithmetic \\(\\mathsf{PA}\\), one can define the \\(&lt;\\)-relation by \\(x&lt;y \\leftrightarrow \\exists z \\; (x+z+1 = y)\\) and thus obtain all axioms of \\(\\mathsf{PA}^-\\). In particular, the standard model \\(\\mathbb{N}\\) with the usual \\(&lt;\\)-relation, the usual operations, and the natural numbers 0,1 is a model of \\(\\mathsf{PA}^-\\).\nThe set \\(\\mathbb{Z}[X]\\) of polynomials in one variable \\(X\\) with integer coefficients is a commutative ring with the usual operations. One can order this ring by setting for a polynomial \\(p=a_n X^n+\\ldots a_1 X + a_0\\) with leading coefficient \\(a_n \\ne 0\\): \\[\na_n X^n+\\ldots a_1 X + a_0 &gt; 0 :\\iff a_n&gt;0\n\\] and thus ordering polynomials \\(p,q \\in \\mathbb{Z}[X]\\) by \\(p&lt;q: \\iff q-p&gt;0\\). The subset \\(\\mathbb{Z}[X]^+\\) of polynomials \\(p\\in \\mathbb{Z}[X]\\) with \\(p\\ge 0\\) then becomes a model of \\(\\mathsf{PA}^-\\), in which the polynomial \\(X\\) is larger than all constant polynomials and thus “infinitely large”.\n\n\n\n\nIn a ring, there is a group with respect to addition, while A13 only allows a restricted inverse formation. If one replaces axioms A13 and A15 in \\(\\mathsf{PA}^-\\) with the axiom\nAxiom A16:\n\nA16: \\(\\forall x \\; \\exists z \\; (x+z = 0)\\)\n\none obtains the algebraic theory DOR of discretely ordered rings, whose models include, for example, the rings \\(\\mathbb{Z}\\) and \\(\\mathbb{Z}[X]\\). Every model \\(\\mathcal{M}\\) of \\(\\mathsf{PA}^-\\) can be extended to a model \\(\\mathcal{R}\\) of the theory DOR (following the same pattern by which one extends the natural numbers to the ring of integers), such that the non-negative elements of \\(\\mathcal{R}\\) coincide with the original model. Conversely, for every model \\(\\mathcal{R}\\) of the theory DOR, the restriction to the non-negative elements is a model of \\(\\mathsf{PA}^-\\), so that one can describe \\(\\mathsf{PA}^-\\) as the theory of (the non-negative part of) discretely ordered rings.",
    "crumbs": [
      "10/29 - Peano Arithmetic"
    ]
  },
  {
    "objectID": "012_Sep26_midterm_review.html",
    "href": "012_Sep26_midterm_review.html",
    "title": "Math 557 Sep 26",
    "section": "",
    "text": "Midterm 1 Review\n\n\n\n\n\n\nTake-home Problem 1\n\n\n\n\nProve unique readability for the set of \\(\\mathcal{L}\\)-formulas.\n\n\n\nSolution 1. First prove readibility, i.e. the statement that for any \\(\\mathcal{L}\\)-formula \\(\\varphi\\), exactly one of the following cases holds:\n\nThere exist terms \\(s,t\\) such that \\(\\varphi \\equiv s=t\\).\nThere exists a relation symbol \\(R\\) and, if \\(n\\) is the arity of \\(R\\), terms \\(t_1, \\dots, t_n\\) sucht that \\(\\varphi \\equiv Rt_1\\dots t_n\\).\nThere exists a formula \\(\\psi\\) such that \\(\\varphi \\equiv \\neg \\psi\\).\nThere exist formulas \\(\\psi, \\theta\\) such that \\(\\varphi \\equiv (\\psi \\land \\theta)\\).\nThere exists a variable \\(x\\) and a formula \\(\\psi\\) such that \\(\\varphi \\equiv \\exists x \\psi\\).\n\nTo see this, let \\(F\\) be the subset of \\(\\mathcal{L}^*\\) such that every \\(\\theta \\in F\\) satisfies exactly one of (1)-(5). Then \\(F\\) contains all atomic formulas and is closed under \\(\\neg, \\land, \\exists x\\). Since the set of \\(\\mathcal{L}\\)-formulas is the smallest such set, it follows that every \\(\\mathcal{L}\\)-formula is contained in \\(F\\), and therefore has the desired property.\nSecond we argue that a proper initial segment of a formula cannot be a formula. We proceed by induction on the length \\(l\\) of \\(\\varphi\\). For \\(l=1\\) there is no formula of that length. Now suppose \\(\\varphi\\) is a formula of length \\(l+1\\), and \\(\\beta\\) is a proper initial segment. We may assume \\(\\beta\\) is not empty. We consider theses (1)-(5) from readability.\n\nCase \\(\\varphi \\equiv s=t\\)\n\nEither \\(\\beta \\equiv s = t'\\) with \\(t \\subset t'\\), but this would contradict that no proper initial segment of a term is a term. Or \\(\\beta \\equiv s=\\): An easy induction over the length of a formula shows that no formula ends with \\(=\\). Or \\(\\beta \\subseteq s\\). Another easy induction shows that no formula can be a term or an initial segment of a term.\n\nCase \\(\\varphi \\equiv Rt_1\\dots t_n\\)\n\nIf \\(\\beta\\) were a formula, it has to be of the form \\(Rs_1\\dots s_n\\). Comparing terms, we would see that one of the \\(s_i\\) is a proper initial segment of some \\(t_j\\), which is impossible.\n\nCase \\(\\varphi \\equiv \\neg \\theta\\)\n\nThen \\(\\beta \\equiv \\neg \\beta'\\) with \\(\\beta'\\) a proper initial segment of \\(\\theta\\). By inductive hypothesis, \\(\\beta'\\) is not a formula, hence \\(\\neg \\beta'\\) is not a formula either.\n\nCase \\(\\varphi \\equiv (\\psi \\land \\theta)\\)\n\nThen \\(\\beta\\) starts with \\((\\) but does not end with \\()\\). Another induction shows that for any formula, the number of \\((\\)’s always equals the number of \\()\\)’s.\n\nCase \\(\\varphi \\equiv \\exists x \\varphi\\)\n\nNeither ‘\\(\\exists\\)’ nor ‘\\(\\exists x\\)’ are formulas. If \\(\\beta\\) is longer than that, it is of the form \\(\\exists x \\beta'\\). By inductive hypothesis, \\(\\beta'\\) is not a formula, and hence \\(\\beta\\) is not a formula (by readability). varphi\n\n\nFinally, we prove unique readability: The choices in (1)-(5) are unique.\n\nCase (1)\n\nSuppose \\(\\varphi \\equiv s=t \\equiv s'=t'\\). Since no proper initial segment of a term is a term, it must hold that \\(s\\equiv s'\\) and \\(t \\equiv t'\\).\n\nCase (2)\n\nSuppose \\(\\varphi \\equiv Rt_1\\dots t_n \\equiv S s_1\\dots s_k\\). Then \\(R \\equiv S\\) and \\(n=k\\). Comparing terms inductively, using again the fact that no proper initial segment of a term is a term, we get \\(s_i \\equiv t_i\\) for all \\(i\\).\n\nCase (3)\n\nSuppose \\(\\varphi \\equiv \\neg \\psi \\equiv \\neg \\theta\\). Immediately, we infer \\(\\psi \\equiv \\theta\\).\n\nCase (4)\n\nSuppose \\(\\varphi \\equiv (\\psi_1 \\land \\theta_1) \\equiv (\\psi_2\\land \\theta_2)\\). Assume \\(\\psi_1 \\not\\equiv \\psi_2\\). Then \\(\\psi_1\\) is a proper initial segment of \\(\\psi_2\\) or vice versa (since both of them are part of \\(\\varphi\\)). Either case is impossible due to the fact that no proper initial segment of a formula is a formula. Hence \\(\\psi_1 \\equiv \\psi_2\\) and thus also \\(\\theta_1 \\equiv \\theta_2\\).\n\nCase (5)\n\nSuppose \\(\\varphi \\equiv \\exists x \\psi \\equiv \\exists y \\theta\\). By comparing entries, we get \\(x \\equiv y\\) and thus $, as desired.\n\n\n\n\n\n\n\n\n\nTake-home Problem 2\n\n\n\n\nLet \\(\\mathcal{L}\\) be any finite language and let \\(\\mathcal{M}\\) be a finite \\(\\mathcal{L}\\)-structure. Show that there is an \\(\\mathcal{L}\\)-sentence \\(\\varphi\\) such that \\[\n\\mathcal{N} \\models \\varphi \\; \\iff \\; \\mathcal{N} \\cong \\mathcal{M}.\n\\]\n\n\n\nSolution 2. Suppose \\(\\mathcal{L} = \\{c_1, \\cdots, c_k, f_1^{(a_1)}, \\dots f_l^{(a_l)}, R_1^{(b_1)}, \\dots, R_j^{(b_j)} \\}\\) where the \\((a_i), (b_m)\\) denote the arities of the respective symbols.\nSince \\(\\mathcal{M}\\) is finite, we may assume \\(M = \\{1, \\dots, n\\}\\) for some \\(n \\in \\mathbb{N}\\).\nThe basic idea is to collect all “elementary facts” about \\(\\mathcal{M}\\) in a single formula (think of a group multiplication table, just for all functions and relations).\nDefine\n\\[\\begin{aligned}\n\\varphi \\equiv \\; \\exists x_1, \\dots, x_n   \\biggl ( & \\bigwedge_{i \\neq m} x_i \\neq x_l \\; \\land \\; \\forall y \\bigvee_{i \\leq n} y = x_i \\\\\n& \\land \\bigwedge_{i \\leq k} c_i = x_{c^{\\mathcal{M}}_i} \\\\\n& \\land \\bigwedge_{i\\leq l} \\bigwedge_{\\pi \\in \\{1,\\dots, n\\}^{a_i}} f_i x_{\\pi(1)} \\dots x_{\\pi(a_i)} = x_{f^{\\mathcal{M}}_i(\\pi(1), \\dots, \\pi(a_i))} \\\\\n& \\land \\bigwedge_{i\\leq j} \\bigwedge_{\\pi \\in \\{1,\\dots, n\\}^{b_i}} \\delta_\\pi R_i x_{\\pi(1)} \\dots x_{\\pi(b_i)} \\biggr )\n\\end{aligned}\\]\nwhere \\(\\delta_\\pi\\) is empty if \\(R(\\pi(1), \\dots, \\pi(b_i))\\) holds in \\(\\mathcal{M}\\), and \\(\\neg\\) if not.\nAssme \\(\\mathcal{N} \\models \\varphi\\). Due to the first line of the equation, \\(N\\) has exactly \\(n\\) elements, and let \\(r_i \\in N\\) be the witness to \\(\\exists x_i\\). Define a mapping \\(\\tau: M \\to N\\) by letting \\(\\tau(i) = r_i\\). We claim that \\(\\tau\\) is an isomorphism.\nBy definition we have \\(\\tau(c_i^{\\mathcal{M}}) = r_{c_i^{\\mathcal{M}}}\\). Moreover, by the second line of the formula, \\(r_{c^{\\mathcal{M}}_i}\\) is the unique element of \\(N\\) that makes the formula \\(c_i = x_{c_i^{\\mathcal{M}}}\\) true. It follows that \\(\\tau(c_i^{\\mathcal{M}}) = c_i^{\\mathcal{N}}\\) for all \\(1 \\leq i \\leq k\\).\nUsing a similar argument with the third line of the formula, we obtain \\[\n\\tau(f_i^{\\mathcal{M}}(s_1, \\dots, s_{a_i})) = r_{f_i^{\\mathcal{M}}(s_1, \\dots, s_{a_i})} = f^{\\mathcal{N}}(r_{s_1}, \\dots, r_{s_{a_i}}) = f^{\\mathcal{N}}(\\tau(s_1), \\dots, \\tau(s_{a_i})\n\\] The argument for \\(R^{\\mathcal{M}}(s_1, \\dots, s_{b_i}) \\iff R^{`\\mathcal{N}}(\\tau(s_1), \\dots, \\tau(s_{b_i}))\\) is similar.\nOn the other hand, if \\(\\mathcal{M} \\cong \\mathcal{N}\\) via \\(\\tau\\), then \\(\\mathcal{N} \\models \\psi[\\tau(1), \\dots, \\tau(n)]\\), where \\(\\psi\\) is such that \\(\\varphi \\equiv \\exists x_1, \\dots, x_n \\: \\psi\\), due to the fact that \\(\\tau\\) is an isomorphism, and thus \\(\\mathcal{N} \\models \\varphi\\).\n\n\n\n\n\n\n\nTake-home Problem 3\n\n\n\n\nGive an example of a language \\(\\mathcal{L}\\) and an \\(\\mathcal{L}\\)-sentence \\(\\psi\\) such that\n\nthere is at least one \\(\\mathcal{L}\\)-structure \\(\\cal A\\) such that \\(\\cal A \\models \\psi\\),\nfor all \\(\\cal L\\)-structures \\(\\cal A\\), if \\(\\cal A \\models \\psi\\), then the universe \\(A\\) of \\(\\cal A\\) is infinite.\n\n\n\n\nSolution 3. Let \\(\\mathcal{L} = \\{&lt;\\}\\), where \\(&lt;\\) is a binary relation symbol. Define\n\\[\\begin{aligned}\n\\psi \\equiv \\;  & \\forall x \\; x \\nless x \\\\\n    & \\land \\forall x,y \\; x &lt; y \\lor x=y \\lor y &lt; x \\\\\n    & \\land \\forall x,y,z \\; (x &lt; y \\land y &lt; z) \\to x &lt; z \\\\\n    & \\land \\forall x \\exists y \\; x &lt; y\n\\end{aligned}\\]\nThe formula says that \\(&lt;\\) is a linear order with no maximal element.\nClearly, \\((\\mathbb{Z}, &lt;) \\models \\psi\\).\nNow suppose \\(\\mathcal{M} \\models \\psi\\). Due to the last line of \\(\\psi\\), there exists a function \\(f: M \\to M\\) such that \\(x &lt; f(x)\\) for all \\(x \\in M\\). We claim that for any \\(x\\) and for any \\(n \\neq m\\), \\[\nf^{(n)}(x) \\neq f^{(m)}(x)\n\\] This follows from antireflexivity (line one) and transitivity (line three).\nTherefore, the set \\[\n\\{x, f^{(1)}(x), f^{(2)}(x), \\dots \\}\n\\] is an infinite subset of \\(N\\).\n\n\n\n\n\n\n\nTake-home problem 4\n\n\n\n\nShow that\n\\[\\begin{aligned}\n\\{\\varphi \\to \\psi \\} & \\vdash \\exists x \\varphi \\: \\to \\: \\exists x \\psi \\\\\n\\{\\varphi \\to \\psi \\} & \\vdash \\forall x \\varphi \\: \\to \\: \\forall x \\psi \\\\\n\\end{aligned}\\]\n\n\n\nSolution 4. We give derivations below (with brief justifications). We collect simple substeps into a single one.\nFor \\(\\{\\varphi \\to \\psi \\}  \\vdash \\exists x \\varphi \\: \\to \\: \\exists x \\psi\\;\\):\n\n\n\n\n\n\n\nFormula\nJustification\n\n\n\n\n\\(\\varphi \\to \\psi\\)\ngiven\n\n\n\\(\\psi \\to \\exists x \\psi\\)\n(Q2)\n\n\n\\(\\varphi \\to \\exists x \\psi\\)\ntautology\n\n\n\\(\\neg \\exists x \\psi \\to \\neg \\varphi\\)\ntautotolgy\n\n\n\\(\\forall x ( \\neg \\exists x \\psi \\to \\neg \\varphi)\\)\n\\(\\forall\\)-intro\n\n\n\\(\\neg \\exists x \\psi \\to \\forall x \\varphi\\)\n(Q1), \\(x\\) not free in \\(\\neg \\exists x \\psi\\)\n\n\n\\(\\neg \\forall x \\neg \\varphi \\to \\exists x \\psi\\)\ntautology\n\n\n\\(\\exists x \\varphi \\to \\exists x \\psi\\)\n(Q3)\n\n\n\n\nFor \\(\\{\\varphi \\to \\psi \\}  \\vdash \\forall x \\varphi \\: \\to \\: \\forall x \\psi \\;\\):\n\n\n\n\n\n\n\nFormula\nJustification\n\n\n\n\n\\(\\varphi \\to \\psi\\)\ngiven\n\n\n\\(\\forall x \\varphi \\to \\varphi\\)\nExample 2.6.1 (d)\n\n\n\\(\\forall x \\varphi \\to \\psi\\)\nTautology\n\n\n\\(\\forall x (\\forall x \\varphi \\to \\psi)\\)\n\\(\\forall\\)-intro\n\n\n\\(\\forall x \\varphi \\to \\forall x \\psi\\)\n(Q1), \\(x\\) not free in \\(\\forall x \\varphi\\)\n\n\n\n\n\n\n\n\n\n\nTake-home Problem 6\n\n\n\n\nUse the compactness theorem to show (without using the Axiom of Choice) that every set can be linearly ordered.\nTry to strengthen this to:\n\nEvery partial order can be extended to a linear order.\n\n\n\n\nSolution 5. We first argue that any finite partial order \\((F,&lt;)\\) can be extended to a linear order.\nWe proceed by induction on the cardinality of \\(F\\).\nFor \\(|F|=0\\) there is nothing to prove.\nNow assume \\(|F|=n+1\\). Pick an arbitrary \\(a \\in F\\) and consider \\(F \\setminus \\{a\\}\\). By inductive hypothesis, \\(F \\setminus \\{a\\}\\) can be extended to a linear order \\(a_1 &lt; a_2 &lt; \\dots &lt; a_n\\).\nIf there does not exist \\(i\\) such that \\(a_i &lt;_F a\\), we can extend to a linear order on \\(F\\) by putting \\(a &lt; a_i\\) for all \\(i\\). Otherwise let \\(k\\) be maximal such that \\(a_k &lt; a\\). Then \\[\n    a_1 &lt; \\dots &lt; a_k &lt; a &lt; a_{k+1} &lt; \\dots &lt; a_n\n\\] defines a linear order that extends \\((F,&lt;)\\).\nNow let \\((P,&lt;)\\) be an arbitrary partial order. We extend the language \\(\\mathcal{L}_&lt;\\) of orders to \\(\\mathcal{L}_P\\), where we add a new constant symcol \\(c_p\\) for every \\(p \\in P\\).\nLet \\(T\\) be the theory of linear orders (see first three lines of sentence \\(\\varphi\\) in Problem 3) together with \\[\n\\{ c_p &lt; c_q : p &lt;_P q \\}\n\\] In other words, if \\(p\\) is less than \\(q\\) according to \\(P\\), we add a corresponding axiom to our theory.\nAny model of \\(T\\) is a liner order that extends \\(P\\).\nMoreover, any finite subset \\(T_0 \\subseteq T\\) induces a partial order on a finite subset of \\(P\\) (induced by those \\(p\\) for which \\(c_p\\) is part of a formula in \\(T_0\\)). By our argument in the first part, this finite partial order extends to a linear order, thereby giving a model of \\(T_0\\).\nBy compactness, \\(T\\) has a model \\(\\mathcal{M} = (M,&lt;)\\). By choice of \\(T\\), \\((M,&lt;)\\) is a linear order. Furthermore, the mapping \\[\n  c_p \\mapsto c_p^{\\mathcal{M}}\n\\] is one-to-one since \\(\\mathcal{M} \\models \\forall x \\ x \\nless x\\).\nWe can “pull back” the order on \\(\\mathcal{M}\\) to \\(P\\) by letting \\[\n  p &lt;' q \\iff c_p^{\\mathcal{M}} &lt;^{\\mathcal{M}} c_q^{\\mathcal{M}}\n\\] By definition of \\(T\\), \\(&lt;'\\) is a linear order that extends \\(&lt;_P\\).",
    "crumbs": [
      "Midterm 1 review"
    ]
  },
  {
    "objectID": "031_Nov19_first_incompleteness.html",
    "href": "031_Nov19_first_incompleteness.html",
    "title": "Math 557 Nov 19",
    "section": "",
    "text": "Theorem 1 (Gödel-Rosser Theorem) \nLet \\(T\\) be a recursive set of (Gödel numbers of) \\(\\mathcal{L}\\)-sentences such that:\n\n\\(T\\) is consistent, i.e., there is no \\(L\\)-sentence \\(\\sigma\\) with \\(\\ulcorner \\sigma \\urcorner \\in T\\) and at the same time \\(\\ulcorner \\neg \\sigma \\urcorner \\in T\\),\n\\(T\\) contains all \\(\\Sigma_1\\) and \\(\\Pi_1\\)-sentences that hold in \\(\\mathsf{PA}^-\\):\n\n\\[\n\\{\\ulcorner \\sigma \\urcorner : \\sigma \\in \\Sigma_1 \\cup \\Pi_1, \\sigma \\text{ sentence },  \\mathsf{PA}^- \\vdash \\sigma \\} \\subseteq T.\n\\]\nThen \\(T\\) is \\(\\Pi_1\\)-incomplete, i.e., there exists a \\(\\Pi_1\\)-sentence \\(\\tau\\) with\n\\[\n\\ulcorner  \\tau \\urcorner  \\not \\in T \\text{ and } \\ulcorner \\neg \\tau \\urcorner  \\not \\in T.\n\\]\n\n\n\n\n\nProof. Since \\(T\\) is recursive, there exists a \\(\\Sigma_1\\)-formula \\(\\theta(v)\\) such that for all \\(n \\in \\mathbb{N}\\)\n\\[\n\\begin{aligned}\nn \\in T & \\Longrightarrow  \\mathsf{PA}^- \\vdash \\theta(\\underline{n}),\\\\\nn \\not \\in T & \\Longrightarrow  \\mathsf{PA}^- \\vdash \\neg \\theta(\\underline{n}).\n\\end{aligned}\n\\]\nBy the Diagonal Lemma, there exists a \\(\\Pi_1\\)-sentence \\(\\tau\\) with\n\\[\n\\mathsf{PA}^- \\vdash \\tau \\leftrightarrow \\neg \\theta(\\underline{\\ulcorner  \\tau \\urcorner}).\n\\]\nFrom assumption (2) it follows that\n\\[\n\\ulcorner  \\tau \\urcorner  \\in T \\Rightarrow \\mathsf{PA}^- \\vdash \\theta(\\underline{\\ulcorner  \\tau \\urcorner}) \\Rightarrow \\mathsf{PA}^- \\vdash \\neg \\tau \\Rightarrow \\ulcorner \\neg \\tau \\urcorner  \\in T\n\\]\nand likewise, using (1),\n\\[\n\\ulcorner \\neg \\tau \\urcorner  \\in T \\Rightarrow \\ulcorner  \\tau \\urcorner \\not  \\in T \\Rightarrow \\mathsf{PA}^- \\vdash \\neg  \\theta(\\underline{\\ulcorner  \\tau \\urcorner}) \\Rightarrow \\mathsf{PA}^- \\vdash \\tau \\Rightarrow \\ulcorner \\tau \\urcorner  \\in T,\n\\]\nso that neither \\(\\ulcorner \\tau \\urcorner\\) nor \\(\\ulcorner \\neg \\tau \\urcorner\\) can be in \\(T\\).\n\n\n\n\n\n\n\n\nTheorem 2 (First Gödel Incompleteness Theorem) \nLet \\(T\\) be a consistent1 and recursively axiomatizable theory in language \\(L\\) which extends the theory \\(\\mathsf{PA}^-\\). Then \\(T\\) is incomplete. In particular, there exists a \\(\\Pi_1\\)-sentence \\(\\tau\\) with\n\\[\nT\\not \\vdash \\tau \\text{ and } T \\not \\vdash \\neg \\tau.\n\\]\n\n\n\n\n\nProof. We assume that \\(T\\) is recursively axiomatizable as well as complete (which implies that it is consistent, by definition), and derive a contradiction. As we proved in a previous lecture, the assumption implies that the set\n\\[\nS:= \\{\\ulcorner \\sigma \\urcorner : \\sigma \\text{ sentence },  T \\vdash \\sigma \\} = \\ulcorner (T^\\vdash) \\urcorner\n\\]\nis recursive. Thus the hypothesis of the Gödel-Rosser Theorem is met, which implies \\(S\\) is \\(\\Pi_1\\)-incomplete—a contradiction!\n\nEvery consistent extension \\(T\\) of \\(\\mathsf{PA}^-\\) has, by Lindenbaum’s Lemma, a complete and consistent extension, none of which, by the above theorem, can be recursive.\n\n\nThe use of the Diagonal Lemma yields rather “artificial” witnesses of incompleteness. Are there “natural” mathematical theorems that \\(\\mathsf{PA}\\) cannot decide? In 1982, Paris and Harrington2 found an example, based on Ramsey theory.\n\n\nIn its simplest form, the pigeonhole principle states:\n\nIf \\(n\\) elements are distributed into \\(m &lt; n\\) many pigeonholes, then one of the pigeonholes must contain at least 2 elements.\n\nThe generalization to infinite sets is:\n\nIf an infinite set is partitioned into finitely many sets, then at least one of these sets must be infinite: \\[\nA = A_0 \\mathop{\\dot{\\cup}} \\ldots \\mathop{\\dot{\\cup}} A_k \\text{ infinite } \\Rightarrow \\exists i \\leq k \\, (A_i \\text{ infinite}).\n\\]\n\nFor further generalization, we set \\[\n[A]^n := \\{x \\subseteq A \\mid |x| = n\\} \\text{ the set of $n$-element subsets of } A.\n\\]\nA partition of the \\(n\\)-element subsets of \\(A\\) into \\(k\\) parts can also be represented by a function \\[\nf : [A]^n \\to k\n\\] (where \\(A_i = \\{x \\in A \\mid f(x) = i\\}\\) are then the partition sets), and such an \\(f\\) is more intuitively called a coloring (of \\([A]^n\\)) with \\(k\\) colors. A subset \\(X \\subseteq A\\) with \\([X]^n \\subseteq A_i\\) for some \\(i &lt; k\\) (whose \\(n\\)-tuples are thus monochromatic) is called homogeneous for the partition \\(f\\).\n\n\n\n\n\n\n\nTheorem 3 (Ramsey’s Theorem) \nFor every coloring \\(f : [\\mathbb{N}]^n \\to k\\) of the \\(n\\)-element subsets of natural numbers with \\(k\\) colors, there exists an infinite subset \\(X \\subseteq \\mathbb{N}\\) such that all \\(n\\)-element subsets of \\(X\\) have the same color: \\[\nf : [\\mathbb{N}]^n \\to k \\Rightarrow \\exists X \\subseteq \\mathbb{N} \\, (X \\text{ infinite } \\land \\forall u,v \\in [X]^n \\, f(u) = f(v)).\n\\]\n\n\n\n\nThis states that every coloring of the \\(n\\)-element subsets of natural numbers with finitely many colors has an infinite homogeneous subset. This theorem is provable in set theory with a weak form of the axiom of choice (see, e.g., D. Marker: Model Theory: An Introduction, § 5.1).\n\n\n\n\n\n\n\nDefinition 1 (Relatively Large Sets) \nA (finite) set \\(H\\) of ordinal numbers is called relatively large if and only if \\[\n\\mathrm{card}(H) \\geq \\min(H).\n\\]\n\n\n\n\nIf \\(n,k \\in \\mathbb{N}\\), \\(\\alpha, \\gamma \\in \\mathrm{On}\\), then let \\[\n\\gamma \\longrightarrow (\\alpha)^n_k \\quad \\text{resp.} \\quad \\gamma \\stackrel{\\min}{\\longrightarrow} (\\alpha)^n_k\n\\] mean that for every coloring \\(f\\) of the \\(n\\)-element subsets of \\(\\gamma\\) with \\(k\\) colors, there exists a (relatively large) subset \\(H \\subseteq \\gamma\\) of order type \\(\\alpha\\) that is homogeneous for \\(f\\).\nTheorem 3 above thus states: \\(\\forall n,k, \\; \\omega \\to (\\omega)^n_k\\). From this follows the finitary Ramsey theorem (using a compactness argument): \\[\n\\forall m,n,k \\; \\exists r \\;\\; r \\to (m)^n_k.\n\\]\nThis is a theorem about natural numbers and can be expressed in the language of Peano arithmetic and proven in \\(\\mathsf{PA}\\).However, an (apparently) slight strengthening cannot:\n\n\n\n\n\n\n\nTheorem 4 (Paris-Harrington Theorem) \nThe statement \\[\n\\forall m,n,k \\, \\exists r \\, r \\stackrel{\\min}{\\longrightarrow} (m)^n_k\n\\] is provable in set theory, but not in \\(\\mathsf{PA}\\) (provided \\(\\mathsf{PA}\\) is consistent). The existence of these numbers \\(r\\) can no longer be shown generally in \\(\\mathsf{PA}\\); in fact, they lead to very large numbers: If \\[\n\\sigma(n) = \\text{the smallest } r \\text{ with } r \\stackrel{\\min}{\\longrightarrow} (n+1)^n_n,\n\\] then the function \\(\\sigma\\) eventually dominates every recursive function \\(f\\) (i.e., for every recursive function \\(f\\) there exists a \\(p\\) such that \\(f(n) &lt; \\sigma(n)\\) for all \\(n \\geq p\\)).",
    "crumbs": [
      "11/19 - First Incompleteness Theorem"
    ]
  },
  {
    "objectID": "031_Nov19_first_incompleteness.html#the-paris-harrington-theorem",
    "href": "031_Nov19_first_incompleteness.html#the-paris-harrington-theorem",
    "title": "Math 557 Nov 19",
    "section": "",
    "text": "The use of the Diagonal Lemma yields rather “artificial” witnesses of incompleteness. Are there “natural” mathematical theorems that \\(\\mathsf{PA}\\) cannot decide? In 1982, Paris and Harrington2 found an example, based on Ramsey theory.\n\n\nIn its simplest form, the pigeonhole principle states:\n\nIf \\(n\\) elements are distributed into \\(m &lt; n\\) many pigeonholes, then one of the pigeonholes must contain at least 2 elements.\n\nThe generalization to infinite sets is:\n\nIf an infinite set is partitioned into finitely many sets, then at least one of these sets must be infinite: \\[\nA = A_0 \\mathop{\\dot{\\cup}} \\ldots \\mathop{\\dot{\\cup}} A_k \\text{ infinite } \\Rightarrow \\exists i \\leq k \\, (A_i \\text{ infinite}).\n\\]\n\nFor further generalization, we set \\[\n[A]^n := \\{x \\subseteq A \\mid |x| = n\\} \\text{ the set of $n$-element subsets of } A.\n\\]\nA partition of the \\(n\\)-element subsets of \\(A\\) into \\(k\\) parts can also be represented by a function \\[\nf : [A]^n \\to k\n\\] (where \\(A_i = \\{x \\in A \\mid f(x) = i\\}\\) are then the partition sets), and such an \\(f\\) is more intuitively called a coloring (of \\([A]^n\\)) with \\(k\\) colors. A subset \\(X \\subseteq A\\) with \\([X]^n \\subseteq A_i\\) for some \\(i &lt; k\\) (whose \\(n\\)-tuples are thus monochromatic) is called homogeneous for the partition \\(f\\).\n\n\n\n\n\n\n\nTheorem 3 (Ramsey’s Theorem) \nFor every coloring \\(f : [\\mathbb{N}]^n \\to k\\) of the \\(n\\)-element subsets of natural numbers with \\(k\\) colors, there exists an infinite subset \\(X \\subseteq \\mathbb{N}\\) such that all \\(n\\)-element subsets of \\(X\\) have the same color: \\[\nf : [\\mathbb{N}]^n \\to k \\Rightarrow \\exists X \\subseteq \\mathbb{N} \\, (X \\text{ infinite } \\land \\forall u,v \\in [X]^n \\, f(u) = f(v)).\n\\]\n\n\n\n\nThis states that every coloring of the \\(n\\)-element subsets of natural numbers with finitely many colors has an infinite homogeneous subset. This theorem is provable in set theory with a weak form of the axiom of choice (see, e.g., D. Marker: Model Theory: An Introduction, § 5.1).\n\n\n\n\n\n\n\nDefinition 1 (Relatively Large Sets) \nA (finite) set \\(H\\) of ordinal numbers is called relatively large if and only if \\[\n\\mathrm{card}(H) \\geq \\min(H).\n\\]\n\n\n\n\nIf \\(n,k \\in \\mathbb{N}\\), \\(\\alpha, \\gamma \\in \\mathrm{On}\\), then let \\[\n\\gamma \\longrightarrow (\\alpha)^n_k \\quad \\text{resp.} \\quad \\gamma \\stackrel{\\min}{\\longrightarrow} (\\alpha)^n_k\n\\] mean that for every coloring \\(f\\) of the \\(n\\)-element subsets of \\(\\gamma\\) with \\(k\\) colors, there exists a (relatively large) subset \\(H \\subseteq \\gamma\\) of order type \\(\\alpha\\) that is homogeneous for \\(f\\).\nTheorem 3 above thus states: \\(\\forall n,k, \\; \\omega \\to (\\omega)^n_k\\). From this follows the finitary Ramsey theorem (using a compactness argument): \\[\n\\forall m,n,k \\; \\exists r \\;\\; r \\to (m)^n_k.\n\\]\nThis is a theorem about natural numbers and can be expressed in the language of Peano arithmetic and proven in \\(\\mathsf{PA}\\).However, an (apparently) slight strengthening cannot:\n\n\n\n\n\n\n\nTheorem 4 (Paris-Harrington Theorem) \nThe statement \\[\n\\forall m,n,k \\, \\exists r \\, r \\stackrel{\\min}{\\longrightarrow} (m)^n_k\n\\] is provable in set theory, but not in \\(\\mathsf{PA}\\) (provided \\(\\mathsf{PA}\\) is consistent). The existence of these numbers \\(r\\) can no longer be shown generally in \\(\\mathsf{PA}\\); in fact, they lead to very large numbers: If \\[\n\\sigma(n) = \\text{the smallest } r \\text{ with } r \\stackrel{\\min}{\\longrightarrow} (n+1)^n_n,\n\\] then the function \\(\\sigma\\) eventually dominates every recursive function \\(f\\) (i.e., for every recursive function \\(f\\) there exists a \\(p\\) such that \\(f(n) &lt; \\sigma(n)\\) for all \\(n \\geq p\\)).",
    "crumbs": [
      "11/19 - First Incompleteness Theorem"
    ]
  },
  {
    "objectID": "031_Nov19_first_incompleteness.html#footnotes",
    "href": "031_Nov19_first_incompleteness.html#footnotes",
    "title": "Math 557 Nov 19",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe original version of Gödel’s theorem had the stronger assumption of \\(\\omega\\)-consistency of \\(T\\) (i.e., for all \\(L\\)-formulas \\(\\theta(v)\\) with \\(T \\vdash \\theta(\\underline{n})\\) for all \\(n \\in \\mathbb{N}\\), the theory \\(T \\cup \\{\\forall v \\, \\theta(v)\\}\\) is consistent). Rosser proved this stronger version in 1936.↩︎\nA mathematical Incompleteness in Peano Arithmetic. In: Handbook of Mathematical Logic, ed. Barwise, Elsevier 1982↩︎",
    "crumbs": [
      "11/19 - First Incompleteness Theorem"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "557",
    "section": "",
    "text": "This site collects course material for Math 557, Mathematical Logic, at Penn State."
  },
  {
    "objectID": "016_Oct08_ultraproducts.html",
    "href": "016_Oct08_ultraproducts.html",
    "title": "Math 557 Oct 8",
    "section": "",
    "text": "Let \\((\\mathcal{M}_i)_{i \\in I}\\) be a family of \\(L\\)-structures.\nWe define the direct product \\[\n\\mathcal{M} = \\prod_{i \\in I} \\mathcal{M}_i\n\\] as follows:\n\nThe universe is the Cartesian product \\(M = \\prod_{i \\in I} M_i\\). If \\(a\\) is an element of \\(M\\), we denote its \\(i\\)-th component (an element of \\(M_i\\)) by \\(a_i\\) and extend this notation to vectors: if \\(\\vec a\\) is a finite tuple in \\(M^n\\), \\(\\vec a_i\\) denotes the \\(n\\)-tuple in \\(M_i\\) consisting of the \\(M_i\\)-entries of \\(\\vec a\\).\nFor each relation symbol \\(R \\in \\mathcal{L}\\), \\[\nR^{\\mathcal{M}}(\\vec a) :\\iff \\forall i \\in I,\\,\n\\vec a_i \\in R^{\\mathcal{M}_i}\n\\]\nFor each function symbol \\(f \\in \\mathcal{L}\\), \\[\nf^{\\mathcal{M}}(\\vec a)\n:= (f^{\\mathcal{M}_i}(\\vec a_i))_{i\\in I}.\n\\]\nFor each constant \\(c \\in \\mathcal{L}\\), \\[\nc^{\\mathcal{M}} = (c^{\\mathcal{M}_i})_{i\\in I}.\n\\]\n\n\n\n\nThe direct product of groups is again a group (componentwise operation).\nThe direct product of fields is not a field: \\[\n(1,0)\\cdot(0,1) = (0,0).\n\\]\nThe direct product of linear orders is only a partial order.\n\nWe often want to preserve properties that hold in “most” component structures.\nTo formalize “most,” we use filters on \\(I\\).\n\n\n\n\nA filter \\(\\mathcal{F}\\) on a set \\(I\\) is a nonempty collection of subsets of \\(I\\) satisfying:\n\n\\(\\emptyset \\notin \\mathcal{F}\\)\n\nIf \\(A,B \\in \\mathcal{F}\\), then \\(A \\cap B \\in \\mathcal{F}\\)\n\nIf \\(A \\in \\mathcal{F}\\) and \\(A \\subseteq B \\subseteq I\\), then \\(B \\in \\mathcal{F}\\)\n\nAn ultrafilter \\(\\mathcal{U}\\) is a maximal filter, equivalently:\n\nFor all \\(A \\subseteq I\\), either \\(A \\in \\mathcal{U}\\) or \\(I \\setminus A \\in \\mathcal{U}\\).\n\nUltrafilters interact nicely with logical operators:\n\n\\(A \\not \\in \\mathcal{U} \\iff I \\backslash A \\in \\mathcal{U}\\),\n\\(A  \\in \\mathcal{U} \\wedge B \\in \\mathcal{U} \\iff A \\cap B \\in \\mathcal{U}\\),\n\\(A  \\in \\mathcal{U} \\vee B \\in \\mathcal{U} \\iff A \\cup B \\in \\mathcal{U}\\).\n\n\n\n\nA principal filter is of the form\n\\[\n\\mathcal{F}_A = \\{ X \\subseteq I : A \\subseteq X \\}\n\\] for some nonempty \\(A \\subseteq I\\).\nIf \\(A = \\{a\\}\\), then \\(\\mathcal{F}_A\\) is a principal ultrafilter.\nA free (non-principal) ultrafilter exists on every infinite set \\(I\\)\n(via Zorn’s Lemma / Boolean prime ideal theorem).\n\n\n\n\nA family of sets has the finite intersection property (FIP) if every finite subfamily has nonempty intersection.\n\n\n\n\n\n\n\nTheorem 1 \nIf a family \\(\\mathcal{A} \\subseteq \\mathcal{P}(I)\\) has the FIP,\nthen there exists an ultrafilter \\(\\mathcal{U}\\) on \\(I\\) with \\(\\mathcal{A} \\subseteq \\mathcal{U}\\).\n\n\n\n\n\n\n\n\nGiven a filter \\(\\mathcal{F}\\) on \\(I\\) and structures \\((\\mathcal{M}_i)_{i \\in I}\\), define the reduced product \\[\n\\mathcal{M} / \\mathcal{F}\n\\] as follows.\nLet \\(M = \\prod_{i \\in I} M_i\\). For \\(a,b \\in M\\), define \\[\na \\sim_{\\mathcal{F}} b \\iff \\{\\, i \\in I : a_i = b_i \\,\\} \\in \\mathcal{F}.\n\\]\nThe universe of \\(\\mathcal{M}/\\mathcal{F}\\) is the quotient \\(M / {\\sim_{\\mathcal{F}}}\\), with elements denoted \\(a_{\\mathcal{F}}\\) (alternatively, \\(a/\\mathcal{F}\\)).\nFor symbols of \\(\\mathcal{L}\\):\n\nRelations:\n\\[\nR^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}})\n: \\iff  \\{\\, i : \\mathcal{M}_i \\models R(\\vec a_i) \\,\\} \\in \\mathcal{F}.\n\\]\nFunctions:\n\\[\nf^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}}) =\n[\\, (f^{\\mathcal{M}_i}(\\vec a_i))_{i \\in I} \\,]_{\\mathcal{F}}.\n\\]\nConstants:\n\\[\nc^{\\mathcal{M}/\\mathcal{F}} = ((c^{\\mathcal{M}_i})_{i\\in I})_{\\mathcal{F}}.\n\\]\n\n\n\n\n\n\n\n\nExercise 1 Check that the above definition does not depend on the choice of representative for each equivalence class\n\n\n\n\n\n\nIf \\(\\mathcal{U}\\) is an ultrafilter on \\(I\\), the reduced product \\[\n\\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\n\\] is called the ultraproduct of \\((\\mathcal{M}_i)_{i \\in I}\\) modulo \\(\\mathcal{U}\\).\nWhen all \\(\\mathcal{M}_i\\) are the same structure \\(\\mathcal{M}\\), we get an ultrapower \\[\n\\mathcal{M}^I / \\mathcal{U}.\n\\]\n\n\n\n\nLet \\(\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\\) be an ultraproduct.\n\n\n\n\n\n\n\nTheorem 2 \nFor every \\(\\mathcal{L}\\)-formula \\(\\varphi(x_1,\\dots,x_n)\\) and tuples\n\\(\\vec a \\in \\prod_{i \\in I} M_i\\), \\[\n\\mathcal{M}/\\mathcal{U} \\models \\varphi[\\vec a_{\\mathcal{U}}]\n\\iff\n\\{\\, i \\in I : \\mathcal{M}_i \\models \\varphi[\\vec a_i]\\,\\} \\in \\mathcal{U}.\n\\]\n\n\n\n\nFor any \\(\\mathcal{L}\\)-formula \\(\\varphi(v_0,\\ldots,v_{n-1})\\) a a tuple \\(\\vec{a} \\in \\prod M_i\\) we define the Boolean extension as \\[\n\\|\\varphi(\\vec{a}) \\| := \\{i \\in I| \\mathcal{M}_i \\models \\varphi[\\vec{a}_i]\\}\n\\]\n\n\n\n\n\n\n\nLemma 1  \n\n\\(\\| \\neg \\varphi(\\vec{a}) \\| = I \\backslash \\|\\varphi(\\vec{a}) \\|\\),\n\\(\\| (\\varphi \\wedge \\psi)(\\vec{a}) \\| =\\| \\varphi(\\vec{a}) \\| \\cap \\| \\psi(\\vec{a}) \\|\\),\n\\(\\| (\\varphi \\vee \\psi)(\\vec{a}) \\| =\\| \\varphi(\\vec{a}) \\| \\cup \\| \\psi(\\vec{a}) \\|\\),\nFor all tuples \\(\\vec{a}\\) and elements \\(b\\) in \\(A\\): \\[\n\\|\\varphi(\\vec{a},b) \\| \\subseteq \\| (\\exists v_n \\varphi)(\\vec{a}) \\|,\n\\] and there exists \\(b \\in M\\) such that \\[\n\\|\\varphi(\\vec{a},b) \\| = \\| (\\exists v_n \\varphi)(\\vec{a}) \\|.\n\\]\n\n\n\n\n\n\nProof. (1)-(3) and the first part of (4) follow directly from the definition of ultrafilters (and the definition of \\(\\models\\)).\nFor the second part of (4), we observe that for every \\[\ni \\in \\| (\\exists v_n \\varphi)(\\vec{a}) \\|\n\\] there exists \\(b_i \\in A_i\\) with \\(\\mathcal{M}_i \\models \\varphi[\\vec{a}_i,b_i]\\). For all other \\(j \\in I \\setminus \\| (\\exists v_n \\varphi)(\\vec{a}) \\|\\) we choose an aribitrary \\(b_j \\in A_j\\). This yields a sequence \\(b = (b_i)_{i\\in I}\\) with \\(b \\in M\\), for which \\[\n\\| (\\exists v_n \\varphi)(\\vec{a}) \\| \\subseteq \\|\\varphi(\\vec{a},b) \\|.\n\\] Together with the first part we obtain \\(=\\).\n\n\n\nWe proceed by induction over the formula height. A straightforward argument shows that the interpretation of functions and symbols in \\(\\mathcal{M}\\) extends to terms in the following way: \\[\nt^{\\mathcal{M}/\\mathcal{U}}(\\vec{a}/U) = (t^{\\mathcal{M}_i}(\\vec{a}_i))_{i \\in I}/\\mathcal{U} = t^{\\mathcal{M}}(\\vec{a})/\\mathcal{U}\n\\] This easily implies the statement for atomic formulas.\nFor \\(\\varphi \\equiv \\neg \\psi\\), we have \\[\n\\begin{aligned}\n\\mathcal{M}/\\mathcal{U} \\models \\neg \\psi[\\vec{a}_{\\mathcal{U}}]\n&\\iff \\mathcal{M}/\\mathcal{U} \\not\\models \\psi[\\vec{a}_{\\mathcal{U}}] \\\\[6pt]\n&\\iff \\{\\, i : \\mathcal{M}_i \\models \\psi[\\vec{a}_i] \\,\\} \\notin \\mathcal{U}\n&& \\text{(I.H.)} \\\\[6pt]\n&\\iff \\| \\psi(\\vec{a}) \\| \\notin \\mathcal{U} \\\\[6pt]\n&\\iff \\neg \\| \\psi(\\vec{a}) \\| \\in \\mathcal{U}\n&& (\\mathcal{U}\\ \\text{is an ultrafilter}) \\\\[6pt]\n&\\iff \\| \\neg \\psi(\\vec{a}) \\| \\in \\mathcal{U}\n&& \\text{(Lemma (i))} \\\\[6pt]\n&\\iff \\{\\, i : \\mathcal{M}_i \\models \\neg \\psi[\\vec{a}_i] \\,\\} \\in \\mathcal{U}.\n\\end{aligned}\n\\]\nThe case \\(\\varphi \\equiv (\\psi \\land \\theta)\\) is similar.\nFinally, assume \\(\\varphi \\equiv \\exists y \\psi\\). Then \\[\n\\begin{aligned}\n\\mathcal{M}/\\mathcal{U} \\models \\exists y\\, \\psi[\\vec{a}_{\\mathcal{U}}]\n&\\iff \\exists b_{\\mathcal{U}} \\in \\mathcal{M}/\\mathcal{U} \\text{ such that }\n   \\mathcal{M}/\\mathcal{U} \\models \\psi[\\vec{a}_{\\mathcal{U}}, b_{\\mathcal{U}}] \\\\[6pt]\n&\\iff \\exists b \\in M \\text{ such that }\n   \\{\\, i : \\mathcal{M}_i \\models \\psi[\\vec{a}_i, b_i] \\,\\} \\in \\mathcal{U}\n   && \\text{(I.H.)} \\\\[6pt]\n&\\iff \\exists b \\in M \\text{ such that } \\|\\psi(\\vec{a}, b)\\| \\in \\mathcal{U} \\\\[6pt]\n&\\iff \\|\\exists y\\, \\psi(\\vec{a})\\| \\in \\mathcal{U}\n   && (\\mathcal{U}\\ \\text{ultrafilter, Lemma (4)}) \\\\[6pt]\n&\\iff \\{\\, i : \\mathcal{M}_i \\models \\exists y\\, \\psi[\\vec{a}_i] \\,\\} \\in \\mathcal{U}.\n\\end{aligned}\n\\]\nThis completes the proof.\n\n\n\n\n\nPreservation of theories:\nIf each \\(\\mathcal{M}_i \\models T\\), then \\(\\prod_i \\mathcal{M}_i / \\mathcal{U} \\models T\\).\nUltrapowers:\n\\(\\mathcal{M} \\equiv \\mathcal{M}^I / \\mathcal{U}\\), i.e., a structure is elementarily equivalent to any of its ultrapowers.\nNonstandard models:\nFor example, the ultrapower \\(\\mathbb{N}^{\\mathbb{N}}/\\mathcal{U}\\) (with \\(\\mathcal{U}\\) non-principal) yields a countably saturated nonstandard model of arithmetic.\n\n\n\nSuppose \\(T\\) is an \\(\\mathcal{L}\\)-theory for which every finite subset \\(\\Delta\\) has a model \\(\\mathcal{M}_\\Delta\\).\nLet \\(I = \\{\\Delta : \\Delta \\subseteq T \\text{ finite}\\}\\).\nFor \\(\\sigma \\in T\\), let \\[\n\\begin{aligned}\n\\hat{\\sigma} & = \\{\\Delta \\in I : \\sigma \\in \\Delta\\} \\subseteq I \\\\\nE & = \\{\\hat{\\sigma} : \\sigma \\in T\\} \\subseteq \\mathcal{P}(I) \\\\\n\\end{aligned}\n\\]\n\\(E\\) has FIP (finite intersection property), since for \\(\\hat{S}_1, \\ldots, \\hat{S}_n \\in E\\), \\[\n\\{\\hat{\\sigma}_1, \\ldots, \\hat{\\sigma}_n\\} \\in \\hat{\\sigma}_1 \\cap \\cdots \\cap \\hat{\\sigma}_n.\n\\]\nBy Theorem 1, \\(E\\) can be extended to an ultrafilter \\(\\mathcal{U}\\) on \\(I\\).\nClaim: \\(\\mathcal{M}/\\mathcal{U} = \\prod_{\\Delta \\in I} \\mathcal{M}_\\Delta / \\mathcal{U} \\models T\\).\nLet \\(\\sigma \\in T\\). Then for \\(\\Delta \\in I\\), \\[\n\\Delta \\in \\hat{\\sigma} \\; \\Rightarrow \\; \\sigma \\in \\Delta \\; \\Rightarrow \\; \\mathcal{M}_\\Delta \\models \\sigma\n\\]\nHence \\[\n\\hat{\\sigma} \\subseteq \\{\\Delta \\in I : \\mathcal{M}_\\Delta \\models \\sigma\\}\n\\]\nSince \\(\\hat{\\sigma} \\in E\\) and \\(E \\subseteq \\mathcal{U}\\), we have \\(\\hat{\\sigma} \\in \\mathcal{U}\\), which implies \\[\n\\{\\Delta \\in I : \\mathcal{M}_\\Delta \\models \\sigma\\} \\in \\mathcal{U}\n\\]\nBy Łoś’ Theorem, \\(\\mathcal{M} \\models \\sigma\\).",
    "crumbs": [
      "10/8 - Ultraproducts"
    ]
  },
  {
    "objectID": "016_Oct08_ultraproducts.html#direct-products",
    "href": "016_Oct08_ultraproducts.html#direct-products",
    "title": "Math 557 Oct 8",
    "section": "",
    "text": "Let \\((\\mathcal{M}_i)_{i \\in I}\\) be a family of \\(L\\)-structures.\nWe define the direct product \\[\n\\mathcal{M} = \\prod_{i \\in I} \\mathcal{M}_i\n\\] as follows:\n\nThe universe is the Cartesian product \\(M = \\prod_{i \\in I} M_i\\). If \\(a\\) is an element of \\(M\\), we denote its \\(i\\)-th component (an element of \\(M_i\\)) by \\(a_i\\) and extend this notation to vectors: if \\(\\vec a\\) is a finite tuple in \\(M^n\\), \\(\\vec a_i\\) denotes the \\(n\\)-tuple in \\(M_i\\) consisting of the \\(M_i\\)-entries of \\(\\vec a\\).\nFor each relation symbol \\(R \\in \\mathcal{L}\\), \\[\nR^{\\mathcal{M}}(\\vec a) :\\iff \\forall i \\in I,\\,\n\\vec a_i \\in R^{\\mathcal{M}_i}\n\\]\nFor each function symbol \\(f \\in \\mathcal{L}\\), \\[\nf^{\\mathcal{M}}(\\vec a)\n:= (f^{\\mathcal{M}_i}(\\vec a_i))_{i\\in I}.\n\\]\nFor each constant \\(c \\in \\mathcal{L}\\), \\[\nc^{\\mathcal{M}} = (c^{\\mathcal{M}_i})_{i\\in I}.\n\\]\n\n\n\n\nThe direct product of groups is again a group (componentwise operation).\nThe direct product of fields is not a field: \\[\n(1,0)\\cdot(0,1) = (0,0).\n\\]\nThe direct product of linear orders is only a partial order.\n\nWe often want to preserve properties that hold in “most” component structures.\nTo formalize “most,” we use filters on \\(I\\).",
    "crumbs": [
      "10/8 - Ultraproducts"
    ]
  },
  {
    "objectID": "016_Oct08_ultraproducts.html#filters-and-ultrafilters",
    "href": "016_Oct08_ultraproducts.html#filters-and-ultrafilters",
    "title": "Math 557 Oct 8",
    "section": "",
    "text": "A filter \\(\\mathcal{F}\\) on a set \\(I\\) is a nonempty collection of subsets of \\(I\\) satisfying:\n\n\\(\\emptyset \\notin \\mathcal{F}\\)\n\nIf \\(A,B \\in \\mathcal{F}\\), then \\(A \\cap B \\in \\mathcal{F}\\)\n\nIf \\(A \\in \\mathcal{F}\\) and \\(A \\subseteq B \\subseteq I\\), then \\(B \\in \\mathcal{F}\\)\n\nAn ultrafilter \\(\\mathcal{U}\\) is a maximal filter, equivalently:\n\nFor all \\(A \\subseteq I\\), either \\(A \\in \\mathcal{U}\\) or \\(I \\setminus A \\in \\mathcal{U}\\).\n\nUltrafilters interact nicely with logical operators:\n\n\\(A \\not \\in \\mathcal{U} \\iff I \\backslash A \\in \\mathcal{U}\\),\n\\(A  \\in \\mathcal{U} \\wedge B \\in \\mathcal{U} \\iff A \\cap B \\in \\mathcal{U}\\),\n\\(A  \\in \\mathcal{U} \\vee B \\in \\mathcal{U} \\iff A \\cup B \\in \\mathcal{U}\\).\n\n\n\n\nA principal filter is of the form\n\\[\n\\mathcal{F}_A = \\{ X \\subseteq I : A \\subseteq X \\}\n\\] for some nonempty \\(A \\subseteq I\\).\nIf \\(A = \\{a\\}\\), then \\(\\mathcal{F}_A\\) is a principal ultrafilter.\nA free (non-principal) ultrafilter exists on every infinite set \\(I\\)\n(via Zorn’s Lemma / Boolean prime ideal theorem).\n\n\n\n\nA family of sets has the finite intersection property (FIP) if every finite subfamily has nonempty intersection.\n\n\n\n\n\n\n\nTheorem 1 \nIf a family \\(\\mathcal{A} \\subseteq \\mathcal{P}(I)\\) has the FIP,\nthen there exists an ultrafilter \\(\\mathcal{U}\\) on \\(I\\) with \\(\\mathcal{A} \\subseteq \\mathcal{U}\\).",
    "crumbs": [
      "10/8 - Ultraproducts"
    ]
  },
  {
    "objectID": "016_Oct08_ultraproducts.html#reduced-products",
    "href": "016_Oct08_ultraproducts.html#reduced-products",
    "title": "Math 557 Oct 8",
    "section": "",
    "text": "Given a filter \\(\\mathcal{F}\\) on \\(I\\) and structures \\((\\mathcal{M}_i)_{i \\in I}\\), define the reduced product \\[\n\\mathcal{M} / \\mathcal{F}\n\\] as follows.\nLet \\(M = \\prod_{i \\in I} M_i\\). For \\(a,b \\in M\\), define \\[\na \\sim_{\\mathcal{F}} b \\iff \\{\\, i \\in I : a_i = b_i \\,\\} \\in \\mathcal{F}.\n\\]\nThe universe of \\(\\mathcal{M}/\\mathcal{F}\\) is the quotient \\(M / {\\sim_{\\mathcal{F}}}\\), with elements denoted \\(a_{\\mathcal{F}}\\) (alternatively, \\(a/\\mathcal{F}\\)).\nFor symbols of \\(\\mathcal{L}\\):\n\nRelations:\n\\[\nR^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}})\n: \\iff  \\{\\, i : \\mathcal{M}_i \\models R(\\vec a_i) \\,\\} \\in \\mathcal{F}.\n\\]\nFunctions:\n\\[\nf^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}}) =\n[\\, (f^{\\mathcal{M}_i}(\\vec a_i))_{i \\in I} \\,]_{\\mathcal{F}}.\n\\]\nConstants:\n\\[\nc^{\\mathcal{M}/\\mathcal{F}} = ((c^{\\mathcal{M}_i})_{i\\in I})_{\\mathcal{F}}.\n\\]\n\n\n\n\n\n\n\n\nExercise 1 Check that the above definition does not depend on the choice of representative for each equivalence class\n\n\n\n\n\n\nIf \\(\\mathcal{U}\\) is an ultrafilter on \\(I\\), the reduced product \\[\n\\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\n\\] is called the ultraproduct of \\((\\mathcal{M}_i)_{i \\in I}\\) modulo \\(\\mathcal{U}\\).\nWhen all \\(\\mathcal{M}_i\\) are the same structure \\(\\mathcal{M}\\), we get an ultrapower \\[\n\\mathcal{M}^I / \\mathcal{U}.\n\\]",
    "crumbs": [
      "10/8 - Ultraproducts"
    ]
  },
  {
    "objectID": "016_Oct08_ultraproducts.html#łoś-theorem",
    "href": "016_Oct08_ultraproducts.html#łoś-theorem",
    "title": "Math 557 Oct 8",
    "section": "",
    "text": "Let \\(\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\\) be an ultraproduct.\n\n\n\n\n\n\n\nTheorem 2 \nFor every \\(\\mathcal{L}\\)-formula \\(\\varphi(x_1,\\dots,x_n)\\) and tuples\n\\(\\vec a \\in \\prod_{i \\in I} M_i\\), \\[\n\\mathcal{M}/\\mathcal{U} \\models \\varphi[\\vec a_{\\mathcal{U}}]\n\\iff\n\\{\\, i \\in I : \\mathcal{M}_i \\models \\varphi[\\vec a_i]\\,\\} \\in \\mathcal{U}.\n\\]\n\n\n\n\nFor any \\(\\mathcal{L}\\)-formula \\(\\varphi(v_0,\\ldots,v_{n-1})\\) a a tuple \\(\\vec{a} \\in \\prod M_i\\) we define the Boolean extension as \\[\n\\|\\varphi(\\vec{a}) \\| := \\{i \\in I| \\mathcal{M}_i \\models \\varphi[\\vec{a}_i]\\}\n\\]\n\n\n\n\n\n\n\nLemma 1  \n\n\\(\\| \\neg \\varphi(\\vec{a}) \\| = I \\backslash \\|\\varphi(\\vec{a}) \\|\\),\n\\(\\| (\\varphi \\wedge \\psi)(\\vec{a}) \\| =\\| \\varphi(\\vec{a}) \\| \\cap \\| \\psi(\\vec{a}) \\|\\),\n\\(\\| (\\varphi \\vee \\psi)(\\vec{a}) \\| =\\| \\varphi(\\vec{a}) \\| \\cup \\| \\psi(\\vec{a}) \\|\\),\nFor all tuples \\(\\vec{a}\\) and elements \\(b\\) in \\(A\\): \\[\n\\|\\varphi(\\vec{a},b) \\| \\subseteq \\| (\\exists v_n \\varphi)(\\vec{a}) \\|,\n\\] and there exists \\(b \\in M\\) such that \\[\n\\|\\varphi(\\vec{a},b) \\| = \\| (\\exists v_n \\varphi)(\\vec{a}) \\|.\n\\]\n\n\n\n\n\n\nProof. (1)-(3) and the first part of (4) follow directly from the definition of ultrafilters (and the definition of \\(\\models\\)).\nFor the second part of (4), we observe that for every \\[\ni \\in \\| (\\exists v_n \\varphi)(\\vec{a}) \\|\n\\] there exists \\(b_i \\in A_i\\) with \\(\\mathcal{M}_i \\models \\varphi[\\vec{a}_i,b_i]\\). For all other \\(j \\in I \\setminus \\| (\\exists v_n \\varphi)(\\vec{a}) \\|\\) we choose an aribitrary \\(b_j \\in A_j\\). This yields a sequence \\(b = (b_i)_{i\\in I}\\) with \\(b \\in M\\), for which \\[\n\\| (\\exists v_n \\varphi)(\\vec{a}) \\| \\subseteq \\|\\varphi(\\vec{a},b) \\|.\n\\] Together with the first part we obtain \\(=\\).\n\n\n\nWe proceed by induction over the formula height. A straightforward argument shows that the interpretation of functions and symbols in \\(\\mathcal{M}\\) extends to terms in the following way: \\[\nt^{\\mathcal{M}/\\mathcal{U}}(\\vec{a}/U) = (t^{\\mathcal{M}_i}(\\vec{a}_i))_{i \\in I}/\\mathcal{U} = t^{\\mathcal{M}}(\\vec{a})/\\mathcal{U}\n\\] This easily implies the statement for atomic formulas.\nFor \\(\\varphi \\equiv \\neg \\psi\\), we have \\[\n\\begin{aligned}\n\\mathcal{M}/\\mathcal{U} \\models \\neg \\psi[\\vec{a}_{\\mathcal{U}}]\n&\\iff \\mathcal{M}/\\mathcal{U} \\not\\models \\psi[\\vec{a}_{\\mathcal{U}}] \\\\[6pt]\n&\\iff \\{\\, i : \\mathcal{M}_i \\models \\psi[\\vec{a}_i] \\,\\} \\notin \\mathcal{U}\n&& \\text{(I.H.)} \\\\[6pt]\n&\\iff \\| \\psi(\\vec{a}) \\| \\notin \\mathcal{U} \\\\[6pt]\n&\\iff \\neg \\| \\psi(\\vec{a}) \\| \\in \\mathcal{U}\n&& (\\mathcal{U}\\ \\text{is an ultrafilter}) \\\\[6pt]\n&\\iff \\| \\neg \\psi(\\vec{a}) \\| \\in \\mathcal{U}\n&& \\text{(Lemma (i))} \\\\[6pt]\n&\\iff \\{\\, i : \\mathcal{M}_i \\models \\neg \\psi[\\vec{a}_i] \\,\\} \\in \\mathcal{U}.\n\\end{aligned}\n\\]\nThe case \\(\\varphi \\equiv (\\psi \\land \\theta)\\) is similar.\nFinally, assume \\(\\varphi \\equiv \\exists y \\psi\\). Then \\[\n\\begin{aligned}\n\\mathcal{M}/\\mathcal{U} \\models \\exists y\\, \\psi[\\vec{a}_{\\mathcal{U}}]\n&\\iff \\exists b_{\\mathcal{U}} \\in \\mathcal{M}/\\mathcal{U} \\text{ such that }\n   \\mathcal{M}/\\mathcal{U} \\models \\psi[\\vec{a}_{\\mathcal{U}}, b_{\\mathcal{U}}] \\\\[6pt]\n&\\iff \\exists b \\in M \\text{ such that }\n   \\{\\, i : \\mathcal{M}_i \\models \\psi[\\vec{a}_i, b_i] \\,\\} \\in \\mathcal{U}\n   && \\text{(I.H.)} \\\\[6pt]\n&\\iff \\exists b \\in M \\text{ such that } \\|\\psi(\\vec{a}, b)\\| \\in \\mathcal{U} \\\\[6pt]\n&\\iff \\|\\exists y\\, \\psi(\\vec{a})\\| \\in \\mathcal{U}\n   && (\\mathcal{U}\\ \\text{ultrafilter, Lemma (4)}) \\\\[6pt]\n&\\iff \\{\\, i : \\mathcal{M}_i \\models \\exists y\\, \\psi[\\vec{a}_i] \\,\\} \\in \\mathcal{U}.\n\\end{aligned}\n\\]\nThis completes the proof.",
    "crumbs": [
      "10/8 - Ultraproducts"
    ]
  },
  {
    "objectID": "016_Oct08_ultraproducts.html#applications",
    "href": "016_Oct08_ultraproducts.html#applications",
    "title": "Math 557 Oct 8",
    "section": "",
    "text": "Preservation of theories:\nIf each \\(\\mathcal{M}_i \\models T\\), then \\(\\prod_i \\mathcal{M}_i / \\mathcal{U} \\models T\\).\nUltrapowers:\n\\(\\mathcal{M} \\equiv \\mathcal{M}^I / \\mathcal{U}\\), i.e., a structure is elementarily equivalent to any of its ultrapowers.\nNonstandard models:\nFor example, the ultrapower \\(\\mathbb{N}^{\\mathbb{N}}/\\mathcal{U}\\) (with \\(\\mathcal{U}\\) non-principal) yields a countably saturated nonstandard model of arithmetic.\n\n\n\nSuppose \\(T\\) is an \\(\\mathcal{L}\\)-theory for which every finite subset \\(\\Delta\\) has a model \\(\\mathcal{M}_\\Delta\\).\nLet \\(I = \\{\\Delta : \\Delta \\subseteq T \\text{ finite}\\}\\).\nFor \\(\\sigma \\in T\\), let \\[\n\\begin{aligned}\n\\hat{\\sigma} & = \\{\\Delta \\in I : \\sigma \\in \\Delta\\} \\subseteq I \\\\\nE & = \\{\\hat{\\sigma} : \\sigma \\in T\\} \\subseteq \\mathcal{P}(I) \\\\\n\\end{aligned}\n\\]\n\\(E\\) has FIP (finite intersection property), since for \\(\\hat{S}_1, \\ldots, \\hat{S}_n \\in E\\), \\[\n\\{\\hat{\\sigma}_1, \\ldots, \\hat{\\sigma}_n\\} \\in \\hat{\\sigma}_1 \\cap \\cdots \\cap \\hat{\\sigma}_n.\n\\]\nBy Theorem 1, \\(E\\) can be extended to an ultrafilter \\(\\mathcal{U}\\) on \\(I\\).\nClaim: \\(\\mathcal{M}/\\mathcal{U} = \\prod_{\\Delta \\in I} \\mathcal{M}_\\Delta / \\mathcal{U} \\models T\\).\nLet \\(\\sigma \\in T\\). Then for \\(\\Delta \\in I\\), \\[\n\\Delta \\in \\hat{\\sigma} \\; \\Rightarrow \\; \\sigma \\in \\Delta \\; \\Rightarrow \\; \\mathcal{M}_\\Delta \\models \\sigma\n\\]\nHence \\[\n\\hat{\\sigma} \\subseteq \\{\\Delta \\in I : \\mathcal{M}_\\Delta \\models \\sigma\\}\n\\]\nSince \\(\\hat{\\sigma} \\in E\\) and \\(E \\subseteq \\mathcal{U}\\), we have \\(\\hat{\\sigma} \\in \\mathcal{U}\\), which implies \\[\n\\{\\Delta \\in I : \\mathcal{M}_\\Delta \\models \\sigma\\} \\in \\mathcal{U}\n\\]\nBy Łoś’ Theorem, \\(\\mathcal{M} \\models \\sigma\\).",
    "crumbs": [
      "10/8 - Ultraproducts"
    ]
  },
  {
    "objectID": "013_Oct01_elementary_equivalence.html",
    "href": "013_Oct01_elementary_equivalence.html",
    "title": "Math 557 Oct 1",
    "section": "",
    "text": "Two \\(\\mathcal{L}\\)-structures are elementary equivalent if for all \\(\\mathcal{L}\\)-sentences \\(\\sigma\\), \\[\\mathcal{M} \\models \\sigma \\; \\iff \\; \\mathcal{N} \\models \\sigma\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 \nShow that for any two \\(\\mathcal{L}\\)-structures \\(\\mathcal{M}, \\mathcal{N}\\), \\[\n\\mathcal{M}\\equiv \\mathcal{N} \\; \\iff \\; \\operatorname{Th}(\\mathcal{M}) = \\operatorname{Th}(\\mathcal{N}).\n\\]\nDeduce that a theory \\(T\\) is complete iff any two models are elementary equivalent.\n\n\n\n\n\n\n\n\n\n\nTake-home problem\n\n\n\n\nLet \\(\\mathcal{L}\\) be an arbitrary language. Show that for finite \\(\\mathcal{L}\\)-structures \\(\\mathcal{M}, \\mathcal{N}\\),\n\\[\n\\mathcal{M} \\equiv \\mathcal{N} \\; \\iff \\; \\mathcal{M} \\cong \\mathcal{N}\n\\]\nWe already know this for finite languages (since in this case a single sentence can force isomorphism). How can we extend this to arbitrary languages?\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nLet \\(\\operatorname{DLO}\\) be the theory of dense linear orders without endpoints (i.e. no minimal or maximal element) in the language \\(\\mathcal{L}_{&lt;}=\\{&lt;\\}\\) of orders.\nFind a finite axiomatization of \\(\\operatorname{DLO}\\), as well as a model.\n\n\n\n\n\\(\\operatorname{DLO}\\) is going to be an important example for us. In many ways, it exemplifies what an “easy” mathematical theory looks like. We will make this precise over the coming weeks. We start with the observation that there cannot be any “non-standard” countable models.\n\n\n\n\n\n\n\nExercise 3 \nShow that any two countable models of \\(\\operatorname{DLO}\\) are isomorphic.\nThis is a famous result due to Cantor. For the proof, think “back and forth”.",
    "crumbs": [
      "10/1 - Elementary equivalence"
    ]
  },
  {
    "objectID": "013_Oct01_elementary_equivalence.html#key-concepts",
    "href": "013_Oct01_elementary_equivalence.html#key-concepts",
    "title": "Math 557 Oct 1",
    "section": "",
    "text": "Two \\(\\mathcal{L}\\)-structures are elementary equivalent if for all \\(\\mathcal{L}\\)-sentences \\(\\sigma\\), \\[\\mathcal{M} \\models \\sigma \\; \\iff \\; \\mathcal{N} \\models \\sigma\\]",
    "crumbs": [
      "10/1 - Elementary equivalence"
    ]
  },
  {
    "objectID": "013_Oct01_elementary_equivalence.html#problems",
    "href": "013_Oct01_elementary_equivalence.html#problems",
    "title": "Math 557 Oct 1",
    "section": "",
    "text": "Exercise 1 \nShow that for any two \\(\\mathcal{L}\\)-structures \\(\\mathcal{M}, \\mathcal{N}\\), \\[\n\\mathcal{M}\\equiv \\mathcal{N} \\; \\iff \\; \\operatorname{Th}(\\mathcal{M}) = \\operatorname{Th}(\\mathcal{N}).\n\\]\nDeduce that a theory \\(T\\) is complete iff any two models are elementary equivalent.\n\n\n\n\n\n\n\n\n\n\nTake-home problem\n\n\n\n\nLet \\(\\mathcal{L}\\) be an arbitrary language. Show that for finite \\(\\mathcal{L}\\)-structures \\(\\mathcal{M}, \\mathcal{N}\\),\n\\[\n\\mathcal{M} \\equiv \\mathcal{N} \\; \\iff \\; \\mathcal{M} \\cong \\mathcal{N}\n\\]\nWe already know this for finite languages (since in this case a single sentence can force isomorphism). How can we extend this to arbitrary languages?\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nLet \\(\\operatorname{DLO}\\) be the theory of dense linear orders without endpoints (i.e. no minimal or maximal element) in the language \\(\\mathcal{L}_{&lt;}=\\{&lt;\\}\\) of orders.\nFind a finite axiomatization of \\(\\operatorname{DLO}\\), as well as a model.\n\n\n\n\n\\(\\operatorname{DLO}\\) is going to be an important example for us. In many ways, it exemplifies what an “easy” mathematical theory looks like. We will make this precise over the coming weeks. We start with the observation that there cannot be any “non-standard” countable models.\n\n\n\n\n\n\n\nExercise 3 \nShow that any two countable models of \\(\\operatorname{DLO}\\) are isomorphic.\nThis is a famous result due to Cantor. For the proof, think “back and forth”.",
    "crumbs": [
      "10/1 - Elementary equivalence"
    ]
  },
  {
    "objectID": "020_Oct17_random_graphs.html",
    "href": "020_Oct17_random_graphs.html",
    "title": "MATH 557 Oct 17",
    "section": "",
    "text": "To simplify things, we state everything in the context of a finite language that contains only constants and relations. In this case finitely generated is equivalent to finite.\n\n\\(\\mathcal{M}\\) is homogeneous if any isomorphism between finite substructures of \\(\\mathcal{M}\\) can be extended to an automorphism of \\(\\mathcal{M}\\).\n\\(\\mathrm{age}(\\mathcal{M})\\) is the class of all finite \\(\\mathcal{L}\\)-structures isomorphic to a substructure of \\(\\mathcal{M}\\).\nAny two countable homogeneous structures with the same age are isomorphic.\nA class of finite structures \\(\\overline{K}\\) is an amalgamation class if it satisfies (HP), (JEP), and (AP). In words, every substructure of a structure in \\(\\overline{K}\\) is in \\(\\overline{K}\\), any two structures in \\(\\overline{K}\\) embed into another structure from \\(\\overline{K}\\), and any two structures with a common substructure (up to isomorphism) amalgamate to another structure that preserves the common substructure.\nFraïssé’s Theorem: Suppose \\(\\overline{K}\\) is a class of finite \\(\\mathcal{L}\\)-structures such that there are only countably many isomorphism types in \\(\\overline{K}\\). Then \\(\\overline{K}\\) is an amalgamation class iff \\(\\overline{K}\\) is the age of a countable homogeneous \\(\\mathcal{L}\\)-structure.\n\n\n\n\nWe consider the theory of undirected graphs without self-loops, also called simple graphs. Let \\(\\mathcal{L}_G = \\{E\\}\\) be the language of graphs with one binary relation symbol \\(E\\).\nSimple graphs are formalized by the axioms\n\n\\(\\forall x \\neg E(x,x)\\)\n\\(\\forall x, y \\: (E(x,y) \\to E(y,x))\\)\n\nWe denote the theory of simple graphs by \\(T_{G}\\)\n\n\n\n\n\n\n\nExercise 1 Verify that \\[\n\\overline{K} = \\{\\mathcal{G} : \\mathcal{G} \\models T_G, \\mathcal{G} \\text{ finite}\\}\n\\] is an amalgamation class with countably many isomorphism types.\n\n\n\n\nIt follows that \\(\\overline{K}\\) has a Fraïssé limit. What does this limit look like?\n\n\n\nWe add the following extension axioms:\n\\[\n\\sigma_{n,m} \\equiv \\forall x_1, \\dots, x_n \\forall y_1, \\dots, y_m \\; \\left ( \\bigwedge_{i=1}^n \\bigwedge_{j = 1}^m x_i \\neq y_j \\; \\to \\; \\exists z \\: \\bigl ( \\bigwedge_{i=1}^n (z \\neq  x_i \\land E(z,x_i) ) \\land \\bigwedge_{j = 1}^m (z \\neq y_j \\land \\neg E(z, y_j)) \\bigr ) \\right )\n\\]\nLet \\[\nT_{RG} = T_G \\cup \\{ \\exists x,y \\: (x \\neq y) \\} \\cup \\{ \\sigma_{n,m} : n, m \\geq 1 \\}\n\\]\n\n\n\n\n\n\n\nExercise 2 Show that every countable model of \\(T_{RG}\\) is homogeneous.\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 Show that if \\(\\mathcal{R}\\) is a model of \\(T_{RG}\\), \\(\\operatorname{age}(\\mathcal{R}) = \\overline{K}\\).\n\n\n\n\nIt follows from Fraïssé’s Theorem that \\(T_{RG}\\) has a countable model \\(\\mathcal{R}\\), and that this model is unique up to isomorphism.\n\n\n\n\n\n\n\nExercise 4 Show that \\(T_{RG}\\) is complete.\n\n\n\n\n\\(\\mathcal{R}\\) is called the random graph and \\(T_{RG}\\) the theory of the random graph. Why? Let \\(G_N\\) be the set of all simple graphs on the vertex set \\(\\{1, \\dots, N\\}\\). Put a probability distribution on \\(G_N\\) by giving every graph the same probability. (Alternatively, we could independently assign edges to any vertex pair with probability \\(1/2\\). This is called the Erdös-Renyi model.) Given an \\(\\mathcal{L}_G\\)-sentence \\(\\sigma\\), let \\(\\mathbb{P}_N(\\sigma)\\) be the probability that \\(\\sigma\\) holds for a random graph in \\(G_N\\), i.e.\n\\[\n\\mathbb{P}_N(\\sigma)=  \\frac{|\\{ \\mathcal{G} \\in G_N : \\mathcal{G} \\models \\sigma\\}|}{|G_N|}.\n\\]\nIt turns out, for large \\(N\\), graphs will satisfy the extension axioms with high probability.\n\n\n\n\n\n\n\nExercise 5 Show that for any \\(n, m \\geq 1\\),\n\\[\n\\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma_{n,m}) = 1.\n\\]\n\n\n\n\nThis justifies referring to \\(\\mathcal{R}\\) as the random graph, since it can be seen as the “limit” of finite random graphs.\n\n\n\n\n\n\n\n\n\n\n\n\nTheorem 1 For any \\(\\mathcal{L}_G\\)-sentence \\(\\sigma\\),\n\\[\n\\text{either } \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 0 \\text{ or } \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 1.\n\\] Moreover, \\(T_{RG}\\) axiomatizes the theory \\[\n\\{ \\sigma : \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 1 \\}\n\\] and this theory is complete.\n\n\n\n\nTo prove the theorem, use that \\(T_{RG}\\) is complete together with Exercise 5. Give it a try!\n\n\n\nThere are other classes of structures that are amalgamation classes, for example:\n\nfinite fields of characteristic \\(p\\)\nfinite groups\n(non-trivial) finite Boolean algebras\n\nWhat kind of object is the Fraïssé limit in each case?",
    "crumbs": [
      "10/17 - Random graphs"
    ]
  },
  {
    "objectID": "020_Oct17_random_graphs.html#key-facts-from-fräissé-theory",
    "href": "020_Oct17_random_graphs.html#key-facts-from-fräissé-theory",
    "title": "MATH 557 Oct 17",
    "section": "",
    "text": "To simplify things, we state everything in the context of a finite language that contains only constants and relations. In this case finitely generated is equivalent to finite.\n\n\\(\\mathcal{M}\\) is homogeneous if any isomorphism between finite substructures of \\(\\mathcal{M}\\) can be extended to an automorphism of \\(\\mathcal{M}\\).\n\\(\\mathrm{age}(\\mathcal{M})\\) is the class of all finite \\(\\mathcal{L}\\)-structures isomorphic to a substructure of \\(\\mathcal{M}\\).\nAny two countable homogeneous structures with the same age are isomorphic.\nA class of finite structures \\(\\overline{K}\\) is an amalgamation class if it satisfies (HP), (JEP), and (AP). In words, every substructure of a structure in \\(\\overline{K}\\) is in \\(\\overline{K}\\), any two structures in \\(\\overline{K}\\) embed into another structure from \\(\\overline{K}\\), and any two structures with a common substructure (up to isomorphism) amalgamate to another structure that preserves the common substructure.\nFraïssé’s Theorem: Suppose \\(\\overline{K}\\) is a class of finite \\(\\mathcal{L}\\)-structures such that there are only countably many isomorphism types in \\(\\overline{K}\\). Then \\(\\overline{K}\\) is an amalgamation class iff \\(\\overline{K}\\) is the age of a countable homogeneous \\(\\mathcal{L}\\)-structure.",
    "crumbs": [
      "10/17 - Random graphs"
    ]
  },
  {
    "objectID": "020_Oct17_random_graphs.html#simple-graphs",
    "href": "020_Oct17_random_graphs.html#simple-graphs",
    "title": "MATH 557 Oct 17",
    "section": "",
    "text": "We consider the theory of undirected graphs without self-loops, also called simple graphs. Let \\(\\mathcal{L}_G = \\{E\\}\\) be the language of graphs with one binary relation symbol \\(E\\).\nSimple graphs are formalized by the axioms\n\n\\(\\forall x \\neg E(x,x)\\)\n\\(\\forall x, y \\: (E(x,y) \\to E(y,x))\\)\n\nWe denote the theory of simple graphs by \\(T_{G}\\)\n\n\n\n\n\n\n\nExercise 1 Verify that \\[\n\\overline{K} = \\{\\mathcal{G} : \\mathcal{G} \\models T_G, \\mathcal{G} \\text{ finite}\\}\n\\] is an amalgamation class with countably many isomorphism types.\n\n\n\n\nIt follows that \\(\\overline{K}\\) has a Fraïssé limit. What does this limit look like?",
    "crumbs": [
      "10/17 - Random graphs"
    ]
  },
  {
    "objectID": "020_Oct17_random_graphs.html#random-graphs",
    "href": "020_Oct17_random_graphs.html#random-graphs",
    "title": "MATH 557 Oct 17",
    "section": "",
    "text": "We add the following extension axioms:\n\\[\n\\sigma_{n,m} \\equiv \\forall x_1, \\dots, x_n \\forall y_1, \\dots, y_m \\; \\left ( \\bigwedge_{i=1}^n \\bigwedge_{j = 1}^m x_i \\neq y_j \\; \\to \\; \\exists z \\: \\bigl ( \\bigwedge_{i=1}^n (z \\neq  x_i \\land E(z,x_i) ) \\land \\bigwedge_{j = 1}^m (z \\neq y_j \\land \\neg E(z, y_j)) \\bigr ) \\right )\n\\]\nLet \\[\nT_{RG} = T_G \\cup \\{ \\exists x,y \\: (x \\neq y) \\} \\cup \\{ \\sigma_{n,m} : n, m \\geq 1 \\}\n\\]\n\n\n\n\n\n\n\nExercise 2 Show that every countable model of \\(T_{RG}\\) is homogeneous.\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 Show that if \\(\\mathcal{R}\\) is a model of \\(T_{RG}\\), \\(\\operatorname{age}(\\mathcal{R}) = \\overline{K}\\).\n\n\n\n\nIt follows from Fraïssé’s Theorem that \\(T_{RG}\\) has a countable model \\(\\mathcal{R}\\), and that this model is unique up to isomorphism.\n\n\n\n\n\n\n\nExercise 4 Show that \\(T_{RG}\\) is complete.\n\n\n\n\n\\(\\mathcal{R}\\) is called the random graph and \\(T_{RG}\\) the theory of the random graph. Why? Let \\(G_N\\) be the set of all simple graphs on the vertex set \\(\\{1, \\dots, N\\}\\). Put a probability distribution on \\(G_N\\) by giving every graph the same probability. (Alternatively, we could independently assign edges to any vertex pair with probability \\(1/2\\). This is called the Erdös-Renyi model.) Given an \\(\\mathcal{L}_G\\)-sentence \\(\\sigma\\), let \\(\\mathbb{P}_N(\\sigma)\\) be the probability that \\(\\sigma\\) holds for a random graph in \\(G_N\\), i.e.\n\\[\n\\mathbb{P}_N(\\sigma)=  \\frac{|\\{ \\mathcal{G} \\in G_N : \\mathcal{G} \\models \\sigma\\}|}{|G_N|}.\n\\]\nIt turns out, for large \\(N\\), graphs will satisfy the extension axioms with high probability.\n\n\n\n\n\n\n\nExercise 5 Show that for any \\(n, m \\geq 1\\),\n\\[\n\\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma_{n,m}) = 1.\n\\]\n\n\n\n\nThis justifies referring to \\(\\mathcal{R}\\) as the random graph, since it can be seen as the “limit” of finite random graphs.",
    "crumbs": [
      "10/17 - Random graphs"
    ]
  },
  {
    "objectID": "020_Oct17_random_graphs.html#further-explorations",
    "href": "020_Oct17_random_graphs.html#further-explorations",
    "title": "MATH 557 Oct 17",
    "section": "",
    "text": "Theorem 1 For any \\(\\mathcal{L}_G\\)-sentence \\(\\sigma\\),\n\\[\n\\text{either } \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 0 \\text{ or } \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 1.\n\\] Moreover, \\(T_{RG}\\) axiomatizes the theory \\[\n\\{ \\sigma : \\lim_{N \\to \\infty} \\mathbb{P}_N(\\sigma) = 1 \\}\n\\] and this theory is complete.\n\n\n\n\nTo prove the theorem, use that \\(T_{RG}\\) is complete together with Exercise 5. Give it a try!\n\n\n\nThere are other classes of structures that are amalgamation classes, for example:\n\nfinite fields of characteristic \\(p\\)\nfinite groups\n(non-trivial) finite Boolean algebras\n\nWhat kind of object is the Fraïssé limit in each case?",
    "crumbs": [
      "10/17 - Random graphs"
    ]
  },
  {
    "objectID": "028_Nov10_representability.html",
    "href": "028_Nov10_representability.html",
    "title": "Math 557 Nov 12",
    "section": "",
    "text": "Representability\nWe have established a closed connection between computability and definability over \\(\\mathbb{N}\\), but how much of that can \\(\\mathsf{PA}^-\\) actually prove? We need to make sure it can represent sufficiently simple (i.e., computable) functions and sets faithfully.\n\n\n\n\n\n\n\nDefinition 1 Let \\(T\\) be a theory in the language of arithmetic \\(L\\) that extends \\(\\mathsf{PA}^-\\). A (total) function \\(f: \\mathbb{N}^k \\to \\mathbb{N}\\) is representable in \\(T\\) iff there exists an \\(L\\)-formula \\(\\theta(x_1,\\ldots,x_k,y)\\) such that for all \\(n_1,\\ldots,n_k ,m \\in \\mathbb{N}\\):\n\n(a) \\(T \\vdash \\exists! y \\; \\theta(\\underline{n_1},\\ldots,\\underline{n_k},y)\\), and\n(b) \\(f(n_1,\\ldots,n_k)= m \\Rightarrow T \\vdash \\theta(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m})\\).\n\nSimilarly, a set \\(S \\subseteq \\mathbb{N}^k\\) is representable in the theory \\(T\\) iff there exists an \\(L\\)-formula \\(\\theta(x_1,\\ldots,x_k)\\) such that for all \\(n_1,\\ldots,n_k \\in \\mathbb{N}\\):\n\n(c) \\((n_1,\\ldots,n_k) \\in S \\Rightarrow T \\vdash \\theta(\\underline{n_1},\\ldots,\\underline{n_k})\\), and\n(d) \\((n_1,\\ldots,n_k) \\not \\in S \\Rightarrow T \\vdash \\neg \\theta(\\underline{n_1},\\ldots,\\underline{n_k})\\).\n\n\n\n\n\nIf the function \\(f\\) (or the set \\(S\\)) is representable by a \\(\\Sigma_1\\)-formula, then \\(f\\) (or \\(S\\), respectively) is called \\(\\Sigma_1\\)-representable.\nNote that by definition, representability is preserved when we pass to a theory \\(T' \\supseteq T\\).\n\n\n\n\n\n\n\nTheorem 1 (Represetation Theorem)  \n\nEvery recursive function \\(f: \\mathbb{N}^k \\to \\mathbb{N}\\) is \\(\\Sigma_1\\)-representable in \\(\\mathsf{PA}^-\\).\nEvery recursive set \\(S \\subseteq \\mathbb{N}^k\\) is \\(\\Sigma_1\\)-representable in \\(\\mathsf{PA}^-\\).\n\n\n\n\n\n\nProof. (i) Let \\(f: \\mathbb{N}^k \\to \\mathbb{N}\\) be a recursive function, so its graph \\(\\Gamma_f\\) is definable over the natural numbers by a \\(\\Sigma_1\\)-formula \\(\\exists \\vec{z} \\; \\varphi(\\vec{x},y, \\vec{z})\\), where \\(\\varphi\\) has only bounded quantifiers. Since every formula of the form \\(\\exists \\vec{z} \\; \\varphi\\) is equivalent in \\(\\mathsf{PA}^-\\) to \\(\\exists u \\; \\exists \\vec{z} \\; ( \\vec{z} &lt; u \\wedge \\varphi)\\), we may assume that \\(\\vec{z}\\) is just a single variable \\(z\\). We now form the \\(\\Delta_0\\)-formula \\(\\psi(\\vec{x},y, z)\\):\n\\[\n\\varphi(\\vec{x},y, z) \\wedge \\forall u,v \\leq y+z \\; (u+v &lt; y+z \\to \\neg \\varphi(\\vec{x},u, v)).\n\\]\nWe now claim that the \\(\\Sigma_1\\)-formula \\(\\exists z \\; \\psi(\\vec{x},y, z)\\) represents the function \\(f\\) in \\(\\mathsf{PA}^-\\):\nFirst we show (b). Assume that \\(f(n_1,\\ldots,n_k)= m\\) holds, thus \\(\\mathbb{N} \\models \\exists z \\; \\varphi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},z)\\). The number \\(m\\) is uniquely determined since \\(f\\) is a function. Choose \\(l\\) as the smallest number such that \\(\\mathbb{N} \\models \\varphi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{l})\\). Then clearly \\(\\mathbb{N} \\models \\psi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{l})\\) also holds, and thus \\(\\mathbb{N} \\models \\exists z \\; \\psi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{z})\\). As a \\(\\Sigma_1\\)-sentence, this sentence is preserved under all end extensions of the standard model to a model of \\(\\mathsf{PA}^-\\), thus it holds in all models of \\(\\mathsf{PA}^-\\), and therefore \\(\\mathsf{PA}^- \\vdash \\exists z \\; \\psi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{z})\\) by the Completeness Theorem.\nThe proof of (a) uses a similar argument: Let \\(f(n_1,\\ldots,n_k)= m\\) and let \\(l\\) again be the smallest number such that \\(\\mathbb{N} \\models \\psi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{l})\\) holds. Let \\(\\mathcal{M} \\models \\mathsf{PA}^-\\). We claim that \\(m\\) is the only element of \\(M\\) that satisfies the formula \\(\\psi(\\underline{n_1},\\ldots,\\underline{n_k},x,\\underline{l})\\) in \\(\\mathcal{M}\\). \\(\\mathcal{M} \\models \\psi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{l})\\) due to the absoluteness of \\(\\Delta_0\\)-formulas. If \\(a,b \\in M\\) are two elements such that \\(\\mathcal{M} \\models \\psi(\\underline{n_1},\\ldots,\\underline{n_k},a,b)\\), then we must have \\(a,b \\le m+l\\): For if one of them were greater than \\(m+l\\), we would also have \\(a+b &gt; m+l\\). We assumed\n\\[\\mathcal{M} \\models \\psi(\\underline{n_1},\\ldots,\\underline{n_k},a,b),\\]\nso by definition of \\(\\psi\\) we have\n\\[\n\\mathcal{M} \\models \\varphi(\\underline{n_1},\\ldots,\\underline{n_k},a,b) \\wedge \\forall u,v \\leq a+b \\; (u+v &lt; a+b \\to \\neg \\varphi(\\underline{n_1},\\ldots,\\underline{n_k},u, v)).\n\\]\nBut since \\(m+l &lt; a+b\\), this would imply \\(\\neg \\varphi(\\underline{n_1},\\ldots,\\underline{n_k},\\underline{m},\\underline{l})\\) in \\(\\mathcal{M}\\), contradicting the choice of \\(m\\) and \\(l\\).\nAs \\(\\mathcal{M}\\) is an end-extension of \\(\\mathbb{N}\\), \\(a,b \\le m+l\\) implies \\(a, b \\in \\mathbb{N}\\). Thus, again by the absoluteness of \\(\\Delta_0\\)-formulas, we have \\(\\mathbb{N} \\models \\psi(\\underline{n_1},\\ldots,\\underline{n_k},a,b)\\), from which \\(\\mathbb{N} \\models \\exists z \\; \\psi(\\underline{n_1},\\ldots,\\underline{n_k},a,z)\\) follows, and therefore \\(a = m\\).\n(ii) now follows easily: If \\(S\\) is recursive, then the characteristic function \\(c_S\\) is computable, thus by (i) represented by a \\(\\Sigma_1\\)-formula \\(\\theta(\\vec{x},y)\\) in \\(\\mathsf{PA}^-\\). Then \\(S\\) is represented by the formula \\(\\theta(\\vec{x},1)\\), since we have:\n\\[\n\\mathsf{PA}^- \\vdash \\neg \\theta(\\vec{x},1) \\iff \\mathsf{PA}^- \\vdash \\theta(\\vec{x},0).\n\\]",
    "crumbs": [
      "11/12 - Representability"
    ]
  },
  {
    "objectID": "025_Nov3_end_extensions.html",
    "href": "025_Nov3_end_extensions.html",
    "title": "Math 557 Nov 3",
    "section": "",
    "text": "The standard model can be embedded into every model \\(\\mathcal{M}\\) of \\(\\mathsf{PA}\\) as an initial segment. It turns out this already holds for models of the theory \\(\\mathsf{PA}^-\\).\n\n\n\n\n\n\n\nDefinition 1 \nLet \\(L\\) be a language containing a 2-ary symbol \\(&lt;\\), and let \\(\\mathcal{M}\\) and \\(\\mathcal{N}\\) be \\(L\\)-structures with \\(\\mathcal{M} \\subseteq \\mathcal{N}\\). Then \\(\\mathcal{N}\\) is called an end extension of \\(\\mathcal{M}\\) (and correspondingly \\(\\mathcal{M}\\) is an initial segment of \\(\\mathcal{N}\\)) if and only if the larger set \\(N\\) does not add any further elements below an element of \\(M\\): \\[\n\\mathcal{M} \\subseteq_{end} \\mathcal{N}: \\iff \\text{for all} \\; x \\in M,y \\in N: (y&lt;^N x \\Rightarrow y \\in M).\n\\]\n\n\n\n\nEach natural number \\(n\\) is represented in the standard model, which we also simply denote by \\(\\mathbb{N}\\) here, by the constant term \\[\n\\underline{n} = 1+ \\ldots + 1 \\quad \\text{($n$ times)}\n\\] where \\(\\underline{0}\\) is the constant \\(0\\).\n\n\n\n\n\n\n\nTheorem 1 \nLet \\(\\mathcal{M} \\models \\mathsf{PA}^-\\). Then the map \\[n \\mapsto \\underline{n}^{\\mathcal{M}}\\] defines an embedding of the standard model \\(\\mathbb{N}\\) onto an initial segment of \\(\\mathcal{M}\\).\nIn particular, every model of \\(\\mathsf{PA}^-\\) is isomorphic to an end extension of the standard model \\(\\mathbb{N}\\).*\n\n\n\n\n\nProof. By simple induction (in the meta-theory), one shows for all natural numbers \\(n,k,l\\): \\[\n\\begin{aligned}\nn = k+l & \\quad \\Longrightarrow \\quad \\mathsf{PA}^- \\vdash \\underline{n}= \\underline{k}+ \\underline{l} \\\\\nn = k \\cdot l & \\quad \\Longrightarrow \\quad \\mathsf{PA}^- \\vdash \\underline{n}= \\underline{k} \\cdot \\underline{l} \\\\\nn &lt; k& \\quad \\Longrightarrow \\quad  \\mathsf{PA}^- \\vdash \\underline{n} &lt; \\underline{k}\\\\\n\\end{aligned}\n\\] and \\[\n\\mathsf{PA}^- \\vdash \\forall x \\:(x \\le  \\underline{k} \\to  (x = \\underline{0} \\; \\vee \\ldots \\vee \\; x = \\underline{k})\n\\]\nThe first three statements will later be generalized to all recursive functions and relations; they imply that the map \\(n \\mapsto \\underline{n}^{\\mathcal{M}}\\) is a homomorphism, and, due to the last statement, the map is also an embedding onto an initial segment of \\(\\mathcal{M}\\).\n\n\n\nThe standard model has no proper initial segment, and \\(\\mathbb{Z}[X]^+\\) has \\(\\mathbb{N}\\) as its only proper initial segment. On the other hand, every model \\(\\mathcal{M} \\models \\mathsf{PA}^-\\) has a proper end extension that is also a model of \\(\\mathsf{PA}^-\\), namely the non-negative part of the polynomial ring \\(R[X]\\), where \\(R\\) is the discretely ordered ring associated with the model \\(\\mathcal{M}\\).\n\n\n\nIn the previous lecture, we introduced arithmetical formulas. \\(\\Delta_0\\)-formulas are at the bottom of the arithmetical hierarchy. We already saw that relations defined by such formulas are primitive recursive. Next, we will show that those formulas mean the same thing in a structure as in all end extensions. This will be crucial later on.\n\n\n\n\n\n\n\nTheorem 2 \nLet \\(\\mathcal{N}, \\mathcal{M}\\) be structures of the language \\(L\\) of \\(\\mathsf{PA}^-\\), with \\(\\mathcal{N} \\subseteq_{end} \\mathcal{M}\\), and let \\(\\vec{a} \\in N\\). Then:\n\nEvery \\(\\Delta_0\\)-formula \\(\\varphi(\\vec{v})\\) is absolute: \\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\iff \\mathcal{M}\\models \\varphi[\\vec{a}],\n\\]\nEvery \\(\\Sigma_1\\)-formula \\(\\varphi(\\vec{v})\\) is upward-persistent: \\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\Longrightarrow \\mathcal{M}\\models \\varphi[\\vec{a}],\n\\]\nEvery \\(\\Pi_1\\)-formula \\(\\varphi(\\vec{v})\\) is downward-persistent: \\[\n\\mathcal{M}\\models \\varphi[\\vec{a}] \\Longrightarrow \\mathcal{N}\\models \\varphi[\\vec{a}],\n\\]\nEvery \\(\\Delta_1\\)-formula \\(\\varphi(\\vec{v})\\) is absolute: \\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\iff \\mathcal{M}\\models \\varphi[\\vec{a}].\n\\]\n\n\n\n\n\n\nProof. Part (i) is proved by induction on the formula structure of \\(\\varphi(\\vec{v})\\). Most cases are straightforward (using that \\(\\mathcal{N}\\) is a substructure of \\(\\mathcal{M}\\)). In the case of a bounded quantifier, one argues that, since \\(\\mathcal{M}\\) is an end extension of \\(\\mathcal{N}\\), \\(M\\) does not insert any new elements below an element of \\(N\\), so that a bounded quantifier means the same thing in both structures.\nThe other parts follow easily from the definition of the satisfaction relation \\(\\models\\) and the \\(\\Delta_0\\) case.\n\nLet \\(\\Sigma_1\\)-\\(\\operatorname{Th}(\\mathbb{N}):= \\{\\sigma \\mid \\sigma \\text{ is a } \\Sigma_1\\text{-sentence with } \\mathbb{N} \\models \\sigma \\}\\). Then we have:\n\n\n\n\n\n\n\nCorollary 1 \\[\n\\mathsf{PA}^- \\models \\Sigma_1\\text{-}\\operatorname{Th}(\\mathbb{N})\n\\]\n\n\n\n\n\nProof. Let \\(\\mathcal{N} \\models \\mathsf{PA}^-\\). By Theorem 1, we may assume that \\(\\mathbb{N} \\subseteq_{end} \\mathcal{N}\\), and the claim then follows from part (ii) above.\n\nThus one can prove in the theory \\(\\mathsf{PA}^-\\) all \\(\\Sigma_1\\)-sentences that hold in the standard model. This is no longer true for \\(\\Pi_1\\)-sentences. For instance, the \\(\\Pi_1\\)-sentence stating that every number is even or odd: \\[\n(*) \\quad \\forall x \\;  \\exists y \\le x \\; (x = 2 \\cdot y \\vee x = 2 \\cdot y +1)\n\\] is true in the standard model, but not in the \\(\\mathsf{PA}^-\\)-model \\(\\mathbb{Z}[X]^+\\).\nEven true \\(\\forall\\)-sentences (i.e., sentences of the form \\(\\forall \\vec{x} \\; \\psi\\) with quantifier-free \\(\\psi\\)) that hold in the standard model need not be provable in \\(\\mathsf{PA}^-\\). For example, the \\(\\forall\\)-sentence \\[\n\\forall x,y  (x^2 \\ne 2 \\cdot y^2)\n\\] is true in the standard model, but not provable in \\(\\mathsf{PA}^-\\) (\\(\\mathbb{Z}/(X^2 - 2Y^2)\\) is a counterexample).\nThus the above sentence (*) is an example of a \\(\\Pi_1\\)-sentence that is not a \\(\\forall\\)-sentence, where one cannot omit the bounded quantifier! (By the way, one can show that \\(\\mathbb{Z}[X]^+\\) is at least a model of all \\(\\forall\\)-sentences that hold in the standard model.)",
    "crumbs": [
      "11/3 - End extensions"
    ]
  },
  {
    "objectID": "025_Nov3_end_extensions.html#preservation-properties-of-end-extensions",
    "href": "025_Nov3_end_extensions.html#preservation-properties-of-end-extensions",
    "title": "Math 557 Nov 3",
    "section": "",
    "text": "In the previous lecture, we introduced arithmetical formulas. \\(\\Delta_0\\)-formulas are at the bottom of the arithmetical hierarchy. We already saw that relations defined by such formulas are primitive recursive. Next, we will show that those formulas mean the same thing in a structure as in all end extensions. This will be crucial later on.\n\n\n\n\n\n\n\nTheorem 2 \nLet \\(\\mathcal{N}, \\mathcal{M}\\) be structures of the language \\(L\\) of \\(\\mathsf{PA}^-\\), with \\(\\mathcal{N} \\subseteq_{end} \\mathcal{M}\\), and let \\(\\vec{a} \\in N\\). Then:\n\nEvery \\(\\Delta_0\\)-formula \\(\\varphi(\\vec{v})\\) is absolute: \\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\iff \\mathcal{M}\\models \\varphi[\\vec{a}],\n\\]\nEvery \\(\\Sigma_1\\)-formula \\(\\varphi(\\vec{v})\\) is upward-persistent: \\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\Longrightarrow \\mathcal{M}\\models \\varphi[\\vec{a}],\n\\]\nEvery \\(\\Pi_1\\)-formula \\(\\varphi(\\vec{v})\\) is downward-persistent: \\[\n\\mathcal{M}\\models \\varphi[\\vec{a}] \\Longrightarrow \\mathcal{N}\\models \\varphi[\\vec{a}],\n\\]\nEvery \\(\\Delta_1\\)-formula \\(\\varphi(\\vec{v})\\) is absolute: \\[\n\\mathcal{N}\\models \\varphi[\\vec{a}] \\iff \\mathcal{M}\\models \\varphi[\\vec{a}].\n\\]\n\n\n\n\n\n\nProof. Part (i) is proved by induction on the formula structure of \\(\\varphi(\\vec{v})\\). Most cases are straightforward (using that \\(\\mathcal{N}\\) is a substructure of \\(\\mathcal{M}\\)). In the case of a bounded quantifier, one argues that, since \\(\\mathcal{M}\\) is an end extension of \\(\\mathcal{N}\\), \\(M\\) does not insert any new elements below an element of \\(N\\), so that a bounded quantifier means the same thing in both structures.\nThe other parts follow easily from the definition of the satisfaction relation \\(\\models\\) and the \\(\\Delta_0\\) case.\n\nLet \\(\\Sigma_1\\)-\\(\\operatorname{Th}(\\mathbb{N}):= \\{\\sigma \\mid \\sigma \\text{ is a } \\Sigma_1\\text{-sentence with } \\mathbb{N} \\models \\sigma \\}\\). Then we have:\n\n\n\n\n\n\n\nCorollary 1 \\[\n\\mathsf{PA}^- \\models \\Sigma_1\\text{-}\\operatorname{Th}(\\mathbb{N})\n\\]\n\n\n\n\n\nProof. Let \\(\\mathcal{N} \\models \\mathsf{PA}^-\\). By Theorem 1, we may assume that \\(\\mathbb{N} \\subseteq_{end} \\mathcal{N}\\), and the claim then follows from part (ii) above.\n\nThus one can prove in the theory \\(\\mathsf{PA}^-\\) all \\(\\Sigma_1\\)-sentences that hold in the standard model. This is no longer true for \\(\\Pi_1\\)-sentences. For instance, the \\(\\Pi_1\\)-sentence stating that every number is even or odd: \\[\n(*) \\quad \\forall x \\;  \\exists y \\le x \\; (x = 2 \\cdot y \\vee x = 2 \\cdot y +1)\n\\] is true in the standard model, but not in the \\(\\mathsf{PA}^-\\)-model \\(\\mathbb{Z}[X]^+\\).\nEven true \\(\\forall\\)-sentences (i.e., sentences of the form \\(\\forall \\vec{x} \\; \\psi\\) with quantifier-free \\(\\psi\\)) that hold in the standard model need not be provable in \\(\\mathsf{PA}^-\\). For example, the \\(\\forall\\)-sentence \\[\n\\forall x,y  (x^2 \\ne 2 \\cdot y^2)\n\\] is true in the standard model, but not provable in \\(\\mathsf{PA}^-\\) (\\(\\mathbb{Z}/(X^2 - 2Y^2)\\) is a counterexample).\nThus the above sentence (*) is an example of a \\(\\Pi_1\\)-sentence that is not a \\(\\forall\\)-sentence, where one cannot omit the bounded quantifier! (By the way, one can show that \\(\\mathbb{Z}[X]^+\\) is at least a model of all \\(\\forall\\)-sentences that hold in the standard model.)",
    "crumbs": [
      "11/3 - End extensions"
    ]
  },
  {
    "objectID": "014_Oct03_elementary_substructures.html",
    "href": "014_Oct03_elementary_substructures.html",
    "title": "Math 557 Oct 3",
    "section": "",
    "text": "Substrucure: \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) if \\(M \\subseteq N\\), \\(c^{\\mathcal{M}} = c^{\\mathcal{N}}\\) for all \\(c \\in \\mathcal{L}\\), \\(f^{\\mathcal{M}} = f^{\\mathcal{N}}\\upharpoonright_{\\mathcal{M}}\\) for all \\(f \\in \\mathcal{L}\\), and \\(R^{\\mathcal{M}} = R^{\\mathcal{N}}\\upharpoonright_{\\mathcal{M}}\\) for all \\(R \\in \\mathcal{L}\\).\nElementary substructure: \\(\\mathcal{M} \\preceq \\mathcal{N}\\) if for all \\(\\mathcal{L}\\)-formulas \\(\\psi(\\vec{x})\\) and all \\(\\vec{a} \\in M\\), \\[\n\\mathcal{M} \\models \\psi[\\vec{a}] \\iff \\mathcal{N} \\models \\psi[\\vec{a}]\n\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 \nWe have the following relations between structures \\(\\mathcal{M}, \\mathcal{N}\\):\n\\[\\subseteq, \\; \\preceq, \\;\\equiv, \\;\\cong\\]\nDraw a diagram indicating implications between these relations, giving counterexamples if one relation does not imply another.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nTHM: Suppose \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) and that for any formula \\(\\psi(x, \\vec{y})\\) and any \\(\\vec{a} \\in M\\), if there exists \\(b \\in N\\) such that \\(\\mathcal{N} \\models \\psi[b, \\vec{a}]\\), then there also exists \\(c \\in M\\) such that \\(\\mathcal{N} \\models \\psi[c, \\vec{a}]\\). Then we have \\(\\mathcal{M} \\preceq \\mathcal{N}\\).\nProve this theorem by induction in \\(\\operatorname{ht}(\\psi)\\).\nBefore you start, which inductive case do you think will require the most work?\n\n\n\n\nAs an application of the Tarski-Vaught test, we get another criterion for \\(\\preceq\\) using automorphisms of the bigger structure.\n\n\n\n\n\n\n\nExercise 3 \nSuppose \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) and that for any finite subset \\(A \\subseteq M\\) and \\(b \\in N\\), there exists an automorphism of \\(\\mathcal{N}\\) that fixes \\(A\\) pointwise and maps \\(b\\) into \\(M\\). Show that \\(\\mathcal{M} \\preceq \\mathcal{N}\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nUse the previous criterion to show that \\[\n(\\mathbb{Q}, &lt;) \\preceq (\\mathbb{R}, &lt;)\n\\]\n\n\n\n\n\n\n\nWe have seen previously that the theory \\(\\operatorname{DLO}\\) is \\(\\aleph_0\\)-categorical, i.e., there is only one countable model up to isomorphism.\nWe will now see that this actually implies \\(\\operatorname{DLO}\\) is complete.\nWe need the following theorem which we will be an easy consequence of the Löwenheim-SKolem Theorems we will prove next week.\n\n\n\n\n\n\n\nTheorem 1 Let \\(T\\) be an \\(\\mathcal{L}\\)-theory that has an infinite model. If \\(\\kappa\\) is an infinite cardinal and \\(\\kappa \\geq |\\mathcal{L}|\\), then there is a model of \\(T\\) of cardinality \\(\\kappa\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 (Vaught’s test) Suppose \\(T\\) is a consistent \\(\\mathcal{L}\\)-theory with no finite models. If \\(T\\) is \\(\\kappa\\)-categorical for some \\(\\kappa \\geq |\\mathcal{L}|\\), then \\(T\\) is complete.",
    "crumbs": [
      "10/3 - Elementary substructures"
    ]
  },
  {
    "objectID": "014_Oct03_elementary_substructures.html#key-concepts",
    "href": "014_Oct03_elementary_substructures.html#key-concepts",
    "title": "Math 557 Oct 3",
    "section": "",
    "text": "Substrucure: \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) if \\(M \\subseteq N\\), \\(c^{\\mathcal{M}} = c^{\\mathcal{N}}\\) for all \\(c \\in \\mathcal{L}\\), \\(f^{\\mathcal{M}} = f^{\\mathcal{N}}\\upharpoonright_{\\mathcal{M}}\\) for all \\(f \\in \\mathcal{L}\\), and \\(R^{\\mathcal{M}} = R^{\\mathcal{N}}\\upharpoonright_{\\mathcal{M}}\\) for all \\(R \\in \\mathcal{L}\\).\nElementary substructure: \\(\\mathcal{M} \\preceq \\mathcal{N}\\) if for all \\(\\mathcal{L}\\)-formulas \\(\\psi(\\vec{x})\\) and all \\(\\vec{a} \\in M\\), \\[\n\\mathcal{M} \\models \\psi[\\vec{a}] \\iff \\mathcal{N} \\models \\psi[\\vec{a}]\n\\]",
    "crumbs": [
      "10/3 - Elementary substructures"
    ]
  },
  {
    "objectID": "014_Oct03_elementary_substructures.html#problems",
    "href": "014_Oct03_elementary_substructures.html#problems",
    "title": "Math 557 Oct 3",
    "section": "",
    "text": "Exercise 1 \nWe have the following relations between structures \\(\\mathcal{M}, \\mathcal{N}\\):\n\\[\\subseteq, \\; \\preceq, \\;\\equiv, \\;\\cong\\]\nDraw a diagram indicating implications between these relations, giving counterexamples if one relation does not imply another.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 \nTHM: Suppose \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) and that for any formula \\(\\psi(x, \\vec{y})\\) and any \\(\\vec{a} \\in M\\), if there exists \\(b \\in N\\) such that \\(\\mathcal{N} \\models \\psi[b, \\vec{a}]\\), then there also exists \\(c \\in M\\) such that \\(\\mathcal{N} \\models \\psi[c, \\vec{a}]\\). Then we have \\(\\mathcal{M} \\preceq \\mathcal{N}\\).\nProve this theorem by induction in \\(\\operatorname{ht}(\\psi)\\).\nBefore you start, which inductive case do you think will require the most work?\n\n\n\n\nAs an application of the Tarski-Vaught test, we get another criterion for \\(\\preceq\\) using automorphisms of the bigger structure.\n\n\n\n\n\n\n\nExercise 3 \nSuppose \\(\\mathcal{M} \\subseteq \\mathcal{N}\\) and that for any finite subset \\(A \\subseteq M\\) and \\(b \\in N\\), there exists an automorphism of \\(\\mathcal{N}\\) that fixes \\(A\\) pointwise and maps \\(b\\) into \\(M\\). Show that \\(\\mathcal{M} \\preceq \\mathcal{N}\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 \nUse the previous criterion to show that \\[\n(\\mathbb{Q}, &lt;) \\preceq (\\mathbb{R}, &lt;)\n\\]\n\n\n\n\n\n\n\nWe have seen previously that the theory \\(\\operatorname{DLO}\\) is \\(\\aleph_0\\)-categorical, i.e., there is only one countable model up to isomorphism.\nWe will now see that this actually implies \\(\\operatorname{DLO}\\) is complete.\nWe need the following theorem which we will be an easy consequence of the Löwenheim-SKolem Theorems we will prove next week.\n\n\n\n\n\n\n\nTheorem 1 Let \\(T\\) be an \\(\\mathcal{L}\\)-theory that has an infinite model. If \\(\\kappa\\) is an infinite cardinal and \\(\\kappa \\geq |\\mathcal{L}|\\), then there is a model of \\(T\\) of cardinality \\(\\kappa\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 (Vaught’s test) Suppose \\(T\\) is a consistent \\(\\mathcal{L}\\)-theory with no finite models. If \\(T\\) is \\(\\kappa\\)-categorical for some \\(\\kappa \\geq |\\mathcal{L}|\\), then \\(T\\) is complete.",
    "crumbs": [
      "10/3 - Elementary substructures"
    ]
  },
  {
    "objectID": "015_Oct06_loewenheim_skolem.html",
    "href": "015_Oct06_loewenheim_skolem.html",
    "title": "Math 557 Oct 6",
    "section": "",
    "text": "Exercise 1 For finite structures \\(\\mathcal{M}, \\mathcal{N}\\), \\(\\mathcal{M} \\preceq \\mathcal{N}\\) implies \\(M=N\\)\n\n\n\n\nHence, for finite structures, proper elementary substructures cannot exist. In contrast, infinite structures have an elementary substructure in every smaller infinite cardinality \\(\\kappa\\) (as long as \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\)):\n\n\n\n\n\n\n\n\n\nTheorem 1 (Löwenheim-Skolem downward) Let \\(\\mathcal{A}\\) be an \\(\\mathcal{L}\\)-structure, \\(\\kappa\\) an infinite cardinal with \\(\\operatorname{card}(\\mathcal{L}) \\le \\kappa\\) and \\(\\kappa \\le \\operatorname{card}(A)\\). Then there exists a structure \\(\\mathcal{B}\\) with \\[\n\\mathcal{B} \\preceq  \\mathcal{A} \\; , \\; \\operatorname{card}(B) = \\kappa.\n\\]\nAddition: If \\(A_0 \\subseteq A\\) is arbitrary with \\(\\operatorname{card}(A_0) \\le \\kappa\\), then one can additionally require \\(A_0 \\subseteq B\\).\n\n\n\n\n\nProof. Let \\(A_0 \\subseteq A\\) be given with \\(\\operatorname{card}(A_0) \\le \\kappa \\le \\operatorname{card}(A)\\). By enlarging \\(A_0\\) if necessary, we can assume that \\(\\operatorname{card}(A_0) = \\kappa\\).\nIf for elements \\(a_1,\\ldots,a_n \\in A_0\\) \\[\n(*) \\quad \\mathcal{A} \\models \\exists v_0 \\varphi[a_1,\\ldots,a_n]\n\\] holds, we have to add a witness \\(b\\) for this existential quantifier to \\(A_0\\); let \\(A_1\\) be the set that arises from \\(A_0\\) by adding such witnesses (for all possible existential formulas and all possible assignments with elements from \\(A_0\\)). Standard cardinal arithmetic yields \\(\\operatorname{card}(A_1) = \\operatorname{card}(A_0) = \\kappa\\).\nNow, however, \\((*)\\) may possibly hold for a formula \\(\\varphi\\) and new elements \\(a_1,\\ldots,a_n \\in A_1\\) that are not contained in \\(A_0\\); thus, we have to iterate the procedure.\nWith \\(A_i\\) defined, add suitable elements from \\(A\\), resulting in a set \\(A_{i+1}\\), such that: \\[\n\\begin{aligned}\n&\\text{If for } \\; a_1, \\ldots,a_n \\in A_i: \\mathcal{A} \\models \\exists v_0 \\varphi[a_1,\\ldots,a_n], \\\\\n&\\text{then there exists an} \\; a \\in A_{i+1} \\; \\text{with} \\; \\mathcal{A} \\models  \\varphi[a,a_1,\\ldots,a_n].\n\\end{aligned}\n\\]\nAs in the first step, \\(A_{i+1}\\) can be obtained from \\(A_i\\) without changing the cardinality. Finally, we set \\[\nB:=  \\bigcup_{i \\in \\mathbb{N}} A_i\n\\] and obtain a set \\(B\\) with \\(A_0 \\subseteq B \\subseteq A\\) and \\(\\operatorname{card}(B) = \\kappa\\).\nIn the first step, we already add all constants of \\(\\mathcal{A}\\) (using \\((*)\\) with the formula \\(\\exists v_0 (v_0 = c)\\)) and in all further steps we are closing under the functions of \\(\\mathcal{A}\\) (using the formula \\(\\exists v_0 (v_0 = f(v_1,\\ldots,v_n))\\)). It follows that \\(B\\) is the universe of a substructure \\(\\mathcal{B}\\) of \\(\\mathcal{A}\\). We can then conclude that \\(\\mathcal{B} \\preceq  \\mathcal{A}\\) using the Tarski-Vaught test, as our construction is arranged precisely so that the Tarski-Vaught criterion is applicable.\n\n\n\n\nThe proof of the upward version is simpler and is based on the Compactness Theorem.\n\n\n\n\n\n\n\nTheorem 2 (Löwenheim-Skolem upward) Let \\(\\mathcal{A}\\) be an infinite \\(\\mathcal{L}\\)-structure, \\(\\kappa\\) a cardinal with \\(\\operatorname{card}(\\mathcal{L}) \\le \\kappa\\) and \\(\\operatorname{card}(A) \\le \\kappa\\). Then there exists a structure \\(\\mathcal{B}\\) with* \\[\n\\mathcal{A} \\preceq  \\mathcal{B} \\; , \\;  \\operatorname{card}(B) = \\kappa.\n\\]\n\n\n\n\n\nProof. We first pick a set \\(C\\) with \\(A  \\subseteq C\\) and \\(\\operatorname{card}(C) = \\kappa\\) and extend the theory of \\(\\mathcal{A}\\) (with the help of new constants) so that every model has at least as many elements as \\(C\\):\n\\[\nT' = \\operatorname{Th}(\\mathcal{A}) \\cup \\{\\underline{c} \\ne \\underline{d}\\mid c,d \\in C, c \\ne d \\}.\n\\]\nBy the Compactness Theorem, \\(T'\\) has a model, say \\(\\mathcal{B}\\), in which the new constants \\(\\underline{c}\\) are interpreted by elements of \\(B\\) – different constants by different elements of \\(B\\). By passing to an isomorphic structure, we can assume that \\(\\underline{c}^{\\mathcal{B}} = c\\) and thus \\(C \\subseteq B\\), so \\(\\operatorname{card}(B) \\ge \\kappa\\).\nThe language of \\(T'\\) has cardinality \\(\\kappa\\) because \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\), so we can also assume that \\(\\operatorname{card}(B) = \\kappa\\) (by using the downward theorem).\nFinally, because \\(\\mathcal{B} \\models \\operatorname{Th}(\\mathcal{A})\\), we have \\(\\mathcal{A}\\equiv \\mathcal{B}\\). The stronger statement \\(\\mathcal{A} \\preceq \\mathcal{B}\\) is obtained by using the same argument, but using the elementary diagram \\(D(\\mathcal{A}) = \\operatorname{Th}(\\mathcal{A}_A)\\) instead of \\(\\operatorname{Th}(\\mathcal{A})\\).\n\n\n\n\n\nIf \\(\\mathcal{A}\\) is an infinite \\(\\mathcal{L}\\)-structure and \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\) is a infinite cardinal, then there exists a structure \\(\\mathcal{B}\\) with \\(\\operatorname{card}(B) = \\kappa\\) and\n\n\\(\\mathcal{B} \\preceq \\mathcal{A}\\) in the case \\(\\kappa \\le \\operatorname{card}(A)\\),\n\\(\\mathcal{A} \\preceq \\mathcal{B}\\) in the case \\(\\operatorname{card}(A) \\le \\kappa\\).\n\nIn particular, every theory \\(T\\) that has an infinite model has a model of cardinality \\(\\kappa\\) for every cardinal \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\).\nMore specifically: A theory \\(T\\) in a countable language \\(\\mathcal{L}\\) that has a model at all also has a countable model. This theorem of Löwenheim (1915) is one of the earliest results of mathematical logic.\n\n\n\nConsider the structure \\((\\mathbb{R},0,1,+,\\cdot, &lt;)\\) over the language of ordered rings. By Löwenheim-Skolem downward, this has a countable elementary substructure \\(\\mathcal{R}'\\). \\(\\mathcal{R}'\\) is a field, so it has to contain \\(\\mathbb{Q}\\), and since it inherits the order from \\(\\mathbb{R}\\), it has to be dense in \\(\\mathbb{R}\\). Since \\(\\mathcal{R}'\\) is countable, the exists \\(r_0 \\in \\mathbb{R}\\setminus R'\\). The set \\[\n\\{ r \\in R' : r &lt; r_0\\}\n\\] is bounded in \\(\\mathcal{R}'\\) but cannot have a least upper bound in \\(\\mathcal{R}'\\).\nAs \\(\\mathcal{R}' \\models \\operatorname{Th}(\\mathbb{R},0,1,+,\\cdot, &lt;)\\), it follows that the theory of complete ordered fields is not first-order axiomatizable in the language of ordered rings.\nIt can be shown that the algebraic numbers \\(\\mathbb{R}_{\\operatorname{alg}}\\) form such a countable elementary substructure of \\(\\mathbb{R}\\).",
    "crumbs": [
      "10/6 - Löwenheim-Skolem Theorems"
    ]
  },
  {
    "objectID": "015_Oct06_loewenheim_skolem.html#down",
    "href": "015_Oct06_loewenheim_skolem.html#down",
    "title": "Math 557 Oct 6",
    "section": "",
    "text": "Theorem 1 (Löwenheim-Skolem downward) Let \\(\\mathcal{A}\\) be an \\(\\mathcal{L}\\)-structure, \\(\\kappa\\) an infinite cardinal with \\(\\operatorname{card}(\\mathcal{L}) \\le \\kappa\\) and \\(\\kappa \\le \\operatorname{card}(A)\\). Then there exists a structure \\(\\mathcal{B}\\) with \\[\n\\mathcal{B} \\preceq  \\mathcal{A} \\; , \\; \\operatorname{card}(B) = \\kappa.\n\\]\nAddition: If \\(A_0 \\subseteq A\\) is arbitrary with \\(\\operatorname{card}(A_0) \\le \\kappa\\), then one can additionally require \\(A_0 \\subseteq B\\).\n\n\n\n\n\nProof. Let \\(A_0 \\subseteq A\\) be given with \\(\\operatorname{card}(A_0) \\le \\kappa \\le \\operatorname{card}(A)\\). By enlarging \\(A_0\\) if necessary, we can assume that \\(\\operatorname{card}(A_0) = \\kappa\\).\nIf for elements \\(a_1,\\ldots,a_n \\in A_0\\) \\[\n(*) \\quad \\mathcal{A} \\models \\exists v_0 \\varphi[a_1,\\ldots,a_n]\n\\] holds, we have to add a witness \\(b\\) for this existential quantifier to \\(A_0\\); let \\(A_1\\) be the set that arises from \\(A_0\\) by adding such witnesses (for all possible existential formulas and all possible assignments with elements from \\(A_0\\)). Standard cardinal arithmetic yields \\(\\operatorname{card}(A_1) = \\operatorname{card}(A_0) = \\kappa\\).\nNow, however, \\((*)\\) may possibly hold for a formula \\(\\varphi\\) and new elements \\(a_1,\\ldots,a_n \\in A_1\\) that are not contained in \\(A_0\\); thus, we have to iterate the procedure.\nWith \\(A_i\\) defined, add suitable elements from \\(A\\), resulting in a set \\(A_{i+1}\\), such that: \\[\n\\begin{aligned}\n&\\text{If for } \\; a_1, \\ldots,a_n \\in A_i: \\mathcal{A} \\models \\exists v_0 \\varphi[a_1,\\ldots,a_n], \\\\\n&\\text{then there exists an} \\; a \\in A_{i+1} \\; \\text{with} \\; \\mathcal{A} \\models  \\varphi[a,a_1,\\ldots,a_n].\n\\end{aligned}\n\\]\nAs in the first step, \\(A_{i+1}\\) can be obtained from \\(A_i\\) without changing the cardinality. Finally, we set \\[\nB:=  \\bigcup_{i \\in \\mathbb{N}} A_i\n\\] and obtain a set \\(B\\) with \\(A_0 \\subseteq B \\subseteq A\\) and \\(\\operatorname{card}(B) = \\kappa\\).\nIn the first step, we already add all constants of \\(\\mathcal{A}\\) (using \\((*)\\) with the formula \\(\\exists v_0 (v_0 = c)\\)) and in all further steps we are closing under the functions of \\(\\mathcal{A}\\) (using the formula \\(\\exists v_0 (v_0 = f(v_1,\\ldots,v_n))\\)). It follows that \\(B\\) is the universe of a substructure \\(\\mathcal{B}\\) of \\(\\mathcal{A}\\). We can then conclude that \\(\\mathcal{B} \\preceq  \\mathcal{A}\\) using the Tarski-Vaught test, as our construction is arranged precisely so that the Tarski-Vaught criterion is applicable.",
    "crumbs": [
      "10/6 - Löwenheim-Skolem Theorems"
    ]
  },
  {
    "objectID": "015_Oct06_loewenheim_skolem.html#up",
    "href": "015_Oct06_loewenheim_skolem.html#up",
    "title": "Math 557 Oct 6",
    "section": "",
    "text": "The proof of the upward version is simpler and is based on the Compactness Theorem.\n\n\n\n\n\n\n\nTheorem 2 (Löwenheim-Skolem upward) Let \\(\\mathcal{A}\\) be an infinite \\(\\mathcal{L}\\)-structure, \\(\\kappa\\) a cardinal with \\(\\operatorname{card}(\\mathcal{L}) \\le \\kappa\\) and \\(\\operatorname{card}(A) \\le \\kappa\\). Then there exists a structure \\(\\mathcal{B}\\) with* \\[\n\\mathcal{A} \\preceq  \\mathcal{B} \\; , \\;  \\operatorname{card}(B) = \\kappa.\n\\]\n\n\n\n\n\nProof. We first pick a set \\(C\\) with \\(A  \\subseteq C\\) and \\(\\operatorname{card}(C) = \\kappa\\) and extend the theory of \\(\\mathcal{A}\\) (with the help of new constants) so that every model has at least as many elements as \\(C\\):\n\\[\nT' = \\operatorname{Th}(\\mathcal{A}) \\cup \\{\\underline{c} \\ne \\underline{d}\\mid c,d \\in C, c \\ne d \\}.\n\\]\nBy the Compactness Theorem, \\(T'\\) has a model, say \\(\\mathcal{B}\\), in which the new constants \\(\\underline{c}\\) are interpreted by elements of \\(B\\) – different constants by different elements of \\(B\\). By passing to an isomorphic structure, we can assume that \\(\\underline{c}^{\\mathcal{B}} = c\\) and thus \\(C \\subseteq B\\), so \\(\\operatorname{card}(B) \\ge \\kappa\\).\nThe language of \\(T'\\) has cardinality \\(\\kappa\\) because \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\), so we can also assume that \\(\\operatorname{card}(B) = \\kappa\\) (by using the downward theorem).\nFinally, because \\(\\mathcal{B} \\models \\operatorname{Th}(\\mathcal{A})\\), we have \\(\\mathcal{A}\\equiv \\mathcal{B}\\). The stronger statement \\(\\mathcal{A} \\preceq \\mathcal{B}\\) is obtained by using the same argument, but using the elementary diagram \\(D(\\mathcal{A}) = \\operatorname{Th}(\\mathcal{A}_A)\\) instead of \\(\\operatorname{Th}(\\mathcal{A})\\).",
    "crumbs": [
      "10/6 - Löwenheim-Skolem Theorems"
    ]
  },
  {
    "objectID": "015_Oct06_loewenheim_skolem.html#some-consequences",
    "href": "015_Oct06_loewenheim_skolem.html#some-consequences",
    "title": "Math 557 Oct 6",
    "section": "",
    "text": "If \\(\\mathcal{A}\\) is an infinite \\(\\mathcal{L}\\)-structure and \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\) is a infinite cardinal, then there exists a structure \\(\\mathcal{B}\\) with \\(\\operatorname{card}(B) = \\kappa\\) and\n\n\\(\\mathcal{B} \\preceq \\mathcal{A}\\) in the case \\(\\kappa \\le \\operatorname{card}(A)\\),\n\\(\\mathcal{A} \\preceq \\mathcal{B}\\) in the case \\(\\operatorname{card}(A) \\le \\kappa\\).\n\nIn particular, every theory \\(T\\) that has an infinite model has a model of cardinality \\(\\kappa\\) for every cardinal \\(\\kappa \\ge \\operatorname{card}(\\mathcal{L})\\).\nMore specifically: A theory \\(T\\) in a countable language \\(\\mathcal{L}\\) that has a model at all also has a countable model. This theorem of Löwenheim (1915) is one of the earliest results of mathematical logic.\n\n\n\nConsider the structure \\((\\mathbb{R},0,1,+,\\cdot, &lt;)\\) over the language of ordered rings. By Löwenheim-Skolem downward, this has a countable elementary substructure \\(\\mathcal{R}'\\). \\(\\mathcal{R}'\\) is a field, so it has to contain \\(\\mathbb{Q}\\), and since it inherits the order from \\(\\mathbb{R}\\), it has to be dense in \\(\\mathbb{R}\\). Since \\(\\mathcal{R}'\\) is countable, the exists \\(r_0 \\in \\mathbb{R}\\setminus R'\\). The set \\[\n\\{ r \\in R' : r &lt; r_0\\}\n\\] is bounded in \\(\\mathcal{R}'\\) but cannot have a least upper bound in \\(\\mathcal{R}'\\).\nAs \\(\\mathcal{R}' \\models \\operatorname{Th}(\\mathbb{R},0,1,+,\\cdot, &lt;)\\), it follows that the theory of complete ordered fields is not first-order axiomatizable in the language of ordered rings.\nIt can be shown that the algebraic numbers \\(\\mathbb{R}_{\\operatorname{alg}}\\) form such a countable elementary substructure of \\(\\mathbb{R}\\).",
    "crumbs": [
      "10/6 - Löwenheim-Skolem Theorems"
    ]
  },
  {
    "objectID": "002_Aug29_semantics.html",
    "href": "002_Aug29_semantics.html",
    "title": "Math 557 August 29",
    "section": "",
    "text": "\\(\\mathcal{L}\\)-structures: Provide a realm to interpret \\(\\mathcal{L}\\)-formulas over.\n\nnon-empty universe \\(M\\),\ninterpretation of all constant, function, and relation symbols over \\(M\\).\n\nstructure isomorphism: bijection \\(\\pi\\) between the universes of two \\(\\mathcal{L}\\)-structures that preserves interpretations of symbols. General version of the well-known idea of isomorphism of mathematical structures.\nassignment: function \\(\\alpha: \\mathcal{V} \\to M\\) that assigns all variables values in the universe of a structure. Recursively extends to terms.\nsatisfaction relation: \\(\\mathcal{M} \\models \\varphi[\\alpha]\\) means the \\(\\mathcal{L}\\)-formula \\(\\varphi\\) is true when interpreted in the \\(\\mathcal{L}\\)-structure \\(\\mathcal{M}\\) and all variables are assigned values according to assignment \\(\\alpha\\). This is defined recursively over the structure of a formula.",
    "crumbs": [
      "8/29 - Semantics of first order logic"
    ]
  },
  {
    "objectID": "002_Aug29_semantics.html#key-concepts",
    "href": "002_Aug29_semantics.html#key-concepts",
    "title": "Math 557 August 29",
    "section": "",
    "text": "\\(\\mathcal{L}\\)-structures: Provide a realm to interpret \\(\\mathcal{L}\\)-formulas over.\n\nnon-empty universe \\(M\\),\ninterpretation of all constant, function, and relation symbols over \\(M\\).\n\nstructure isomorphism: bijection \\(\\pi\\) between the universes of two \\(\\mathcal{L}\\)-structures that preserves interpretations of symbols. General version of the well-known idea of isomorphism of mathematical structures.\nassignment: function \\(\\alpha: \\mathcal{V} \\to M\\) that assigns all variables values in the universe of a structure. Recursively extends to terms.\nsatisfaction relation: \\(\\mathcal{M} \\models \\varphi[\\alpha]\\) means the \\(\\mathcal{L}\\)-formula \\(\\varphi\\) is true when interpreted in the \\(\\mathcal{L}\\)-structure \\(\\mathcal{M}\\) and all variables are assigned values according to assignment \\(\\alpha\\). This is defined recursively over the structure of a formula.",
    "crumbs": [
      "8/29 - Semantics of first order logic"
    ]
  },
  {
    "objectID": "002_Aug29_semantics.html#problems",
    "href": "002_Aug29_semantics.html#problems",
    "title": "Math 557 August 29",
    "section": "Problems",
    "text": "Problems\nWe warm up with a quote often attributed to Lincoln.\n\n\n\n\n\n\n\nExercise 1  \n\nYou can fool all the people some of the time, and some of the people all the time, but you cannot fool all the people all the time.\n\nDefine a suitable language and formalize this statement in first-order logic.\n\n\n\n\nNext, a couple of problems to see the definition of structures and the satisfaction relation \\(\\models\\) at work.\n\n\n\n\n\n\n\nExercise 2 \nLet \\(\\mathcal{L} = \\{ \\Box, \\triangle, c\\}\\), where \\(\\Box\\) is a binary relation symbol, \\(\\triangle\\) is a binary function symbol, and \\(c\\) is a constant symbol.\nFor each of the following formulas, find two \\(\\mathcal{L}\\)-structures and (if necessary) assignments to the free variable(s) such that the formula holds in one structure but fails in the other.\n\\[\\begin{aligned}\n\\varphi & \\equiv \\forall x \\exists y \\: \\Box \\, \\triangle x y \\, c \\\\\n\\psi & \\equiv \\exists x \\forall y ( x = c \\: \\wedge \\: \\Box \\, \\triangle zc \\, y )\n\\end{aligned}\\]\n\n\n\n\nNext, let’s see some general properties of structures we can describe through first-order formulas.\n\n\n\n\n\n\n\nExercise 3 \nLet \\(n\\) be a natural number and let \\(\\mathcal{L}\\) be any language. Find formulas \\(, \\psi^{\\geq}, \\psi^{\\leq}, \\psi^=\\) such that, for any \\(\\mathcal{L}\\)-structure \\(\\mathcal{M}\\),\n\\[\\begin{aligned}\n\\mathcal{M} \\models \\psi^{\\geq} & \\iff \\; |M| \\geq n \\\\\n\\mathcal{M} \\models \\psi^{\\leq} & \\iff \\; |M| \\leq n \\\\\n\\mathcal{M} \\models \\psi^{=} & \\iff \\; |M| = n \\\\\n\\end{aligned}\\]\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCan we find a formula \\(\\theta\\) such that\n\\[\n\\mathcal{M} \\models \\theta \\; \\iff \\; |M| \\text{ is finite}?\n\\]\n\n\nWe will answer this question in a few weeks…\n\n\n\n\n\n\n\nExercise 4 \nLet \\(\\mathcal{L} = \\{\\cdot , e\\}\\) be the language of groups. Show that there is a sentence \\(\\varphi\\) such that \\(\\mathcal{M} \\models \\varphi\\) if and only if\n\\[M \\cong \\mathbb{Z}/2\\mathbb{Z}\\times \\mathbb{Z}/2\\mathbb{Z}.\\]\n\n\n\n\n\n\n\n\n\n\nTake-home Problems\n\n\n\n\n\nLet \\(\\mathcal{L}\\) be any finite language and let \\(\\mathcal{M}\\) be a finite \\(\\mathcal{L}\\)-structure. Show that there is an \\(\\mathcal{L}\\)-sentence \\(\\varphi\\) such that\n\n\\[\n\\mathcal{N} \\models \\varphi \\; \\iff \\; \\mathcal{N} \\cong \\mathcal{M}.\n\\]\n\nGive an example of a language \\(\\mathcal{L}\\) and an \\(\\mathcal{L}\\)-sentence \\(\\psi\\) such that\n\nthere is at least one \\(\\mathcal{L}\\)-structure \\(\\cal A\\) such that \\(\\cal A \\models \\psi\\),\nfor all \\(\\cal L\\)-structures \\(\\cal A\\), if \\(\\cal A \\models \\psi\\), then the universe \\(A\\) of \\(\\cal A\\) is infinite.",
    "crumbs": [
      "8/29 - Semantics of first order logic"
    ]
  },
  {
    "objectID": "017_Oct10_week7_problems.html",
    "href": "017_Oct10_week7_problems.html",
    "title": "Math 557 Oct 10",
    "section": "",
    "text": "A filter \\(\\mathcal{F}\\) on a set \\(I\\) is a nonempty collection of subsets of \\(I\\) satisfying:\n\n\\(\\emptyset \\notin \\mathcal{F}\\)\n\nIf \\(A,B \\in \\mathcal{F}\\), then \\(A \\cap B \\in \\mathcal{F}\\)\n\nIf \\(A \\in \\mathcal{F}\\) and \\(A \\subseteq B \\subseteq I\\), then \\(B \\in \\mathcal{F}\\)\n\nAn ultrafilter \\(\\mathcal{U}\\) is a maximal filter, equivalently:\n\nFor all \\(A \\subseteq I\\), either \\(A \\in \\mathcal{U}\\) or \\(I \\setminus A \\in \\mathcal{U}\\).\n\n\n\n\nGiven: filter \\(\\mathcal{F}\\) on \\(I\\) and structures \\((\\mathcal{M}_i)_{i \\in I}\\). Let \\(M = \\prod_{i \\in I} M_i\\) and define \\[\na \\sim_{\\mathcal{F}} b \\iff \\{\\, i \\in I : a_i = b_i \\,\\} \\in \\mathcal{F}.\n\\]\nThe universe of \\(\\mathcal{M}/\\mathcal{F}\\) is the quotient \\(M / {\\sim_{\\mathcal{F}}}\\), with elements denoted \\(a_{\\mathcal{F}}\\) (alternatively, \\(a/\\mathcal{F}\\)).\n\nRelations:\n\\[\nR^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}})\n: \\iff  \\{\\, i : \\mathcal{M}_i \\models R(\\vec a_i) \\,\\} \\in \\mathcal{F}.\n\\]\nFunctions:\n\\[\nf^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}}) =\n[\\, (f^{\\mathcal{M}_i}(\\vec a_i))_{i \\in I} \\,]_{\\mathcal{F}}.\n\\]\nConstants:\n\\[\nc^{\\mathcal{M}/\\mathcal{F}} = ((c^{\\mathcal{M}_i})_{i\\in I})_{\\mathcal{F}}.\n\\]\n\n\n\n\nLet \\(\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\\) be an ultraproduct. For every \\(\\mathcal{L}\\)-formula \\(\\varphi(x_1,\\dots,x_n)\\) and tuples\n\\(\\vec a \\in \\prod_{i \\in I} M_i\\), \\[\n\\mathcal{M}/\\mathcal{U} \\models \\varphi[\\vec a_{\\mathcal{U}}]\n\\iff\n\\{\\, i \\in I : \\mathcal{M}_i \\models \\varphi[\\vec a_i]\\,\\} \\in \\mathcal{U}.\n\\]\n\n\n\n\n\n\n\n\n\n\n\nExercise 1 (Principal filters) Show that for every \\(A \\subseteq I\\), \\[\n\\{X \\subseteq I : A \\subseteq X \\}\n\\] is a filter on \\(I\\). Show that it is an ultrafilter if and only if \\(|A| = 1\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 (Finite sets) Show that every ultrafilter on a finite set is principal.\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 (Free ultrafilters on infinite sets) Show that a free ultrafilter on an infinite set \\(I\\) cannot contain any finite subsets of \\(I\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 (Ultrafilter existence) Use Zorn’s Lemma to show that any family \\(\\mathcal{A} \\subseteq \\mathcal{P}(I)\\) with the FIP can be extended to an ultrafilter \\(\\mathcal{U}\\) on \\(I\\).\nUse this to show that any infinite set has a free ultrafilter.\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 (Ultrapoducts with principal ultrafilters) Show that if \\(\\mathcal{U}\\) is a principal ultrafilter on \\(I\\), then every ultraproduct \\[\n\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i/\\mathcal{U}\n\\] is isomorphic to some \\(\\mathcal{M}_j\\), \\(j \\in I\\).\nFor principal ultrafilters, ultraproducts do not lead to anything new.\n\n\n\n\n\n\n\n\n\n\n\nExercise 6 (Ultraproducts of fields) For any prime \\(p\\) let \\(\\mathbb{F}_p\\) the field with \\(p\\) elements (of characteristic \\(p\\)), and let \\(\\mathcal{U}\\) be a free ultrafilter on the set \\(P\\) of prime numbers.\nShow that the ultraproduct\n\\[\\prod_{p\\in P} \\mathbb{F}_p/\\mathcal{U}\\]\nis a field of characteristic \\(0\\).\n\n\n\n\n\n\n\nIf we take an ultraproduct over the same structure \\(\\mathcal{M}\\) along an index set \\(I\\), we call this an ultrapower, denoted by \\[\n\\mathcal{M}^I/\\mathcal{U}\n\\]\nLet \\(\\mathcal{U}\\) be a free ultrafilter on an (infinite) set \\(I\\).\n\nShow that the map \\(j: b \\mapsto (b)_{i \\in I}/\\mathcal{U}\\) defines an elementary embedding of \\(\\mathcal{M}\\) into \\(\\mathcal{M}^I/\\mathcal{U}\\) (i.e. it is injective and the image is an elementary substructure).\nShow that if \\(\\mathcal{M}\\) is infinite, \\(j\\) is not a surjection.\n\nIf we apply this to \\(\\mathbb{N}\\) in the language of arithmetic, this yields another way to obtain non-standard models of arithmetic.\n\n\n\n\n\nGiven a language \\(\\mathcal{L}\\), define an equivalence relation of the set of all \\(\\mathcal{L}\\)-sentences by \\[\n\\sigma \\sim \\tau \\; \\iff \\; \\vdash \\sigma \\leftrightarrow \\tau\n\\]\nThe equivalence classes will then form a Boolean algebra, the Lindenbaum-Tarksi algebra \\(\\mathcal{B}\\) with the operations \\[\n\\begin{aligned}\n[\\sigma] \\land [\\tau] & :=  [\\sigma \\land \\tau]\\\\\n[\\sigma] \\lor [\\tau] & := [\\sigma \\lor \\tau] \\\\\n\\neg[\\sigma] & := [\\neg \\sigma]\n\\end{aligned}\n\\] The bottom element is \\(0 :=[\\sigma \\land \\neg \\sigma]\\), the top element is \\(1:= [\\sigma \\lor \\neg \\sigma]\\).\nWe can define an order by putting \\([\\sigma] \\leq [\\tau] : \\iff \\vdash \\sigma \\to \\tau\\). (This corresponds to the order that is defined on any Boolean algebra via \\(a \\leq b :\\Leftrightarrow a = a \\land b\\).)\nA filter on a Boolean algebra is defined in the same way it is defined on a set \\(I\\) (in fact, a filter on a set \\(I\\) is simply a filter on the Boolean algebra induced on its power set by taking intersections, unions, and complements): \\(F \\subseteq \\mathcal{B}\\) is a filter if it does not contain the bottom element, is closed under \\(\\land\\) and closed upward under \\(\\leq\\).\n\nShow that if \\(T\\) is a deductively closed, consistent \\(\\mathcal{L}\\)-theory, the set \\[\n\\{ [\\sigma] : \\sigma \\in T \\}\n\\] is a filter in \\(\\mathcal{B}\\).\nShow that if \\(T\\) is complete, the above filter is an ultrafilter.\n\n\n\n\nFrom Łoś’ Theorem, we know that if two ultrapowers are isomorphic, then the original structures are elementary equivalent. Remarkably, the converse holds, too, and hence gives an algebraic characterization of elementary equivalence.\n\n\n\n\n\n\n\nTheorem 1 (Keisler-Shelah) For any two structures \\(\\mathcal{M}, \\mathcal{N}\\), \\[\n\\mathcal{M} \\equiv \\mathcal{N} \\; \\iff \\; \\text{ there exists an index set $I$ and an ultrafilter $\\mathcal{U}$ on $I$ such that } \\mathcal{M}^I/\\mathcal{U} \\cong \\mathcal{N}^I/\\mathcal{U}\n\\]\n\n\n\n\n\n\n\n\nRamsey theory and ultrafilters",
    "crumbs": [
      "10/10 - Problems"
    ]
  },
  {
    "objectID": "017_Oct10_week7_problems.html#key-concepts",
    "href": "017_Oct10_week7_problems.html#key-concepts",
    "title": "Math 557 Oct 10",
    "section": "",
    "text": "A filter \\(\\mathcal{F}\\) on a set \\(I\\) is a nonempty collection of subsets of \\(I\\) satisfying:\n\n\\(\\emptyset \\notin \\mathcal{F}\\)\n\nIf \\(A,B \\in \\mathcal{F}\\), then \\(A \\cap B \\in \\mathcal{F}\\)\n\nIf \\(A \\in \\mathcal{F}\\) and \\(A \\subseteq B \\subseteq I\\), then \\(B \\in \\mathcal{F}\\)\n\nAn ultrafilter \\(\\mathcal{U}\\) is a maximal filter, equivalently:\n\nFor all \\(A \\subseteq I\\), either \\(A \\in \\mathcal{U}\\) or \\(I \\setminus A \\in \\mathcal{U}\\).\n\n\n\n\nGiven: filter \\(\\mathcal{F}\\) on \\(I\\) and structures \\((\\mathcal{M}_i)_{i \\in I}\\). Let \\(M = \\prod_{i \\in I} M_i\\) and define \\[\na \\sim_{\\mathcal{F}} b \\iff \\{\\, i \\in I : a_i = b_i \\,\\} \\in \\mathcal{F}.\n\\]\nThe universe of \\(\\mathcal{M}/\\mathcal{F}\\) is the quotient \\(M / {\\sim_{\\mathcal{F}}}\\), with elements denoted \\(a_{\\mathcal{F}}\\) (alternatively, \\(a/\\mathcal{F}\\)).\n\nRelations:\n\\[\nR^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}})\n: \\iff  \\{\\, i : \\mathcal{M}_i \\models R(\\vec a_i) \\,\\} \\in \\mathcal{F}.\n\\]\nFunctions:\n\\[\nf^{\\mathcal{M}/\\mathcal{F}}(\\vec a_{\\mathcal{F}}) =\n[\\, (f^{\\mathcal{M}_i}(\\vec a_i))_{i \\in I} \\,]_{\\mathcal{F}}.\n\\]\nConstants:\n\\[\nc^{\\mathcal{M}/\\mathcal{F}} = ((c^{\\mathcal{M}_i})_{i\\in I})_{\\mathcal{F}}.\n\\]\n\n\n\n\nLet \\(\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i / \\mathcal{U}\\) be an ultraproduct. For every \\(\\mathcal{L}\\)-formula \\(\\varphi(x_1,\\dots,x_n)\\) and tuples\n\\(\\vec a \\in \\prod_{i \\in I} M_i\\), \\[\n\\mathcal{M}/\\mathcal{U} \\models \\varphi[\\vec a_{\\mathcal{U}}]\n\\iff\n\\{\\, i \\in I : \\mathcal{M}_i \\models \\varphi[\\vec a_i]\\,\\} \\in \\mathcal{U}.\n\\]",
    "crumbs": [
      "10/10 - Problems"
    ]
  },
  {
    "objectID": "017_Oct10_week7_problems.html#problems",
    "href": "017_Oct10_week7_problems.html#problems",
    "title": "Math 557 Oct 10",
    "section": "",
    "text": "Exercise 1 (Principal filters) Show that for every \\(A \\subseteq I\\), \\[\n\\{X \\subseteq I : A \\subseteq X \\}\n\\] is a filter on \\(I\\). Show that it is an ultrafilter if and only if \\(|A| = 1\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 (Finite sets) Show that every ultrafilter on a finite set is principal.\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 (Free ultrafilters on infinite sets) Show that a free ultrafilter on an infinite set \\(I\\) cannot contain any finite subsets of \\(I\\).\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 (Ultrafilter existence) Use Zorn’s Lemma to show that any family \\(\\mathcal{A} \\subseteq \\mathcal{P}(I)\\) with the FIP can be extended to an ultrafilter \\(\\mathcal{U}\\) on \\(I\\).\nUse this to show that any infinite set has a free ultrafilter.\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 (Ultrapoducts with principal ultrafilters) Show that if \\(\\mathcal{U}\\) is a principal ultrafilter on \\(I\\), then every ultraproduct \\[\n\\mathcal{M}/\\mathcal{U} = \\prod_{i \\in I} \\mathcal{M}_i/\\mathcal{U}\n\\] is isomorphic to some \\(\\mathcal{M}_j\\), \\(j \\in I\\).\nFor principal ultrafilters, ultraproducts do not lead to anything new.\n\n\n\n\n\n\n\n\n\n\n\nExercise 6 (Ultraproducts of fields) For any prime \\(p\\) let \\(\\mathbb{F}_p\\) the field with \\(p\\) elements (of characteristic \\(p\\)), and let \\(\\mathcal{U}\\) be a free ultrafilter on the set \\(P\\) of prime numbers.\nShow that the ultraproduct\n\\[\\prod_{p\\in P} \\mathbb{F}_p/\\mathcal{U}\\]\nis a field of characteristic \\(0\\).",
    "crumbs": [
      "10/10 - Problems"
    ]
  },
  {
    "objectID": "017_Oct10_week7_problems.html#ultrapowers",
    "href": "017_Oct10_week7_problems.html#ultrapowers",
    "title": "Math 557 Oct 10",
    "section": "",
    "text": "If we take an ultraproduct over the same structure \\(\\mathcal{M}\\) along an index set \\(I\\), we call this an ultrapower, denoted by \\[\n\\mathcal{M}^I/\\mathcal{U}\n\\]\nLet \\(\\mathcal{U}\\) be a free ultrafilter on an (infinite) set \\(I\\).\n\nShow that the map \\(j: b \\mapsto (b)_{i \\in I}/\\mathcal{U}\\) defines an elementary embedding of \\(\\mathcal{M}\\) into \\(\\mathcal{M}^I/\\mathcal{U}\\) (i.e. it is injective and the image is an elementary substructure).\nShow that if \\(\\mathcal{M}\\) is infinite, \\(j\\) is not a surjection.\n\nIf we apply this to \\(\\mathbb{N}\\) in the language of arithmetic, this yields another way to obtain non-standard models of arithmetic.",
    "crumbs": [
      "10/10 - Problems"
    ]
  },
  {
    "objectID": "017_Oct10_week7_problems.html#further-explorations",
    "href": "017_Oct10_week7_problems.html#further-explorations",
    "title": "Math 557 Oct 10",
    "section": "",
    "text": "Given a language \\(\\mathcal{L}\\), define an equivalence relation of the set of all \\(\\mathcal{L}\\)-sentences by \\[\n\\sigma \\sim \\tau \\; \\iff \\; \\vdash \\sigma \\leftrightarrow \\tau\n\\]\nThe equivalence classes will then form a Boolean algebra, the Lindenbaum-Tarksi algebra \\(\\mathcal{B}\\) with the operations \\[\n\\begin{aligned}\n[\\sigma] \\land [\\tau] & :=  [\\sigma \\land \\tau]\\\\\n[\\sigma] \\lor [\\tau] & := [\\sigma \\lor \\tau] \\\\\n\\neg[\\sigma] & := [\\neg \\sigma]\n\\end{aligned}\n\\] The bottom element is \\(0 :=[\\sigma \\land \\neg \\sigma]\\), the top element is \\(1:= [\\sigma \\lor \\neg \\sigma]\\).\nWe can define an order by putting \\([\\sigma] \\leq [\\tau] : \\iff \\vdash \\sigma \\to \\tau\\). (This corresponds to the order that is defined on any Boolean algebra via \\(a \\leq b :\\Leftrightarrow a = a \\land b\\).)\nA filter on a Boolean algebra is defined in the same way it is defined on a set \\(I\\) (in fact, a filter on a set \\(I\\) is simply a filter on the Boolean algebra induced on its power set by taking intersections, unions, and complements): \\(F \\subseteq \\mathcal{B}\\) is a filter if it does not contain the bottom element, is closed under \\(\\land\\) and closed upward under \\(\\leq\\).\n\nShow that if \\(T\\) is a deductively closed, consistent \\(\\mathcal{L}\\)-theory, the set \\[\n\\{ [\\sigma] : \\sigma \\in T \\}\n\\] is a filter in \\(\\mathcal{B}\\).\nShow that if \\(T\\) is complete, the above filter is an ultrafilter.\n\n\n\n\nFrom Łoś’ Theorem, we know that if two ultrapowers are isomorphic, then the original structures are elementary equivalent. Remarkably, the converse holds, too, and hence gives an algebraic characterization of elementary equivalence.\n\n\n\n\n\n\n\nTheorem 1 (Keisler-Shelah) For any two structures \\(\\mathcal{M}, \\mathcal{N}\\), \\[\n\\mathcal{M} \\equiv \\mathcal{N} \\; \\iff \\; \\text{ there exists an index set $I$ and an ultrafilter $\\mathcal{U}$ on $I$ such that } \\mathcal{M}^I/\\mathcal{U} \\cong \\mathcal{N}^I/\\mathcal{U}\n\\]\n\n\n\n\n\n\n\n\nRamsey theory and ultrafilters",
    "crumbs": [
      "10/10 - Problems"
    ]
  },
  {
    "objectID": "022_Oct24_primitive_recursive.html",
    "href": "022_Oct24_primitive_recursive.html",
    "title": "Math 557 Oct 24",
    "section": "",
    "text": "The following functions are certainly intuitively computable.\n\n\n\nR1\n\\(O(x) = 0\\)\nZero function\n\n\nR2\n\\(S(x)=x+1\\)\nSuccessor function\n\n\nR3\n\\(P^n_i(x_1,\\ldots,x_n) = x_i\\)\ni-th Projection\n\n\n\nBy substituting functions into already given functions we obtain a new function:\n\n\n\n\n\n\n\n\nR4\n\\(f(\\vec{x}) \\simeq h(g_1(\\vec{x}), \\ldots, g_k(\\vec{x}))\\)\nSubstitution\n\n\n\nAnother important way to form new functions is by primitive recursion. According to this pattern the arithmetic operations addition, multiplication and exponentiation are defined.\n\n\n\nR5\n\\(f(\\vec{x},0) \\simeq g(\\vec{x})\\)\nPrimitive recursion\n\n\n\n\\(f(\\vec{x},y+1) \\simeq h(\\vec{x},y,f(\\vec{x},y))\\)\n\n\n\n\n\nDefinition 1The class PRIM of all primitive recursive (abbreviated: p.r.) functions is the smallest class of functions that contains the initial functions and is closed under substitution and primitive recursion. These functions are in particular total functions.\n\n\n\n\nThe following functions are primitive recursive:\n\n\n\n\n\\(x+y\\)\nSum\n\n\n\n\\(x\\cdot y\\)\nProduct\n\n\n\n\\(x^y\\)\nExponentiation\n\n\n\n\\(\\max(x,y)\\)\nMaximum\n\n\n\n\\(\\min(x,y)\\)\nMinimum\n\n\n\n\\(|x-y|\\)\nAbsolute difference\n\n\n\nand moreover,\n\\[x\\dot{-} y = \\begin{cases}\n  x - y   & \\text{if} \\; x \\ge y, \\\\\n  0   & \\text{otherwise}\n\\end{cases} \\qquad \\text{\\emph{Monus (difference on $\\mathbb{N}$)}}\\]\n\\[sg(x) = \\begin{cases}\n  0   & \\text{if} \\; x =0, \\\\\n  1   & \\text{if} \\; x &gt; 0\n\\end{cases} \\qquad \\text{\\emph{Sign function}}\\]\n\\[\\overline{sg}(x) = \\begin{cases}\n  1   & \\text{if} \\; x = 0, \\\\\n  0   & \\text{if} \\; x &gt; 0\n\\end{cases} \\qquad \\text{\\emph{Negated sign function}}\\]\n\nProof. Addition, multiplication and exponentiation are obviously primitive recursive. For the remaining cases one first shows that the predecessor function \\(x \\dot{-} 1\\) is primitive recursive, namely because\n\\[\n\\begin{aligned}\n0 \\dot{-} 1 &= 0\\\\\n(x+1) \\dot{-} 1 &= x\n\\end{aligned}\n\\]\nand then defines \\(\\dot{-}\\) by primitive recursion\n\\[\n\\begin{aligned}\nx \\dot{-} 0 &= x\\\\\nx \\dot{-} (y+1) &= (x \\dot{-} y) \\dot{-} 1\n\\end{aligned}\n\\]\nThe remaining functions can be defined directly using \\(+\\) and \\(\\dot{-}\\):\n\\[\n\\begin{aligned}\n|x-y| &= (x\\dot{-} y) + (y\\dot{-} x)\\\\\n\\max (x,y) &= x+(y\\dot{-} x)\\\\\n\\min (x,y) &= \\max(x,y)\\dot{-} |x-y|\\\\\n\\overline{sg}(x) &= 1\\dot{-} x\\\\\nsg(x) &= 1\\dot{-} \\overline{sg} (x)\n\\end{aligned}\n\\]\n\n\n\n\n\nExercise 1Show that primitive recursive functions are closed under\n(i) Case distinction:\nIf \\(g, f_0,f_1,\\ldots,f_k\\) are primitive recursive, then so is f with\n\\[f(\\vec{x})= \\begin{cases}\n    f_0(\\vec{x})  & \\text{if}  \\quad  g(\\vec{x}) =0, \\\\\n     f_1(\\vec{x})  & \\text{if}  \\quad  g(\\vec{x}) =1, \\\\\n     \\vdots         &  \\vdots \\\\\n      f_k(\\vec{x})  & \\text{if}  \\quad  g(\\vec{x}) \\ge k.\n\\end{cases}\\]\nand\n(ii) Bounded \\(\\mu\\)-operator:\nIf \\(g\\) is primitive recursive, then so is f with\n\\[\nf(\\vec{x},z) = \\mu y &lt; z \\; (g(\\vec{x},y) = 0),\n\\]\nwhere\n\\[\\mu y &lt; z \\; R(\\vec{x},y) = \\begin{cases}\n    \\text{the smallest } y &lt; z \\text{ with } R(\\vec{x},y)  &  \\text{if such $y$ exists} \\\\\n      z & \\text{otherwise}.\n\\end{cases}\\]\n\n\n\n\n\n\nAn example of a computable but not primitive recursive function is the Ackermann function. This is a 2-ary function that is recursively defined by the following equations:\n\\[\n\\begin{aligned}\nA(0,y) &= y+1\\\\\nA(x+1,0)&= A(x,1)\\\\\nA(x+1,y+1)&= A(x,A(x+1,y))\n\\end{aligned}\n\\]\nThis is a double recursion, yet one can easily verify that each value \\(A(x,y)\\) is determined by finitely many “earlier” values \\(A(u,v)\\) with \\(u&lt;x\\) or \\(u=x \\wedge v&lt;y\\). Writing \\(F_n(m)\\) for \\(A(n,m)\\), we obtain:\n\\[\n\\begin{aligned}\nF_0(m)   &= m+1\\\\\nF_1(m)  &= m+2\\\\\nF_2(m) & \\approx 2m\\\\\nF_3(m) & \\approx 2^m\\\\\nF_4(m) & \\approx  2^{2^{.^{.^{.^{2}}}}} \\text{ ($m$ times)}\n\\end{aligned}\n\\]\nThis means that the Ackermann function iterates the basic arithmetic operations and grows very rapidly, particularly in the first argument (which indicates the number of iterations). In fact, it majorizes every primitive recursive function: If \\(f\\) is a \\(k\\)-ary p.r. function, then there exists a number \\(n\\) with\n\\[\nf(x_1,\\ldots,x_k) \\le F_n(\\max(x_1,\\ldots,x_k))\n\\]\nfor all \\(x_1,\\ldots,x_k\\). Thus the 2-ary function \\(A\\) cannot be p.r. (although on the other hand all \\(F_n\\) are primitive recursive). That the Ackermann function is nevertheless computable can be seen from the fact that it can be obtained from a p.r. function by means of minimalization:\n\n\n\n\n\n\n\n\nR6\n\\(f(\\vec{x}) \\simeq  \\mu y \\; (g(\\vec{x},y)\\simeq 0)\\)\n\\(\\mu\\)-operator\n\n\n\nthat is,\n\\[f(\\vec{x}) = \\begin{cases}\n  \\text{the smallest } y \\text{ such that}  &  \\text{if such a } y \\text{ exists},\\\\  \n    \\qquad (i) \\;  g(\\vec{x},z)\\;  \\text{is defined for all} \\; z\\le y \\;  \\text{and} \\\\\n    \\qquad (ii)   \\;  g(\\vec{x},y)=0, \\qquad  \\qquad \\qquad  \\\\\n    \\text{undefined}  &  \\text{otherwise}.\n\\end{cases}\\]\nThis principle can lead from total to partial functions (e.g., for \\(g(x,y)=|x-y^2|\\), as a function over \\(\\mathbb{N}\\times \\mathbb{N}\\)).\n\nDefinition 2The class R of all recursive functions is the smallest class of functions that contains the initial functions and is closed under substitution, primitive recursion and minimalization. These functions are often also referred to as general recursive, \\(\\mu\\)-recursive functions or (based on the Church-Turing thesis) as computable functions. We will use recursive functions primarily to denote total (i.e. everywhere defined) computable functions. If the functions involved are partial, we will use partial recursive and partial computable.\n\n\nThus every primitive recursive function is also a recursive function (while the Ackermann function is an example of a recursive, but not p.r. function), and the closure properties from previous sections (suitably modified for partial functions) also hold for recursive functions.\n\n\n\nDefinition 3A number-theoretic relation \\(R \\subseteq \\mathbb{N}^k\\) is called (primitive) recursive if and only if its characteristic function \\(c_R\\) is (primitive) recursive, where\n\\[c_R(\\vec{x}) = \\begin{cases}\n    1  & \\text{if } \\; R(\\vec{x}), \\\\\n     0 & \\text{otherwise}.\n\\end{cases}\\]\n\n\nThus, for example, the predicates \\(x=y,\\, x \\ne y, \\, x \\le y, \\, x&lt;y\\) are primitive recursive. Recursive relations are also called decidable.\n\nDefinition 4A relation \\(R \\subseteq \\mathbb{N}^k\\) is called recursively enumerable (r.e.), often also computably enumerable (c.e.) if it is the domain of a partial computable function:\n\\[R \\; \\text{r.e.} :\\iff R =  \\{\\vec{x}\\mid f(\\vec{x})\\downarrow \\} \\; \\text{ for a computable function } \\; f.\\]\n\n\n\n\n\n\nA non-empty set \\(A \\subseteq \\mathbb{N}^k\\) is r.e. if and only if \\(A\\) is the range of a total computable function.\nIf \\(R\\) is a decidable relation, then there is an effective procedure that determines if \\(R\\) holds or not. An r.e. set is also called semi-decidable, since in this case we have a procedure to list the elements.\nIf both a relation and its complement are r.e., we can run both listing procedures in parallel and wait until an element gets listed. Thus \\[\nA \\text{ decidable} \\quad \\Leftrightarrow \\quad A \\text{ and } \\mathbb{N}^k \\setminus A \\text{ are r.e.}\n\\]\nWe will later see that if \\(T\\) is a theory consisting of a computable set of sentences, its deductive closure \\[\n\\{\\sigma : T \\vdash \\sigma\\}\n\\] is r.e.. If \\(T\\) is complete, this will imply that the deductive closure is decidable.",
    "crumbs": [
      "10/24 - Primtive recursion"
    ]
  },
  {
    "objectID": "022_Oct24_primitive_recursive.html#primitive-recursion",
    "href": "022_Oct24_primitive_recursive.html#primitive-recursion",
    "title": "Math 557 Oct 24",
    "section": "",
    "text": "The following functions are certainly intuitively computable.\n\n\n\nR1\n\\(O(x) = 0\\)\nZero function\n\n\nR2\n\\(S(x)=x+1\\)\nSuccessor function\n\n\nR3\n\\(P^n_i(x_1,\\ldots,x_n) = x_i\\)\ni-th Projection\n\n\n\nBy substituting functions into already given functions we obtain a new function:\n\n\n\n\n\n\n\n\nR4\n\\(f(\\vec{x}) \\simeq h(g_1(\\vec{x}), \\ldots, g_k(\\vec{x}))\\)\nSubstitution\n\n\n\nAnother important way to form new functions is by primitive recursion. According to this pattern the arithmetic operations addition, multiplication and exponentiation are defined.\n\n\n\nR5\n\\(f(\\vec{x},0) \\simeq g(\\vec{x})\\)\nPrimitive recursion\n\n\n\n\\(f(\\vec{x},y+1) \\simeq h(\\vec{x},y,f(\\vec{x},y))\\)\n\n\n\n\n\nDefinition 1The class PRIM of all primitive recursive (abbreviated: p.r.) functions is the smallest class of functions that contains the initial functions and is closed under substitution and primitive recursion. These functions are in particular total functions.\n\n\n\n\nThe following functions are primitive recursive:\n\n\n\n\n\\(x+y\\)\nSum\n\n\n\n\\(x\\cdot y\\)\nProduct\n\n\n\n\\(x^y\\)\nExponentiation\n\n\n\n\\(\\max(x,y)\\)\nMaximum\n\n\n\n\\(\\min(x,y)\\)\nMinimum\n\n\n\n\\(|x-y|\\)\nAbsolute difference\n\n\n\nand moreover,\n\\[x\\dot{-} y = \\begin{cases}\n  x - y   & \\text{if} \\; x \\ge y, \\\\\n  0   & \\text{otherwise}\n\\end{cases} \\qquad \\text{\\emph{Monus (difference on $\\mathbb{N}$)}}\\]\n\\[sg(x) = \\begin{cases}\n  0   & \\text{if} \\; x =0, \\\\\n  1   & \\text{if} \\; x &gt; 0\n\\end{cases} \\qquad \\text{\\emph{Sign function}}\\]\n\\[\\overline{sg}(x) = \\begin{cases}\n  1   & \\text{if} \\; x = 0, \\\\\n  0   & \\text{if} \\; x &gt; 0\n\\end{cases} \\qquad \\text{\\emph{Negated sign function}}\\]\n\nProof. Addition, multiplication and exponentiation are obviously primitive recursive. For the remaining cases one first shows that the predecessor function \\(x \\dot{-} 1\\) is primitive recursive, namely because\n\\[\n\\begin{aligned}\n0 \\dot{-} 1 &= 0\\\\\n(x+1) \\dot{-} 1 &= x\n\\end{aligned}\n\\]\nand then defines \\(\\dot{-}\\) by primitive recursion\n\\[\n\\begin{aligned}\nx \\dot{-} 0 &= x\\\\\nx \\dot{-} (y+1) &= (x \\dot{-} y) \\dot{-} 1\n\\end{aligned}\n\\]\nThe remaining functions can be defined directly using \\(+\\) and \\(\\dot{-}\\):\n\\[\n\\begin{aligned}\n|x-y| &= (x\\dot{-} y) + (y\\dot{-} x)\\\\\n\\max (x,y) &= x+(y\\dot{-} x)\\\\\n\\min (x,y) &= \\max(x,y)\\dot{-} |x-y|\\\\\n\\overline{sg}(x) &= 1\\dot{-} x\\\\\nsg(x) &= 1\\dot{-} \\overline{sg} (x)\n\\end{aligned}\n\\]\n\n\n\n\n\nExercise 1Show that primitive recursive functions are closed under\n(i) Case distinction:\nIf \\(g, f_0,f_1,\\ldots,f_k\\) are primitive recursive, then so is f with\n\\[f(\\vec{x})= \\begin{cases}\n    f_0(\\vec{x})  & \\text{if}  \\quad  g(\\vec{x}) =0, \\\\\n     f_1(\\vec{x})  & \\text{if}  \\quad  g(\\vec{x}) =1, \\\\\n     \\vdots         &  \\vdots \\\\\n      f_k(\\vec{x})  & \\text{if}  \\quad  g(\\vec{x}) \\ge k.\n\\end{cases}\\]\nand\n(ii) Bounded \\(\\mu\\)-operator:\nIf \\(g\\) is primitive recursive, then so is f with\n\\[\nf(\\vec{x},z) = \\mu y &lt; z \\; (g(\\vec{x},y) = 0),\n\\]\nwhere\n\\[\\mu y &lt; z \\; R(\\vec{x},y) = \\begin{cases}\n    \\text{the smallest } y &lt; z \\text{ with } R(\\vec{x},y)  &  \\text{if such $y$ exists} \\\\\n      z & \\text{otherwise}.\n\\end{cases}\\]",
    "crumbs": [
      "10/24 - Primtive recursion"
    ]
  },
  {
    "objectID": "022_Oct24_primitive_recursive.html#recursive-and-partially-recursive-functions",
    "href": "022_Oct24_primitive_recursive.html#recursive-and-partially-recursive-functions",
    "title": "Math 557 Oct 24",
    "section": "",
    "text": "An example of a computable but not primitive recursive function is the Ackermann function. This is a 2-ary function that is recursively defined by the following equations:\n\\[\n\\begin{aligned}\nA(0,y) &= y+1\\\\\nA(x+1,0)&= A(x,1)\\\\\nA(x+1,y+1)&= A(x,A(x+1,y))\n\\end{aligned}\n\\]\nThis is a double recursion, yet one can easily verify that each value \\(A(x,y)\\) is determined by finitely many “earlier” values \\(A(u,v)\\) with \\(u&lt;x\\) or \\(u=x \\wedge v&lt;y\\). Writing \\(F_n(m)\\) for \\(A(n,m)\\), we obtain:\n\\[\n\\begin{aligned}\nF_0(m)   &= m+1\\\\\nF_1(m)  &= m+2\\\\\nF_2(m) & \\approx 2m\\\\\nF_3(m) & \\approx 2^m\\\\\nF_4(m) & \\approx  2^{2^{.^{.^{.^{2}}}}} \\text{ ($m$ times)}\n\\end{aligned}\n\\]\nThis means that the Ackermann function iterates the basic arithmetic operations and grows very rapidly, particularly in the first argument (which indicates the number of iterations). In fact, it majorizes every primitive recursive function: If \\(f\\) is a \\(k\\)-ary p.r. function, then there exists a number \\(n\\) with\n\\[\nf(x_1,\\ldots,x_k) \\le F_n(\\max(x_1,\\ldots,x_k))\n\\]\nfor all \\(x_1,\\ldots,x_k\\). Thus the 2-ary function \\(A\\) cannot be p.r. (although on the other hand all \\(F_n\\) are primitive recursive). That the Ackermann function is nevertheless computable can be seen from the fact that it can be obtained from a p.r. function by means of minimalization:\n\n\n\n\n\n\n\n\nR6\n\\(f(\\vec{x}) \\simeq  \\mu y \\; (g(\\vec{x},y)\\simeq 0)\\)\n\\(\\mu\\)-operator\n\n\n\nthat is,\n\\[f(\\vec{x}) = \\begin{cases}\n  \\text{the smallest } y \\text{ such that}  &  \\text{if such a } y \\text{ exists},\\\\  \n    \\qquad (i) \\;  g(\\vec{x},z)\\;  \\text{is defined for all} \\; z\\le y \\;  \\text{and} \\\\\n    \\qquad (ii)   \\;  g(\\vec{x},y)=0, \\qquad  \\qquad \\qquad  \\\\\n    \\text{undefined}  &  \\text{otherwise}.\n\\end{cases}\\]\nThis principle can lead from total to partial functions (e.g., for \\(g(x,y)=|x-y^2|\\), as a function over \\(\\mathbb{N}\\times \\mathbb{N}\\)).\n\nDefinition 2The class R of all recursive functions is the smallest class of functions that contains the initial functions and is closed under substitution, primitive recursion and minimalization. These functions are often also referred to as general recursive, \\(\\mu\\)-recursive functions or (based on the Church-Turing thesis) as computable functions. We will use recursive functions primarily to denote total (i.e. everywhere defined) computable functions. If the functions involved are partial, we will use partial recursive and partial computable.\n\n\nThus every primitive recursive function is also a recursive function (while the Ackermann function is an example of a recursive, but not p.r. function), and the closure properties from previous sections (suitably modified for partial functions) also hold for recursive functions.\n\n\n\nDefinition 3A number-theoretic relation \\(R \\subseteq \\mathbb{N}^k\\) is called (primitive) recursive if and only if its characteristic function \\(c_R\\) is (primitive) recursive, where\n\\[c_R(\\vec{x}) = \\begin{cases}\n    1  & \\text{if } \\; R(\\vec{x}), \\\\\n     0 & \\text{otherwise}.\n\\end{cases}\\]\n\n\nThus, for example, the predicates \\(x=y,\\, x \\ne y, \\, x \\le y, \\, x&lt;y\\) are primitive recursive. Recursive relations are also called decidable.\n\nDefinition 4A relation \\(R \\subseteq \\mathbb{N}^k\\) is called recursively enumerable (r.e.), often also computably enumerable (c.e.) if it is the domain of a partial computable function:\n\\[R \\; \\text{r.e.} :\\iff R =  \\{\\vec{x}\\mid f(\\vec{x})\\downarrow \\} \\; \\text{ for a computable function } \\; f.\\]\n\n\n\n\n\n\nA non-empty set \\(A \\subseteq \\mathbb{N}^k\\) is r.e. if and only if \\(A\\) is the range of a total computable function.\nIf \\(R\\) is a decidable relation, then there is an effective procedure that determines if \\(R\\) holds or not. An r.e. set is also called semi-decidable, since in this case we have a procedure to list the elements.\nIf both a relation and its complement are r.e., we can run both listing procedures in parallel and wait until an element gets listed. Thus \\[\nA \\text{ decidable} \\quad \\Leftrightarrow \\quad A \\text{ and } \\mathbb{N}^k \\setminus A \\text{ are r.e.}\n\\]\nWe will later see that if \\(T\\) is a theory consisting of a computable set of sentences, its deductive closure \\[\n\\{\\sigma : T \\vdash \\sigma\\}\n\\] is r.e.. If \\(T\\) is complete, this will imply that the deductive closure is decidable.",
    "crumbs": [
      "10/24 - Primtive recursion"
    ]
  },
  {
    "objectID": "CLAUDE.html",
    "href": "CLAUDE.html",
    "title": "CLAUDE.md",
    "section": "",
    "text": "This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n\nThis is a Quarto website for Math 557 (Mathematical Logic) course materials at Penn State, Fall 2025. The site contains lecture notes organized chronologically, covering topics from basic syntax and semantics through the Löwenheim-Skolem theorems.\n\n\n\n\nSource files: .qmd files containing lecture notes (e.g., 001_Aug27_syntax.qmd, 014_Oct03_elementary_substructures.qmd)\n\nNaming convention: NNN_MonDD_topic.qmd where NNN is a sequence number\nEach file is standalone and represents one lecture date\n\nLaTeX files: Some lecture notes exist as .tex files (e.g., mathlogik_kapitel_4.tex, 014_Oct06_loewenheim_skolem.tex)\n\nGerman-language reference material\n\nConfiguration: _quarto.yml contains website configuration and sidebar navigation\nOutput: _site/ directory (git-ignored) contains rendered HTML\nExtensions: Two Quarto extensions in _extensions/:\n\ncallouty-theorem: Creates theorem-like callouts (exercises use #exr- with callout-type: tip)\nsearch-replace: Defines shortcuts like +L → $\\mathcal{L}$\n\n\n\n\n\n\n\nquarto preview\nStarts a local server with live reload at http://localhost:4200\n\n\n\nquarto render\nOutputs to _site/ directory\n\n\n\nquarto render 014_Oct03_elementary_substructures.qmd\n\n\n\nquarto render &lt;file&gt;.qmd --to pdf\n\n\n\n\n\n\nEach .qmd lecture file follows this pattern: - YAML frontmatter with title (e.g., title: \"Math 557 Oct 3\") - Main heading with topic (e.g., # Elementary Substructures) - Optional subsections (e.g., ## Key Concepts, ## Problems) - Exercises marked with ::: {#exr-} callout blocks - Math notation using LaTeX syntax - Special callouts like {.callout-important} for take-home problems\n\n\n\nThe sidebar is configured in _quarto.yml under website.sidebar.contents. When adding new lecture notes: 1. Create the .qmd file with appropriate naming (sequence number, date, topic) 2. Add an entry to the sidebar with href and text (typically the date) 3. Entries appear in order listed in the config file\n\n\n\nThe search-replace extension provides text shortcuts: - +L expands to $\\mathcal{L}$ (the language symbol) - To add more shortcuts, edit the search-replace section in _quarto.yml\n\n\n\n\n\n\n\nCreate file: NNN_MonDD_topic.qmd (increment sequence number)\nAdd YAML frontmatter with title\nAdd to sidebar in _quarto.yml\nUse standard formatting patterns (see existing files)\n\n\n\n\n\nLegacy .tex files exist (in German) for reference\nActive development uses .qmd format\nSome content may need to be converted from .tex to .qmd format\nWhen converting, preserve mathematical notation and structure but adapt to QMD callout syntax"
  },
  {
    "objectID": "CLAUDE.html#overview",
    "href": "CLAUDE.html#overview",
    "title": "CLAUDE.md",
    "section": "",
    "text": "This is a Quarto website for Math 557 (Mathematical Logic) course materials at Penn State, Fall 2025. The site contains lecture notes organized chronologically, covering topics from basic syntax and semantics through the Löwenheim-Skolem theorems."
  },
  {
    "objectID": "CLAUDE.html#project-structure",
    "href": "CLAUDE.html#project-structure",
    "title": "CLAUDE.md",
    "section": "",
    "text": "Source files: .qmd files containing lecture notes (e.g., 001_Aug27_syntax.qmd, 014_Oct03_elementary_substructures.qmd)\n\nNaming convention: NNN_MonDD_topic.qmd where NNN is a sequence number\nEach file is standalone and represents one lecture date\n\nLaTeX files: Some lecture notes exist as .tex files (e.g., mathlogik_kapitel_4.tex, 014_Oct06_loewenheim_skolem.tex)\n\nGerman-language reference material\n\nConfiguration: _quarto.yml contains website configuration and sidebar navigation\nOutput: _site/ directory (git-ignored) contains rendered HTML\nExtensions: Two Quarto extensions in _extensions/:\n\ncallouty-theorem: Creates theorem-like callouts (exercises use #exr- with callout-type: tip)\nsearch-replace: Defines shortcuts like +L → $\\mathcal{L}$"
  },
  {
    "objectID": "CLAUDE.html#common-commands",
    "href": "CLAUDE.html#common-commands",
    "title": "CLAUDE.md",
    "section": "",
    "text": "quarto preview\nStarts a local server with live reload at http://localhost:4200\n\n\n\nquarto render\nOutputs to _site/ directory\n\n\n\nquarto render 014_Oct03_elementary_substructures.qmd\n\n\n\nquarto render &lt;file&gt;.qmd --to pdf"
  },
  {
    "objectID": "CLAUDE.html#content-architecture",
    "href": "CLAUDE.html#content-architecture",
    "title": "CLAUDE.md",
    "section": "",
    "text": "Each .qmd lecture file follows this pattern: - YAML frontmatter with title (e.g., title: \"Math 557 Oct 3\") - Main heading with topic (e.g., # Elementary Substructures) - Optional subsections (e.g., ## Key Concepts, ## Problems) - Exercises marked with ::: {#exr-} callout blocks - Math notation using LaTeX syntax - Special callouts like {.callout-important} for take-home problems\n\n\n\nThe sidebar is configured in _quarto.yml under website.sidebar.contents. When adding new lecture notes: 1. Create the .qmd file with appropriate naming (sequence number, date, topic) 2. Add an entry to the sidebar with href and text (typically the date) 3. Entries appear in order listed in the config file\n\n\n\nThe search-replace extension provides text shortcuts: - +L expands to $\\mathcal{L}$ (the language symbol) - To add more shortcuts, edit the search-replace section in _quarto.yml"
  },
  {
    "objectID": "CLAUDE.html#working-with-content",
    "href": "CLAUDE.html#working-with-content",
    "title": "CLAUDE.md",
    "section": "",
    "text": "Create file: NNN_MonDD_topic.qmd (increment sequence number)\nAdd YAML frontmatter with title\nAdd to sidebar in _quarto.yml\nUse standard formatting patterns (see existing files)\n\n\n\n\n\nLegacy .tex files exist (in German) for reference\nActive development uses .qmd format\nSome content may need to be converted from .tex to .qmd format\nWhen converting, preserve mathematical notation and structure but adapt to QMD callout syntax"
  }
]